//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_SSO_URL = new InjectionToken<string>('API_SSO_URL');

@Injectable()
export class SSO_ApplicationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteLogCache(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Application/DeleteLogCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLogCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLogCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLogCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenant (optional) 
     * @return Success
     */
    resetCacheSSOsync(tenant: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Application/ResetCacheSSOsync?";
        if (tenant === null)
            throw new Error("The parameter 'tenant' cannot be null.");
        else if (tenant !== undefined)
            url_ += "tenant=" + encodeURIComponent("" + tenant) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetCacheSSOsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetCacheSSOsync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetCacheSSOsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    setQuyenUser(email: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Application/SetQuyenUser?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetQuyenUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetQuyenUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetQuyenUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    resetUser(email: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Application/ResetUser?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SSOCategoryGuidGetDto | undefined): Observable<SSOCategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Category/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOCategoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOCategoryOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SSOCategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SSOCategoryOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SSOCategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Category/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOCategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOCategoryOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SSOCategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SSOCategoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SSOCategoryInputDto | undefined): Observable<SSOCategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOCategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOCategoryOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SSOCategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SSOCategoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SSOCategoryInputDto | undefined): Observable<SSOCategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOCategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOCategoryOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SSOCategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SSOCategoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPermissions(body: SSOCategoryInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/SetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_DataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getTitle(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Data/GetTitle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetTitle(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_DataOrganizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOrganization(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/DataOrganization/GetOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetOrganization(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_DataUserOrganizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserOrganization(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/DataUserOrganization/GetUserOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetUserOrganization(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_FamilyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: FamilyGuidGetDto | undefined): Observable<FamilyDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Family/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByUserId(body: Int64EntityDto | undefined): Observable<FamilyDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Family/GetByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDto[]>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<FamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByListUserId(body: GetByListUserDto | undefined): Observable<FamilyDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Family/GetByListUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByListUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByListUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDto[]>;
        }));
    }

    protected processGetByListUserId(response: HttpResponseBase): Observable<FamilyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FamilyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    joinFamily(body: InputFamilyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Family/JoinFamily";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinFamily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinFamily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processJoinFamily(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmUser(body: ConfirmFamilyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Family/ConfirmUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Family/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_MenuClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: MenuGuidGetDto | undefined): Observable<MenuOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Menu/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MenuOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Menu/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: MenuInputDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Menu/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MenuInputDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Menu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Menu/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: MenuInputDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Menu/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_MenuClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: MenuGuidGetDto | undefined): Observable<MenuOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/MenuClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MenuOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/MenuClient/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_NotificationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserNotificationCount(body: GetUserNotificationsDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/sso/read/Notification/GetUserNotificationCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetUserNotificationCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserNotifications(body: GetUserNotificationsDto | undefined): Observable<UserNotification[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Notification/GetUserNotifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserNotification[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserNotification[]>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<UserNotification[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserNotification.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserNotificationsString(body: GetUserNotificationsDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sso/read/Notification/GetUserNotificationsString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationsString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationsString(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetUserNotificationsString(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishNotification(body: RelationNotificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Notification/PublishNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublishNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAllUserNotification(body: AllUserNotificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Notification/DeleteAllUserNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllUserNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteUserNotification(body: UserNotificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Notification/DeleteUserNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllUserNotificationState(body: AllUserNotificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Notification/UpdateAllUserNotificationState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllUserNotificationState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllUserNotificationState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllUserNotificationState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserNotificationState(body: UserNotificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Notification/UpdateUserNotificationState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserNotificationState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserNotificationState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserNotificationState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_OrganizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: OrganizationGuidGetDto | undefined): Observable<OrganizationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Organization/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<OrganizationOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLevel(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Organization/GetLevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetLevel(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Organization/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: OrganizationInputDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: OrganizationInputDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: OrganizationInputDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTitles(body: OrganizationTitlesDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/SetTitles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTitles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTitles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetTitles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setCategories(body: OrganizationCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/SetCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_OrganizationClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: OrganizationGuidGetDto | undefined): Observable<OrganizationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<OrganizationOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_OrganizationUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOrganizationUser(body: OrganizationUserGuidGetDto | undefined): Observable<OrganizationUserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserOutputDto[]>;
        }));
    }

    protected processGetOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getClientOrganizationUser(body: OrganizationUserGuidGetDto | undefined): Observable<OrganizationUserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetClientOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserOutputDto[]>;
        }));
    }

    protected processGetClientOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserNotInOrganization(body: OrganizationUserGuidGetDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetUserNotInOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotInOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotInOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processGetUserNotInOrganization(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllTenantOrganizationByUserId(body: GetOrganizationUserDto | undefined): Observable<TenantOrganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetAllTenantOrganizationByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenantOrganizationByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenantOrganizationByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantOrganizationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantOrganizationDto[]>;
        }));
    }

    protected processGetAllTenantOrganizationByUserId(response: HttpResponseBase): Observable<TenantOrganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantOrganizationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByUserId(body: GetOrganizationUserDto | undefined): Observable<OrganizationUserOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserOutputDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<OrganizationUserOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOrganizationalChart(body: OrganizationalChartInputDto | undefined): Observable<OrganizationChartDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetOrganizationalChart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationalChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationalChart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationChartDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationChartDto>;
        }));
    }

    protected processGetOrganizationalChart(response: HttpResponseBase): Observable<OrganizationChartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationChartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inviteUser(body: OrganizationUserInputDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/InviteUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInviteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processInviteUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmInviteUser(body: ConfirmOrganizationUserDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/ConfirmInviteUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmInviteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmInviteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processConfirmInviteUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userJoinOrganization(body: OrganizationUserInputDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/UserJoinOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserJoinOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserJoinOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processUserJoinOrganization(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmUser(body: ConfirmOrganizationUserDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/ConfirmUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processConfirmUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrganizationUser(body: AddOrganizationUserDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/AddOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processAddOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/SetOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processSetOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    remove(body: OrganizationUserInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/Remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lockOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/LockOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processLockOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unLockOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/UnLockOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnLockOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnLockOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processUnLockOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    leaveOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<OrganizationUserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/LeaveOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeaveOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeaveOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUserDto>;
        }));
    }

    protected processLeaveOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/RemoveOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveOrganizationUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_PermissionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TenantPermissionGuidGetDto | undefined): Observable<PermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Permission/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PermissionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<PermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Permission/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PermissionInputDto | undefined): Observable<PermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Permission/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PermissionInputDto | undefined): Observable<PermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Permission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Permission/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: PermissionInputDto[] | null | undefined): Observable<PermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/write/Permission/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto[]>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<PermissionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_PermissionClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TenantPermissionGuidGetDto | undefined): Observable<PermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/PermissionClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PermissionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_RegistrationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidTenant(body: CheckValidTenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/read/Registration/CheckValidTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckValidTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantDto | undefined): Observable<RegisterResultDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Registration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterResultDto>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerUser(body: RegisterUserDto | undefined): Observable<RegisterResultDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Registration/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterResultDto>;
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<RegisterResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerListUser(body: RegisterUserDto[] | null | undefined): Observable<RegisterUserDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/write/Registration/RegisterListUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterListUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterUserDto[]>;
        }));
    }

    protected processRegisterListUser(response: HttpResponseBase): Observable<RegisterUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegisterUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerOrUpdateListUser(body: RegisterUserDto[] | null | undefined): Observable<RegisterUserDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/write/Registration/RegisterOrUpdateListUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterOrUpdateListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterOrUpdateListUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterUserDto[]>;
        }));
    }

    protected processRegisterOrUpdateListUser(response: HttpResponseBase): Observable<RegisterUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegisterUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_SendEmailJobClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMail(body: SendEmailJobArgs | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/SendEmailJob/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendListMail(body: SendEmailJobArgs[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/SendEmailJob/SendListMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendListMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendListMail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendListMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_SettingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByName(input: string | null | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Setting/GetByName?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createByTenant(body: SettingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Setting/CreateByTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateByTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateByTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateByTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SettingDto | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Setting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SettingDto | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Setting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Setting/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_SSOClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListTenantByApplication(body: GuidEntityDto | undefined): Observable<TenantDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetListTenantByApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListTenantByApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListTenantByApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto[]>;
        }));
    }

    protected processGetListTenantByApplication(response: HttpResponseBase): Observable<TenantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllClient(body: Int32EntityDto | undefined): Observable<ClientSSOOrganizationUserDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetAllClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSSOOrganizationUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSSOOrganizationUserDto[]>;
        }));
    }

    protected processGetAllClient(response: HttpResponseBase): Observable<ClientSSOOrganizationUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSSOOrganizationUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<SSOOrganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOOrganizationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOOrganizationDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SSOOrganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SSOOrganizationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllInfinity(): Observable<SSOOrganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetAllInfinity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInfinity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInfinity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOOrganizationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOOrganizationDto[]>;
        }));
    }

    protected processGetAllInfinity(response: HttpResponseBase): Observable<SSOOrganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SSOOrganizationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getClientOrganizationUser(body: ValidationShareKeyDto | undefined): Observable<SSOOrganizationUserDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetClientOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOOrganizationUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOOrganizationUserDto[]>;
        }));
    }

    protected processGetClientOrganizationUser(response: HttpResponseBase): Observable<SSOOrganizationUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SSOOrganizationUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOrganizationUser(body: ValidationShareKeyDto | undefined): Observable<SSOOrganizationUserDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOOrganizationUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOOrganizationUserDto[]>;
        }));
    }

    protected processGetOrganizationUser(response: HttpResponseBase): Observable<SSOOrganizationUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SSOOrganizationUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getLevel(body: ValidationShareKeyDto | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/GetLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetLevel(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkShareKey(body: ValidationShareKeyDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/read/SSO/CheckShareKey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckShareKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckShareKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckShareKey(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_TemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Template/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TemplateGuidGetDto | undefined): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Template/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByGroup(body: TemplateGuidGetDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Template/GetByGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processGetByGroup(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    systemGet(body: GuidEntityDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Template/SystemGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSystemGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSystemGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processSystemGet(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    systemGetList(body: TemplateGuidGetDto | undefined): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Template/SystemGetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSystemGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSystemGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto[]>;
        }));
    }

    protected processSystemGetList(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TemplateDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Template/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TemplateDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Template/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Template/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    systemCreate(body: TemplateDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Template/SystemCreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSystemCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSystemCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processSystemCreate(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    systemUpdate(body: TemplateDto | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Template/SystemUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSystemUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSystemUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processSystemUpdate(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    systemDelete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Template/SystemDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSystemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSystemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSystemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_TenantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getCurrentProfile(): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Tenant/GetCurrentProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGetCurrentProfile(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllTenants(): Observable<TenantDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Tenant/GetAllTenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto[]>;
        }));
    }

    protected processGetAllTenants(response: HttpResponseBase): Observable<TenantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkTenancyName(body: CheckValidTenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/read/Tenant/CheckTenancyName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTenancyName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTenancyName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckTenancyName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getTenant(input: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Tenant/GetTenant?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGetTenant(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTenant(body: TenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/write/Tenant/AddTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/write/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addApplication(body: ApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Tenant/AddApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateApplication(body: ApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Tenant/UpdateApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeApplication(body: ApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Tenant/RemoveApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_TitleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TitleGuidGetDto | undefined): Observable<TitleOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Title/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TitleOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TitleOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<TitleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Title/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TitleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    removeCache2(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/RemoveCache2";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCache2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCache2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveCache2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TitleInputDto | undefined): Observable<TitleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TitleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TitleInputDto | undefined): Observable<TitleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TitleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPermissions(body: TitlePermissionsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/SetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: TitleInputDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_TitleClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TitleGuidGetDto | undefined): Observable<TitleOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/TitleClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TitleOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TitleOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_TokenAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    joinTenant(body: TenantModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/JoinTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processJoinTenant(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extToken(body: UserModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExtToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processExtToken(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeToken(body: UserTenantModel | undefined): Observable<AuthenticateResultModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/ChangeToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel[]>;
        }));
    }

    protected processChangeToken(response: HttpResponseBase): Observable<AuthenticateResultModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuthenticateResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeToken1(body: UserTenantModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ChangeToken1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeToken1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeToken1(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeToken1(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSO_UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SSO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getCurrentUser(): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: UserInt64GetDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getListOwner(): Observable<UserOwnerDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetListOwner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOwnerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOwnerDto[]>;
        }));
    }

    protected processGetListOwner(response: HttpResponseBase): Observable<UserOwnerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserOwnerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAdmin(): Observable<UserOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetAdmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto>;
        }));
    }

    protected processGetAdmin(response: HttpResponseBase): Observable<UserOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByListUserId(body: number[] | null | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetByListUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByListUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByListUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processGetByListUserId(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserByTime(body: GetUserByTimeDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetUserByTime";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processGetUserByTime(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListUserTenantByApplication(body: GuidEntityDto | undefined): Observable<UserInfoTenantDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetListUserTenantByApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUserTenantByApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUserTenantByApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoTenantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoTenantDto[]>;
        }));
    }

    protected processGetListUserTenantByApplication(response: HttpResponseBase): Observable<UserInfoTenantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoTenantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListUserTenant(body: GetUserTenantDto | undefined): Observable<UserInfoTenantDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetListUserTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUserTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUserTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoTenantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoTenantDto[]>;
        }));
    }

    protected processGetListUserTenant(response: HttpResponseBase): Observable<UserInfoTenantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoTenantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPageUsers(body: UserInt64GetDto | undefined): Observable<UserOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetPageUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDtoPagedResultDto>;
        }));
    }

    protected processGetPageUsers(response: HttpResponseBase): Observable<UserOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCurrentProfile(): Observable<UserInfoDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetCurrentProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoDto>;
        }));
    }

    protected processGetCurrentProfile(response: HttpResponseBase): Observable<UserInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCurrentUserPermission(): Observable<UserPermissionDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetCurrentUserPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserPermissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserPermissionDto>;
        }));
    }

    protected processGetCurrentUserPermission(response: HttpResponseBase): Observable<UserPermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPermissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSearchUsers(body: UserDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetSearchUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processGetSearchUsers(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkEmailAddressOrUserName(body: UserDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/CheckEmailAddressOrUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmailAddressOrUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmailAddressOrUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckEmailAddressOrUserName(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordUserInFamily(body: ChangePasswordInFamilyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/ChangePasswordUserInFamily";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePasswordUserInFamily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePasswordUserInFamily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePasswordUserInFamily(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeAccount(body: ChangeUserPasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/ChangeAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeAccountUserInFamily(body: ChangeUserPasswordInFamilyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/ChangeAccountUserInFamily";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAccountUserInFamily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAccountUserInFamily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeAccountUserInFamily(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: RegisterUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserInputDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPassword(body: ChangePasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInfo(body: UserInputDto | undefined): Observable<UserOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/UpdateInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto>;
        }));
    }

    protected processUpdateInfo(response: HttpResponseBase): Observable<UserOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShareKey(body: ShareKeyDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/UpdateShareKey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShareKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShareKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateShareKey(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    joinApplication(body: ApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/JoinApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processJoinApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateApplication(body: ApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/UpdateApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeApplication(body: ApplicationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/RemoveApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeTenant(body: TenantUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/RemoveTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeDefaultTenant(body: TenantUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/ChangeDefaultTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDefaultTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDefaultTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeDefaultTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class StringEntityDto implements IStringEntityDto {
    id?: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IStringEntityDto {
    id?: string | undefined;
}

export enum OperationCriteria {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class CriteriaRequestDto implements ICriteriaRequestDto {
    propertyName?: string | undefined;
    operation?: OperationCriteria;
    value?: string | undefined;

    constructor(data?: ICriteriaRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.operation = _data["operation"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CriteriaRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CriteriaRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data;
    }
}

export interface ICriteriaRequestDto {
    propertyName?: string | undefined;
    operation?: OperationCriteria;
    value?: string | undefined;
}

export class SSOCategoryGuidGetDto implements ISSOCategoryGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ISSOCategoryGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SSOCategoryGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ISSOCategoryGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class ValueCategoryPermissionDto implements IValueCategoryPermissionDto {
    allow?: boolean;
    deny?: boolean;

    constructor(data?: IValueCategoryPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allow = _data["allow"];
            this.deny = _data["deny"];
        }
    }

    static fromJS(data: any): ValueCategoryPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueCategoryPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allow"] = this.allow;
        data["deny"] = this.deny;
        return data;
    }
}

export interface IValueCategoryPermissionDto {
    allow?: boolean;
    deny?: boolean;
}

export class SSOCategoryOutputDto implements ISSOCategoryOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    valuePermissions?: ValueCategoryPermissionDto;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISSOCategoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
            this.valuePermissions = _data["valuePermissions"] ? ValueCategoryPermissionDto.fromJS(_data["valuePermissions"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SSOCategoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        data["valuePermissions"] = this.valuePermissions ? this.valuePermissions.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISSOCategoryOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    valuePermissions?: ValueCategoryPermissionDto;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GuidEntityDto implements IGuidEntityDto {
    id?: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGuidEntityDto {
    id?: string;
}

export class SSOCategoryInputDto implements ISSOCategoryInputDto {
    valuePermissions?: ValueCategoryPermissionDto;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISSOCategoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valuePermissions = _data["valuePermissions"] ? ValueCategoryPermissionDto.fromJS(_data["valuePermissions"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SSOCategoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valuePermissions"] = this.valuePermissions ? this.valuePermissions.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISSOCategoryInputDto {
    valuePermissions?: ValueCategoryPermissionDto;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class DataOutputDto implements IDataOutputDto {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    groupCode?: string | undefined;
    isDefault?: boolean | undefined;
    data?: string | undefined;

    constructor(data?: IDataOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.groupCode = _data["groupCode"];
            this.isDefault = _data["isDefault"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DataOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["groupCode"] = this.groupCode;
        data["isDefault"] = this.isDefault;
        data["data"] = this.data;
        return data;
    }
}

export interface IDataOutputDto {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    groupCode?: string | undefined;
    isDefault?: boolean | undefined;
    data?: string | undefined;
}

export class FamilyGuidGetDto implements IFamilyGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IFamilyGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): FamilyGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IFamilyGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class UserInputDto implements IUserInputDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: IUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.familyKeys = _data["familyKeys"];
            this.familyType = _data["familyType"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["familyKeys"] = this.familyKeys;
        data["familyType"] = this.familyType;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserInputDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class FamilyDto implements IFamilyDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    userId?: number;
    user?: UserInputDto;
    familyKeys?: string | undefined;
    type?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserInputDto.fromJS(_data["user"]) : <any>undefined;
            this.familyKeys = _data["familyKeys"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["familyKeys"] = this.familyKeys;
        data["type"] = this.type;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IFamilyDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    userId?: number;
    user?: UserInputDto;
    familyKeys?: string | undefined;
    type?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class Int64EntityDto implements IInt64EntityDto {
    id?: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IInt64EntityDto {
    id?: number;
}

export class GetByListUserDto implements IGetByListUserDto {
    listUserId?: number[] | undefined;

    constructor(data?: IGetByListUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
        }
    }

    static fromJS(data: any): GetByListUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetByListUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        return data;
    }
}

export interface IGetByListUserDto {
    listUserId?: number[] | undefined;
}

export class InputFamilyDto implements IInputFamilyDto {
    receiverId?: number;
    typeSender?: string | undefined;
    typeReceiver?: string | undefined;
    defaultFamilySender?: string | undefined;
    defaultFamilyReceiver?: string | undefined;

    constructor(data?: IInputFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiverId = _data["receiverId"];
            this.typeSender = _data["typeSender"];
            this.typeReceiver = _data["typeReceiver"];
            this.defaultFamilySender = _data["defaultFamilySender"];
            this.defaultFamilyReceiver = _data["defaultFamilyReceiver"];
        }
    }

    static fromJS(data: any): InputFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiverId"] = this.receiverId;
        data["typeSender"] = this.typeSender;
        data["typeReceiver"] = this.typeReceiver;
        data["defaultFamilySender"] = this.defaultFamilySender;
        data["defaultFamilyReceiver"] = this.defaultFamilyReceiver;
        return data;
    }
}

export interface IInputFamilyDto {
    receiverId?: number;
    typeSender?: string | undefined;
    typeReceiver?: string | undefined;
    defaultFamilySender?: string | undefined;
    defaultFamilyReceiver?: string | undefined;
}

export class ConfirmFamilyDto implements IConfirmFamilyDto {
    action?: string | undefined;
    comment?: string | undefined;
    id?: string;

    constructor(data?: IConfirmFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConfirmFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data;
    }
}

export interface IConfirmFamilyDto {
    action?: string | undefined;
    comment?: string | undefined;
    id?: string;
}

export class MenuGuidGetDto implements IMenuGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IMenuGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): MenuGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IMenuGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class MenuOutputDto implements IMenuOutputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IMenuOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IMenuOutputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class MenuInputDto implements IMenuInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IMenuInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IMenuInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export enum UserNotificationState {
    _0 = 0,
    _1 = 1,
}

export class GetUserNotificationsDto implements IGetUserNotificationsDto {
    userId?: number;
    state?: UserNotificationState;
    notificationName?: string | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IGetUserNotificationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notificationName = _data["notificationName"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetUserNotificationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserNotificationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notificationName"] = this.notificationName;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IGetUserNotificationsDto {
    userId?: number;
    state?: UserNotificationState;
    notificationName?: string | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class NotificationData implements INotificationData {
    readonly type?: string | undefined;
    properties?: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIntPtr {
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value?: IntPtr;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data;
    }
}

export interface IModuleHandle {
    mdStreamVersion?: number;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: Type;
    readonly value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] ? Type.fromJS(_data["argumentType"]) : <any>undefined;
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;
}

export class MemberInfo implements IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    readonly name?: string | undefined;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    name?: string | undefined;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string | undefined;
    readonly isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    readonly constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments?: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] ? Type.fromJS(_data["attributeType"]) : <any>undefined;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export class Module implements IModule {
    assembly?: Assembly;
    readonly fullyQualifiedName?: string | undefined;
    readonly name?: string | undefined;
    readonly mdStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IModule {
    assembly?: Assembly;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mdStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class ConstructorInfo implements IConstructorInfo {
    memberType?: MemberTypes;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IConstructorInfo {
    memberType?: MemberTypes;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    readonly name?: string | undefined;
    parameterType?: Type;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.parameterType = _data["parameterType"] ? Type.fromJS(_data["parameterType"]) : <any>undefined;
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    name?: string | undefined;
    parameterType?: Type;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export class MethodInfo implements IMethodInfo {
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            this.returnType = _data["returnType"] ? Type.fromJS(_data["returnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMethodInfo {
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export class EventInfo implements IEventInfo {
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    readonly isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    readonly isMulticast?: boolean;
    eventHandlerType?: Type;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"]) : <any>undefined;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"]) : <any>undefined;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["isMulticast"];
            this.eventHandlerType = _data["eventHandlerType"] ? Type.fromJS(_data["eventHandlerType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["isMulticast"] = this.isMulticast;
        data["eventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IEventInfo {
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    isMulticast?: boolean;
    eventHandlerType?: Type;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeFieldHandle {
    value?: IntPtr;
}

export class FieldInfo implements IFieldInfo {
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    readonly isInitOnly?: boolean;
    readonly isLiteral?: boolean;
    readonly isNotSerialized?: boolean;
    readonly isPinvokeImpl?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.fieldType = _data["fieldType"] ? Type.fromJS(_data["fieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["isInitOnly"];
            (<any>this).isLiteral = _data["isLiteral"];
            (<any>this).isNotSerialized = _data["isNotSerialized"];
            (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["fieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["isInitOnly"] = this.isInitOnly;
        data["isLiteral"] = this.isLiteral;
        data["isNotSerialized"] = this.isNotSerialized;
        data["isPinvokeImpl"] = this.isPinvokeImpl;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IFieldInfo {
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    isInitOnly?: boolean;
    isLiteral?: boolean;
    isNotSerialized?: boolean;
    isPinvokeImpl?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    readonly isSpecialName?: boolean;
    readonly canRead?: boolean;
    readonly canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.propertyType = _data["propertyType"] ? Type.fromJS(_data["propertyType"]) : <any>undefined;
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IPropertyInfo {
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    isSpecialName?: boolean;
    canRead?: boolean;
    canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export class MethodBase implements IMethodBase {
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMethodBase {
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    value?: LayoutKind;
    readonly typeId?: any | undefined;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            (<any>this).typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["typeId"] = this.typeId;
        return data;
    }
}

export interface IStructLayoutAttribute {
    value?: LayoutKind;
    typeId?: any | undefined;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeTypeHandle {
    value?: IntPtr;
}

export class TypeInfo implements ITypeInfo {
    readonly genericTypeParameters?: Type[] | undefined;
    readonly declaredConstructors?: ConstructorInfo[] | undefined;
    readonly declaredEvents?: EventInfo[] | undefined;
    readonly declaredFields?: FieldInfo[] | undefined;
    readonly declaredMembers?: MemberInfo[] | undefined;
    readonly declaredMethods?: MethodInfo[] | undefined;
    readonly declaredNestedTypes?: TypeInfo[] | undefined;
    readonly declaredProperties?: PropertyInfo[] | undefined;
    readonly implementedInterfaces?: Type[] | undefined;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["genericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    (<any>this).genericTypeParameters!.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    (<any>this).declaredConstructors!.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    (<any>this).declaredEvents!.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    (<any>this).declaredFields!.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    (<any>this).declaredMembers!.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    (<any>this).declaredMethods!.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    (<any>this).declaredNestedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    (<any>this).declaredProperties!.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    (<any>this).implementedInterfaces!.push(Type.fromJS(item));
            }
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item.toJSON());
        }
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface ITypeInfo {
    genericTypeParameters?: Type[] | undefined;
    declaredConstructors?: ConstructorInfo[] | undefined;
    declaredEvents?: EventInfo[] | undefined;
    declaredFields?: FieldInfo[] | undefined;
    declaredMembers?: MemberInfo[] | undefined;
    declaredMethods?: MethodInfo[] | undefined;
    declaredNestedTypes?: TypeInfo[] | undefined;
    declaredProperties?: PropertyInfo[] | undefined;
    implementedInterfaces?: Type[] | undefined;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    guid?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Assembly implements IAssembly {
    readonly definedTypes?: TypeInfo[] | undefined;
    readonly exportedTypes?: Type[] | undefined;
    readonly codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string | undefined;
    readonly isDynamic?: boolean;
    readonly location?: string | undefined;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    readonly modules?: Module[] | undefined;
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    securityRuleSet?: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item.toJSON());
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data;
    }
}

export interface IAssembly {
    definedTypes?: TypeInfo[] | undefined;
    exportedTypes?: Type[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isCollectible?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: SecurityRuleSet;
}

export class Type implements IType {
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IType {
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    guid?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum NotificationSeverity {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class TenantNotification implements ITenantNotification {
    tenantId?: number | undefined;
    notificationName?: string | undefined;
    data?: NotificationData;
    entityType?: Type;
    entityTypeName?: string | undefined;
    entityId?: any | undefined;
    severity?: NotificationSeverity;
    creationTime?: Date;
    id?: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"] ? Type.fromJS(_data["entityType"]) : <any>undefined;
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType ? this.entityType.toJSON() : <any>undefined;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantNotification {
    tenantId?: number | undefined;
    notificationName?: string | undefined;
    data?: NotificationData;
    entityType?: Type;
    entityTypeName?: string | undefined;
    entityId?: any | undefined;
    severity?: NotificationSeverity;
    creationTime?: Date;
    id?: string;
}

export class UserNotification implements IUserNotification {
    tenantId?: number | undefined;
    userId?: number;
    state?: UserNotificationState;
    notification?: TenantNotification;
    id?: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserNotification {
    tenantId?: number | undefined;
    userId?: number;
    state?: UserNotificationState;
    notification?: TenantNotification;
    id?: string;
}

export class RelationNotificationDto implements IRelationNotificationDto {
    notificationName?: string | undefined;
    tenantId?: number | undefined;
    tenantName?: string | undefined;
    tenancyName?: string | undefined;
    listUserId?: number[] | undefined;
    userFullName?: string | undefined;
    creatorUserId?: number | undefined;
    creatorUserFullName?: string | undefined;
    entityId?: any | undefined;
    tableName?: string | undefined;
    action?: string | undefined;
    message?: string | undefined;
    tag?: string | undefined;
    readonly type?: string | undefined;
    properties?: { [key: string]: any; } | undefined;

    constructor(data?: IRelationNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationName = _data["notificationName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.tenancyName = _data["tenancyName"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
            this.userFullName = _data["userFullName"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserFullName = _data["creatorUserFullName"];
            this.entityId = _data["entityId"];
            this.tableName = _data["tableName"];
            this.action = _data["action"];
            this.message = _data["message"];
            this.tag = _data["tag"];
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): RelationNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelationNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationName"] = this.notificationName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["tenancyName"] = this.tenancyName;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        data["userFullName"] = this.userFullName;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserFullName"] = this.creatorUserFullName;
        data["entityId"] = this.entityId;
        data["tableName"] = this.tableName;
        data["action"] = this.action;
        data["message"] = this.message;
        data["tag"] = this.tag;
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface IRelationNotificationDto {
    notificationName?: string | undefined;
    tenantId?: number | undefined;
    tenantName?: string | undefined;
    tenancyName?: string | undefined;
    listUserId?: number[] | undefined;
    userFullName?: string | undefined;
    creatorUserId?: number | undefined;
    creatorUserFullName?: string | undefined;
    entityId?: any | undefined;
    tableName?: string | undefined;
    action?: string | undefined;
    message?: string | undefined;
    tag?: string | undefined;
    type?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export class AllUserNotificationDto implements IAllUserNotificationDto {
    userId?: number;
    state?: UserNotificationState;

    constructor(data?: IAllUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): AllUserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllUserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["state"] = this.state;
        return data;
    }
}

export interface IAllUserNotificationDto {
    userId?: number;
    state?: UserNotificationState;
}

export class UserNotificationDto implements IUserNotificationDto {
    userNotificationId!: string;
    state?: UserNotificationState;

    constructor(data?: IUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNotificationId = _data["userNotificationId"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): UserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNotificationId"] = this.userNotificationId;
        data["state"] = this.state;
        return data;
    }
}

export interface IUserNotificationDto {
    userNotificationId: string;
    state?: UserNotificationState;
}

export class OrganizationGuidGetDto implements IOrganizationGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IOrganizationGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): OrganizationGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IOrganizationGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class OrganizationActiveCodeDto implements IOrganizationActiveCodeDto {
    securityCode?: string | undefined;
    expiredTime?: Date | undefined;

    constructor(data?: IOrganizationActiveCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.securityCode = _data["securityCode"];
            this.expiredTime = _data["expiredTime"] ? new Date(_data["expiredTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationActiveCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationActiveCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityCode"] = this.securityCode;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IOrganizationActiveCodeDto {
    securityCode?: string | undefined;
    expiredTime?: Date | undefined;
}

export class ValuePermissionDto implements IValuePermissionDto {
    securityCode?: string | undefined;
    name?: string | undefined;
    levelCode?: string | undefined;
    type?: string | undefined;
    code?: string | undefined;
    id?: string;

    constructor(data?: IValuePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.securityCode = _data["securityCode"];
            this.name = _data["name"];
            this.levelCode = _data["levelCode"];
            this.type = _data["type"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ValuePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValuePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityCode"] = this.securityCode;
        data["name"] = this.name;
        data["levelCode"] = this.levelCode;
        data["type"] = this.type;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }
}

export interface IValuePermissionDto {
    securityCode?: string | undefined;
    name?: string | undefined;
    levelCode?: string | undefined;
    type?: string | undefined;
    code?: string | undefined;
    id?: string;
}

export class ValueTitleDto implements IValueTitleDto {
    code?: string | undefined;
    securityCode?: string | undefined;
    name?: string | undefined;
    index?: number;
    listPermission?: ValuePermissionDto[] | undefined;
    id?: string;

    constructor(data?: IValueTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.securityCode = _data["securityCode"];
            this.name = _data["name"];
            this.index = _data["index"];
            if (Array.isArray(_data["listPermission"])) {
                this.listPermission = [] as any;
                for (let item of _data["listPermission"])
                    this.listPermission!.push(ValuePermissionDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ValueTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["name"] = this.name;
        data["index"] = this.index;
        if (Array.isArray(this.listPermission)) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IValueTitleDto {
    code?: string | undefined;
    securityCode?: string | undefined;
    name?: string | undefined;
    index?: number;
    listPermission?: ValuePermissionDto[] | undefined;
    id?: string;
}

export class ValueCategoryDto implements IValueCategoryDto {
    code?: string | undefined;
    group?: string | undefined;
    parentId?: string | undefined;
    name?: string | undefined;
    index?: number;
    order?: number;
    valuePermissions?: ValueCategoryPermissionDto;
    id?: string;

    constructor(data?: IValueCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.group = _data["group"];
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.valuePermissions = _data["valuePermissions"] ? ValueCategoryPermissionDto.fromJS(_data["valuePermissions"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ValueCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["group"] = this.group;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["index"] = this.index;
        data["order"] = this.order;
        data["valuePermissions"] = this.valuePermissions ? this.valuePermissions.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IValueCategoryDto {
    code?: string | undefined;
    group?: string | undefined;
    parentId?: string | undefined;
    name?: string | undefined;
    index?: number;
    order?: number;
    valuePermissions?: ValueCategoryPermissionDto;
    id?: string;
}

export class OrganizationOutputDto implements IOrganizationOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    securityCode?: string | undefined;
    activeCode?: OrganizationActiveCodeDto;
    listTitle?: ValueTitleDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    token?: string | undefined;
    titles?: string | undefined;
    profiles?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IOrganizationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
            this.securityCode = _data["securityCode"];
            this.activeCode = _data["activeCode"] ? OrganizationActiveCodeDto.fromJS(_data["activeCode"]) : <any>undefined;
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(ValueTitleDto.fromJS(item));
            }
            if (Array.isArray(_data["listCategory"])) {
                this.listCategory = [] as any;
                for (let item of _data["listCategory"])
                    this.listCategory!.push(ValueCategoryDto.fromJS(item));
            }
            this.token = _data["token"];
            this.titles = _data["titles"];
            this.profiles = _data["profiles"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        data["securityCode"] = this.securityCode;
        data["activeCode"] = this.activeCode ? this.activeCode.toJSON() : <any>undefined;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (Array.isArray(this.listCategory)) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["token"] = this.token;
        data["titles"] = this.titles;
        data["profiles"] = this.profiles;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    securityCode?: string | undefined;
    activeCode?: OrganizationActiveCodeDto;
    listTitle?: ValueTitleDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    token?: string | undefined;
    titles?: string | undefined;
    profiles?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class OrganizationInputDto implements IOrganizationInputDto {
    activeCode?: OrganizationActiveCodeDto;
    listTitle?: ValueTitleDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    token?: string | undefined;
    titles?: string | undefined;
    profiles?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IOrganizationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeCode = _data["activeCode"] ? OrganizationActiveCodeDto.fromJS(_data["activeCode"]) : <any>undefined;
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(ValueTitleDto.fromJS(item));
            }
            if (Array.isArray(_data["listCategory"])) {
                this.listCategory = [] as any;
                for (let item of _data["listCategory"])
                    this.listCategory!.push(ValueCategoryDto.fromJS(item));
            }
            this.token = _data["token"];
            this.titles = _data["titles"];
            this.profiles = _data["profiles"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeCode"] = this.activeCode ? this.activeCode.toJSON() : <any>undefined;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (Array.isArray(this.listCategory)) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["token"] = this.token;
        data["titles"] = this.titles;
        data["profiles"] = this.profiles;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationInputDto {
    activeCode?: OrganizationActiveCodeDto;
    listTitle?: ValueTitleDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    token?: string | undefined;
    titles?: string | undefined;
    profiles?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class OrganizationTitleDto implements IOrganizationTitleDto {
    name?: string | undefined;
    code?: string | undefined;
    securityCode?: string | undefined;
    id?: string;

    constructor(data?: IOrganizationTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.securityCode = _data["securityCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationTitleDto {
    name?: string | undefined;
    code?: string | undefined;
    securityCode?: string | undefined;
    id?: string;
}

export class OrganizationTitlesDto implements IOrganizationTitlesDto {
    name?: string | undefined;
    listTitle?: OrganizationTitleDto[] | undefined;
    id?: string;

    constructor(data?: IOrganizationTitlesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(OrganizationTitleDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationTitlesDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTitlesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationTitlesDto {
    name?: string | undefined;
    listTitle?: OrganizationTitleDto[] | undefined;
    id?: string;
}

export class OrganizationCategoryDto implements IOrganizationCategoryDto {
    listCategory?: ValueCategoryDto[] | undefined;
    id?: string;

    constructor(data?: IOrganizationCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCategory"])) {
                this.listCategory = [] as any;
                for (let item of _data["listCategory"])
                    this.listCategory!.push(ValueCategoryDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCategory)) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationCategoryDto {
    listCategory?: ValueCategoryDto[] | undefined;
    id?: string;
}

export class OrganizationUserGuidGetDto implements IOrganizationUserGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IOrganizationUserGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): OrganizationUserGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IOrganizationUserGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class UserOutputDto implements IUserOutputDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: IUserOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.familyKeys = _data["familyKeys"];
            this.familyType = _data["familyType"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["familyKeys"] = this.familyKeys;
        data["familyType"] = this.familyType;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserOutputDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class OrganizationUserOutputDto implements IOrganizationUserOutputDto {
    user?: UserOutputDto;
    titleIndex?: number;
    listTitle?: ValueTitleDto[] | undefined;
    listPermission?: ValuePermissionDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    organizationId?: string;
    userId?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IOrganizationUserOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserOutputDto.fromJS(_data["user"]) : <any>undefined;
            this.titleIndex = _data["titleIndex"];
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(ValueTitleDto.fromJS(item));
            }
            if (Array.isArray(_data["listPermission"])) {
                this.listPermission = [] as any;
                for (let item of _data["listPermission"])
                    this.listPermission!.push(ValuePermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["listCategory"])) {
                this.listCategory = [] as any;
                for (let item of _data["listCategory"])
                    this.listCategory!.push(ValueCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUserOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["titleIndex"] = this.titleIndex;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (Array.isArray(this.listPermission)) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        if (Array.isArray(this.listCategory)) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUserOutputDto {
    user?: UserOutputDto;
    titleIndex?: number;
    listTitle?: ValueTitleDto[] | undefined;
    listPermission?: ValuePermissionDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    organizationId?: string;
    userId?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetOrganizationUserDto implements IGetOrganizationUserDto {
    tenantId?: number;
    organizationId?: string | undefined;
    userId?: number | undefined;

    constructor(data?: IGetOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationId = _data["organizationId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): GetOrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IGetOrganizationUserDto {
    tenantId?: number;
    organizationId?: string | undefined;
    userId?: number | undefined;
}

export class ValueOrganizationDto implements IValueOrganizationDto {
    titles?: string | undefined;
    listTitle?: ValueTitleDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    listOrganizationUser?: OrganizationUserOutputDto[] | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: IValueOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titles = _data["titles"];
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(ValueTitleDto.fromJS(item));
            }
            if (Array.isArray(_data["listCategory"])) {
                this.listCategory = [] as any;
                for (let item of _data["listCategory"])
                    this.listCategory!.push(ValueCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listOrganizationUser"])) {
                this.listOrganizationUser = [] as any;
                for (let item of _data["listOrganizationUser"])
                    this.listOrganizationUser!.push(OrganizationUserOutputDto.fromJS(item));
            }
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ValueOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titles"] = this.titles;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (Array.isArray(this.listCategory)) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listOrganizationUser)) {
            data["listOrganizationUser"] = [];
            for (let item of this.listOrganizationUser)
                data["listOrganizationUser"].push(item.toJSON());
        }
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IValueOrganizationDto {
    titles?: string | undefined;
    listTitle?: ValueTitleDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    listOrganizationUser?: OrganizationUserOutputDto[] | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class FileDto implements IFileDto {
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnail = _data["thumbnail"];
            this.reference = _data["reference"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["thumbnail"] = this.thumbnail;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface IFileDto {
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;
}

export class TenantOrganizationDto implements ITenantOrganizationDto {
    listOrganization?: ValueOrganizationDto[] | undefined;
    profiles?: string | undefined;
    types?: string | undefined;
    logoCompany?: string | undefined;
    fileLogoCompany?: FileDto;
    tenancyName!: string;
    name!: string;
    status?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: ITenantOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listOrganization"])) {
                this.listOrganization = [] as any;
                for (let item of _data["listOrganization"])
                    this.listOrganization!.push(ValueOrganizationDto.fromJS(item));
            }
            this.profiles = _data["profiles"];
            this.types = _data["types"];
            this.logoCompany = _data["logoCompany"];
            this.fileLogoCompany = _data["fileLogoCompany"] ? FileDto.fromJS(_data["fileLogoCompany"]) : <any>undefined;
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listOrganization)) {
            data["listOrganization"] = [];
            for (let item of this.listOrganization)
                data["listOrganization"].push(item.toJSON());
        }
        data["profiles"] = this.profiles;
        data["types"] = this.types;
        data["logoCompany"] = this.logoCompany;
        data["fileLogoCompany"] = this.fileLogoCompany ? this.fileLogoCompany.toJSON() : <any>undefined;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["status"] = this.status;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantOrganizationDto {
    listOrganization?: ValueOrganizationDto[] | undefined;
    profiles?: string | undefined;
    types?: string | undefined;
    logoCompany?: string | undefined;
    fileLogoCompany?: FileDto;
    tenancyName: string;
    name: string;
    status?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class OrganizationalChartInputDto implements IOrganizationalChartInputDto {
    level?: number | undefined;
    search?: string | undefined;
    sorting?: string | undefined;
    listCategoryId?: string[] | undefined;
    listStatus?: string[] | undefined;
    listOrganizationId?: string[] | undefined;
    listTitleId?: string[] | undefined;
    listPermissionId?: string[] | undefined;
    skipCount?: number;
    maxCountResult?: number;

    constructor(data?: IOrganizationalChartInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.search = _data["search"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["listCategoryId"])) {
                this.listCategoryId = [] as any;
                for (let item of _data["listCategoryId"])
                    this.listCategoryId!.push(item);
            }
            if (Array.isArray(_data["listStatus"])) {
                this.listStatus = [] as any;
                for (let item of _data["listStatus"])
                    this.listStatus!.push(item);
            }
            if (Array.isArray(_data["listOrganizationId"])) {
                this.listOrganizationId = [] as any;
                for (let item of _data["listOrganizationId"])
                    this.listOrganizationId!.push(item);
            }
            if (Array.isArray(_data["listTitleId"])) {
                this.listTitleId = [] as any;
                for (let item of _data["listTitleId"])
                    this.listTitleId!.push(item);
            }
            if (Array.isArray(_data["listPermissionId"])) {
                this.listPermissionId = [] as any;
                for (let item of _data["listPermissionId"])
                    this.listPermissionId!.push(item);
            }
            this.skipCount = _data["skipCount"];
            this.maxCountResult = _data["maxCountResult"];
        }
    }

    static fromJS(data: any): OrganizationalChartInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationalChartInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["search"] = this.search;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.listCategoryId)) {
            data["listCategoryId"] = [];
            for (let item of this.listCategoryId)
                data["listCategoryId"].push(item);
        }
        if (Array.isArray(this.listStatus)) {
            data["listStatus"] = [];
            for (let item of this.listStatus)
                data["listStatus"].push(item);
        }
        if (Array.isArray(this.listOrganizationId)) {
            data["listOrganizationId"] = [];
            for (let item of this.listOrganizationId)
                data["listOrganizationId"].push(item);
        }
        if (Array.isArray(this.listTitleId)) {
            data["listTitleId"] = [];
            for (let item of this.listTitleId)
                data["listTitleId"].push(item);
        }
        if (Array.isArray(this.listPermissionId)) {
            data["listPermissionId"] = [];
            for (let item of this.listPermissionId)
                data["listPermissionId"].push(item);
        }
        data["skipCount"] = this.skipCount;
        data["maxCountResult"] = this.maxCountResult;
        return data;
    }
}

export interface IOrganizationalChartInputDto {
    level?: number | undefined;
    search?: string | undefined;
    sorting?: string | undefined;
    listCategoryId?: string[] | undefined;
    listStatus?: string[] | undefined;
    listOrganizationId?: string[] | undefined;
    listTitleId?: string[] | undefined;
    listPermissionId?: string[] | undefined;
    skipCount?: number;
    maxCountResult?: number;
}

export class DataIdDto implements IDataIdDto {
    id?: string | undefined;
    creationTime?: Date | undefined;

    constructor(data?: IDataIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DataIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDataIdDto {
    id?: string | undefined;
    creationTime?: Date | undefined;
}

export class ValueTenantDto implements IValueTenantDto {
    tenancyName!: string;
    name!: string;
    status?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: IValueTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ValueTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["status"] = this.status;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface IValueTenantDto {
    tenancyName: string;
    name: string;
    status?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class KeyValueDto implements IKeyValueDto {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IKeyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValueDto {
    key?: string | undefined;
    value?: string | undefined;
}

export class UserDto implements IUserDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    dataIds?: DataIdDto;
    tenant?: ValueTenantDto;
    listTenant?: ValueTenantDto[] | undefined;
    listInformation?: KeyValueDto[] | undefined;
    id?: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.phoneNumber = _data["phoneNumber"];
            this.dataIds = _data["dataIds"] ? DataIdDto.fromJS(_data["dataIds"]) : <any>undefined;
            this.tenant = _data["tenant"] ? ValueTenantDto.fromJS(_data["tenant"]) : <any>undefined;
            if (Array.isArray(_data["listTenant"])) {
                this.listTenant = [] as any;
                for (let item of _data["listTenant"])
                    this.listTenant!.push(ValueTenantDto.fromJS(item));
            }
            if (Array.isArray(_data["listInformation"])) {
                this.listInformation = [] as any;
                for (let item of _data["listInformation"])
                    this.listInformation!.push(KeyValueDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["phoneNumber"] = this.phoneNumber;
        data["dataIds"] = this.dataIds ? this.dataIds.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        if (Array.isArray(this.listTenant)) {
            data["listTenant"] = [];
            for (let item of this.listTenant)
                data["listTenant"].push(item.toJSON());
        }
        if (Array.isArray(this.listInformation)) {
            data["listInformation"] = [];
            for (let item of this.listInformation)
                data["listInformation"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    dataIds?: DataIdDto;
    tenant?: ValueTenantDto;
    listTenant?: ValueTenantDto[] | undefined;
    listInformation?: KeyValueDto[] | undefined;
    id?: number;
}

export class OrganizationChartDto implements IOrganizationChartDto {
    total?: number;
    listUser?: UserDto[] | undefined;
    listOrganization?: ValueOrganizationDto[] | undefined;

    constructor(data?: IOrganizationChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["listUser"])) {
                this.listUser = [] as any;
                for (let item of _data["listUser"])
                    this.listUser!.push(UserDto.fromJS(item));
            }
            if (Array.isArray(_data["listOrganization"])) {
                this.listOrganization = [] as any;
                for (let item of _data["listOrganization"])
                    this.listOrganization!.push(ValueOrganizationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.listUser)) {
            data["listUser"] = [];
            for (let item of this.listUser)
                data["listUser"].push(item.toJSON());
        }
        if (Array.isArray(this.listOrganization)) {
            data["listOrganization"] = [];
            for (let item of this.listOrganization)
                data["listOrganization"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationChartDto {
    total?: number;
    listUser?: UserDto[] | undefined;
    listOrganization?: ValueOrganizationDto[] | undefined;
}

export class TitleOutputDto implements ITitleOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    listPermission?: ValuePermissionDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITitleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
            if (Array.isArray(_data["listPermission"])) {
                this.listPermission = [] as any;
                for (let item of _data["listPermission"])
                    this.listPermission!.push(ValuePermissionDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.securityCode = _data["securityCode"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TitleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        if (Array.isArray(this.listPermission)) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITitleOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    listPermission?: ValuePermissionDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class OrganizationUserInputDto implements IOrganizationUserInputDto {
    action?: string | undefined;
    listTitle?: TitleOutputDto[] | undefined;
    listPermission?: ValuePermissionDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    organizationId?: string;
    userId?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IOrganizationUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(TitleOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listPermission"])) {
                this.listPermission = [] as any;
                for (let item of _data["listPermission"])
                    this.listPermission!.push(ValuePermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["listCategory"])) {
                this.listCategory = [] as any;
                for (let item of _data["listCategory"])
                    this.listCategory!.push(ValueCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (Array.isArray(this.listPermission)) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        if (Array.isArray(this.listCategory)) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUserInputDto {
    action?: string | undefined;
    listTitle?: TitleOutputDto[] | undefined;
    listPermission?: ValuePermissionDto[] | undefined;
    listCategory?: ValueCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    organizationId?: string;
    userId?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class OrganizationUserDto implements IOrganizationUserDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    organizationId?: string;
    userId?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUserDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    organizationId?: string;
    userId?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ConfirmOrganizationUserDto implements IConfirmOrganizationUserDto {
    action?: string | undefined;
    comment?: string | undefined;
    id?: string;

    constructor(data?: IConfirmOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConfirmOrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmOrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data;
    }
}

export interface IConfirmOrganizationUserDto {
    action?: string | undefined;
    comment?: string | undefined;
    id?: string;
}

export class OwnerDto implements IOwnerDto {
    value?: number;

    constructor(data?: IOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IOwnerDto {
    value?: number;
}

export class RegisterUserDto implements IRegisterUserDto {
    id?: number | undefined;
    tenantId?: number | undefined;
    userName!: string;
    name!: string;
    surname!: string;
    password!: string;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    familyKeys?: string | undefined;
    owner?: OwnerDto;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.password = _data["password"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.type = _data["type"];
            this.familyKeys = _data["familyKeys"];
            this.owner = _data["owner"] ? OwnerDto.fromJS(_data["owner"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["type"] = this.type;
        data["familyKeys"] = this.familyKeys;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterUserDto {
    id?: number | undefined;
    tenantId?: number | undefined;
    userName: string;
    name: string;
    surname: string;
    password: string;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    familyKeys?: string | undefined;
    owner?: OwnerDto;
}

export class AddOrganizationUserDto implements IAddOrganizationUserDto {
    organizationUser?: OrganizationUserInputDto;
    user?: RegisterUserDto;

    constructor(data?: IAddOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUser = _data["organizationUser"] ? OrganizationUserInputDto.fromJS(_data["organizationUser"]) : <any>undefined;
            this.user = _data["user"] ? RegisterUserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddOrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUser"] = this.organizationUser ? this.organizationUser.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddOrganizationUserDto {
    organizationUser?: OrganizationUserInputDto;
    user?: RegisterUserDto;
}

export class TenantPermissionGuidGetDto implements ITenantPermissionGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITenantPermissionGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TenantPermissionGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantPermissionGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITenantPermissionGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class PermissionOutputDto implements IPermissionOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IPermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.securityCode = _data["securityCode"];
            this.levelCode = _data["levelCode"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["levelCode"] = this.levelCode;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IPermissionOutputDto {
    parentCode?: string | undefined;
    parentName?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class PermissionInputDto implements IPermissionInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IPermissionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.securityCode = _data["securityCode"];
            this.levelCode = _data["levelCode"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["levelCode"] = this.levelCode;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IPermissionInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class CheckValidTenantDto implements ICheckValidTenantDto {
    tenancyName!: string;

    constructor(data?: ICheckValidTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): CheckValidTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ICheckValidTenantDto {
    tenancyName: string;
}

export class RegisterTenantDto implements IRegisterTenantDto {
    tenantId?: number | undefined;
    tenancyName!: string;
    name!: string;
    emailAddress!: string;
    password!: string;
    logoCompany?: FileDto;
    applicationId?: string | undefined;

    constructor(data?: IRegisterTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.logoCompany = _data["logoCompany"] ? FileDto.fromJS(_data["logoCompany"]) : <any>undefined;
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): RegisterTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["logoCompany"] = this.logoCompany ? this.logoCompany.toJSON() : <any>undefined;
        data["applicationId"] = this.applicationId;
        return data;
    }
}

export interface IRegisterTenantDto {
    tenantId?: number | undefined;
    tenancyName: string;
    name: string;
    emailAddress: string;
    password: string;
    logoCompany?: FileDto;
    applicationId?: string | undefined;
}

export class RegisterResultDto implements IRegisterResultDto {
    id?: number;
    canLogin?: boolean;
    tenancyName?: string | undefined;
    name?: string | undefined;
    userId?: number;
    userName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IRegisterResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.canLogin = _data["canLogin"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): RegisterResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["canLogin"] = this.canLogin;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IRegisterResultDto {
    id?: number;
    canLogin?: boolean;
    tenancyName?: string | undefined;
    name?: string | undefined;
    userId?: number;
    userName?: string | undefined;
    emailAddress?: string | undefined;
}

export class FileAttachment implements IFileAttachment {
    name?: string | undefined;
    attachment?: string | undefined;

    constructor(data?: IFileAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.attachment = _data["attachment"];
        }
    }

    static fromJS(data: any): FileAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new FileAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["attachment"] = this.attachment;
        return data;
    }
}

export interface IFileAttachment {
    name?: string | undefined;
    attachment?: string | undefined;
}

export class SendEmailJobArgs implements ISendEmailJobArgs {
    senderUserId?: number;
    targetUserId?: number;
    from?: string | undefined;
    to?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isBodyHtml?: boolean;
    attachments?: FileAttachment[] | undefined;

    constructor(data?: ISendEmailJobArgs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderUserId = _data["senderUserId"];
            this.targetUserId = _data["targetUserId"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.isBodyHtml = _data["isBodyHtml"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(FileAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendEmailJobArgs {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailJobArgs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderUserId"] = this.senderUserId;
        data["targetUserId"] = this.targetUserId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["isBodyHtml"] = this.isBodyHtml;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendEmailJobArgs {
    senderUserId?: number;
    targetUserId?: number;
    from?: string | undefined;
    to?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isBodyHtml?: boolean;
    attachments?: FileAttachment[] | undefined;
}

export class SettingDto implements ISettingDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    name?: string | undefined;
    value?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.value = _data["value"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["value"] = this.value;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISettingDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    name?: string | undefined;
    value?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TenantDto implements ITenantDto {
    profiles?: string | undefined;
    types?: string | undefined;
    logoCompany?: string | undefined;
    fileLogoCompany?: FileDto;
    tenancyName!: string;
    name!: string;
    status?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profiles = _data["profiles"];
            this.types = _data["types"];
            this.logoCompany = _data["logoCompany"];
            this.fileLogoCompany = _data["fileLogoCompany"] ? FileDto.fromJS(_data["fileLogoCompany"]) : <any>undefined;
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profiles"] = this.profiles;
        data["types"] = this.types;
        data["logoCompany"] = this.logoCompany;
        data["fileLogoCompany"] = this.fileLogoCompany ? this.fileLogoCompany.toJSON() : <any>undefined;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["status"] = this.status;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantDto {
    profiles?: string | undefined;
    types?: string | undefined;
    logoCompany?: string | undefined;
    fileLogoCompany?: FileDto;
    tenancyName: string;
    name: string;
    status?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class Int32EntityDto implements IInt32EntityDto {
    id?: number;

    constructor(data?: IInt32EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int32EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IInt32EntityDto {
    id?: number;
}

export class SSOTypeUserDto implements ISSOTypeUserDto {
    key?: string | undefined;
    info?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    title?: string | undefined;
    code?: string | undefined;
    type?: string | undefined;

    constructor(data?: ISSOTypeUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.info = _data["info"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.title = _data["title"];
            this.code = _data["code"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SSOTypeUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOTypeUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["info"] = this.info;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["title"] = this.title;
        data["code"] = this.code;
        data["type"] = this.type;
        return data;
    }
}

export interface ISSOTypeUserDto {
    key?: string | undefined;
    info?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    title?: string | undefined;
    code?: string | undefined;
    type?: string | undefined;
}

export class SSOOrganizationUserDto implements ISSOOrganizationUserDto {
    info?: string | undefined;
    userId?: number;
    organizationId?: string;
    order?: number;
    listUser?: SSOTypeUserDto[] | undefined;
    permissions?: string | undefined;
    code?: string | undefined;

    constructor(data?: ISSOOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.info = _data["info"];
            this.userId = _data["userId"];
            this.organizationId = _data["organizationId"];
            this.order = _data["order"];
            if (Array.isArray(_data["listUser"])) {
                this.listUser = [] as any;
                for (let item of _data["listUser"])
                    this.listUser!.push(SSOTypeUserDto.fromJS(item));
            }
            this.permissions = _data["permissions"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): SSOOrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOOrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["info"] = this.info;
        data["userId"] = this.userId;
        data["organizationId"] = this.organizationId;
        data["order"] = this.order;
        if (Array.isArray(this.listUser)) {
            data["listUser"] = [];
            for (let item of this.listUser)
                data["listUser"].push(item.toJSON());
        }
        data["permissions"] = this.permissions;
        data["code"] = this.code;
        return data;
    }
}

export interface ISSOOrganizationUserDto {
    info?: string | undefined;
    userId?: number;
    organizationId?: string;
    order?: number;
    listUser?: SSOTypeUserDto[] | undefined;
    permissions?: string | undefined;
    code?: string | undefined;
}

export class ClientSSOOrganizationUserDto implements IClientSSOOrganizationUserDto {
    userId?: number;
    listOrganizationUser?: SSOOrganizationUserDto[] | undefined;

    constructor(data?: IClientSSOOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["listOrganizationUser"])) {
                this.listOrganizationUser = [] as any;
                for (let item of _data["listOrganizationUser"])
                    this.listOrganizationUser!.push(SSOOrganizationUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientSSOOrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSSOOrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.listOrganizationUser)) {
            data["listOrganizationUser"] = [];
            for (let item of this.listOrganizationUser)
                data["listOrganizationUser"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientSSOOrganizationUserDto {
    userId?: number;
    listOrganizationUser?: SSOOrganizationUserDto[] | undefined;
}

export class SSOOrganizationDto implements ISSOOrganizationDto {
    organizationId?: string;
    name?: string | undefined;
    order?: number;
    code?: string | undefined;
    listUser?: SSOTypeUserDto[] | undefined;

    constructor(data?: ISSOOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.code = _data["code"];
            if (Array.isArray(_data["listUser"])) {
                this.listUser = [] as any;
                for (let item of _data["listUser"])
                    this.listUser!.push(SSOTypeUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["name"] = this.name;
        data["order"] = this.order;
        data["code"] = this.code;
        if (Array.isArray(this.listUser)) {
            data["listUser"] = [];
            for (let item of this.listUser)
                data["listUser"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISSOOrganizationDto {
    organizationId?: string;
    name?: string | undefined;
    order?: number;
    code?: string | undefined;
    listUser?: SSOTypeUserDto[] | undefined;
}

export class ValidationShareKeyDto implements IValidationShareKeyDto {
    userId?: number | undefined;
    tenantId?: number | undefined;
    curentUserId?: number | undefined;
    code?: string | undefined;
    endTime?: Date | undefined;

    constructor(data?: IValidationShareKeyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.curentUserId = _data["curentUserId"];
            this.code = _data["code"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationShareKeyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationShareKeyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["curentUserId"] = this.curentUserId;
        data["code"] = this.code;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IValidationShareKeyDto {
    userId?: number | undefined;
    tenantId?: number | undefined;
    curentUserId?: number | undefined;
    code?: string | undefined;
    endTime?: Date | undefined;
}

export class TemplateDto implements ITemplateDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    group?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.group = _data["group"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["group"] = this.group;
        data["value"] = this.value;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITemplateDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    group?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TemplateGuidGetDto implements ITemplateGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITemplateGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TemplateGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITemplateGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class ApplicationDto implements IApplicationDto {
    status?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    id?: string;

    constructor(data?: IApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationDto {
    status?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    id?: string;
}

export class TitleGuidGetDto implements ITitleGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITitleGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TitleGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITitleGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class TitleInputDto implements ITitleInputDto {
    listPermission?: ValuePermissionDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITitleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listPermission"])) {
                this.listPermission = [] as any;
                for (let item of _data["listPermission"])
                    this.listPermission!.push(ValuePermissionDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.securityCode = _data["securityCode"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TitleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listPermission)) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITitleInputDto {
    listPermission?: ValuePermissionDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    securityCode?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TitlePermissionsDto implements ITitlePermissionsDto {
    listPermission?: ValuePermissionDto[] | undefined;
    id?: string;

    constructor(data?: ITitlePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listPermission"])) {
                this.listPermission = [] as any;
                for (let item of _data["listPermission"])
                    this.listPermission!.push(ValuePermissionDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TitlePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitlePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listPermission)) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ITitlePermissionsDto {
    listPermission?: ValuePermissionDto[] | undefined;
    id?: string;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient?: boolean;
    tenantName?: string | undefined;
    expriteMinutes?: number;
    defaultTenant?: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.tenantName = _data["tenantName"];
            this.expriteMinutes = _data["expriteMinutes"];
            this.defaultTenant = _data["defaultTenant"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["tenantName"] = this.tenantName;
        data["expriteMinutes"] = this.expriteMinutes;
        data["defaultTenant"] = this.defaultTenant;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient?: boolean;
    tenantName?: string | undefined;
    expriteMinutes?: number;
    defaultTenant?: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken?: string | undefined;
    encryptedAccessToken?: string | undefined;
    expireInSeconds?: number;
    userId?: number;
    tenantId?: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken?: string | undefined;
    encryptedAccessToken?: string | undefined;
    expireInSeconds?: number;
    userId?: number;
    tenantId?: number | undefined;
}

export class TenantModel implements ITenantModel {
    id!: number;
    name!: string;

    constructor(data?: ITenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantModel {
        data = typeof data === 'object' ? data : {};
        let result = new TenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITenantModel {
    id: number;
    name: string;
}

export class UserModel implements IUserModel {
    id!: number;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IUserModel {
    id: number;
}

export class UserTenantModel implements IUserTenantModel {
    userId!: number;
    changeUserId?: number | undefined;
    tenantId!: number;
    tenantName!: string;

    constructor(data?: IUserTenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.changeUserId = _data["changeUserId"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
        }
    }

    static fromJS(data: any): UserTenantModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserTenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["changeUserId"] = this.changeUserId;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        return data;
    }
}

export interface IUserTenantModel {
    userId: number;
    changeUserId?: number | undefined;
    tenantId: number;
    tenantName: string;
}

export class UserInt64GetDto implements IUserInt64GetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: number;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IUserInt64GetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): UserInt64GetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInt64GetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IUserInt64GetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: number;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class UserOwnerDto implements IUserOwnerDto {
    owners?: OwnerDto;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: IUserOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.owners = _data["owners"] ? OwnerDto.fromJS(_data["owners"]) : <any>undefined;
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.familyKeys = _data["familyKeys"];
            this.familyType = _data["familyType"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["owners"] = this.owners ? this.owners.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["familyKeys"] = this.familyKeys;
        data["familyType"] = this.familyType;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserOwnerDto {
    owners?: OwnerDto;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class GetUserByTimeDto implements IGetUserByTimeDto {
    timeStart?: Date | undefined;
    timeEnd?: Date | undefined;
    typeUser?: string | undefined;

    constructor(data?: IGetUserByTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeStart = _data["timeStart"] ? new Date(_data["timeStart"].toString()) : <any>undefined;
            this.timeEnd = _data["timeEnd"] ? new Date(_data["timeEnd"].toString()) : <any>undefined;
            this.typeUser = _data["typeUser"];
        }
    }

    static fromJS(data: any): GetUserByTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeStart"] = this.timeStart ? this.timeStart.toISOString() : <any>undefined;
        data["timeEnd"] = this.timeEnd ? this.timeEnd.toISOString() : <any>undefined;
        data["typeUser"] = this.typeUser;
        return data;
    }
}

export interface IGetUserByTimeDto {
    timeStart?: Date | undefined;
    timeEnd?: Date | undefined;
    typeUser?: string | undefined;
}

export class UserInfoTenantDto implements IUserInfoTenantDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    tenantId?: number;
    tenantName?: string | undefined;
    typeUser?: string | undefined;
    id?: number;

    constructor(data?: IUserInfoTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.typeUser = _data["typeUser"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserInfoTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["typeUser"] = this.typeUser;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserInfoTenantDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    tenantId?: number;
    tenantName?: string | undefined;
    typeUser?: string | undefined;
    id?: number;
}

export class GetUserTenantDto implements IGetUserTenantDto {
    userId?: number | undefined;
    tenantId?: number | undefined;
    typeUser?: string | undefined;

    constructor(data?: IGetUserTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.typeUser = _data["typeUser"];
        }
    }

    static fromJS(data: any): GetUserTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["typeUser"] = this.typeUser;
        return data;
    }
}

export interface IGetUserTenantDto {
    userId?: number | undefined;
    tenantId?: number | undefined;
    typeUser?: string | undefined;
}

export class UserOutputDtoPagedResultDto implements IUserOutputDtoPagedResultDto {
    totalCount?: number;
    items?: UserOutputDto[] | undefined;

    constructor(data?: IUserOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserOutputDtoPagedResultDto {
    totalCount?: number;
    items?: UserOutputDto[] | undefined;
}

export class ShareKeyDto implements IShareKeyDto {
    code?: string | undefined;
    endTime?: Date | undefined;

    constructor(data?: IShareKeyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShareKeyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShareKeyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IShareKeyDto {
    code?: string | undefined;
    endTime?: Date | undefined;
}

export class UserInfoDto implements IUserInfoDto {
    typeFamily?: string | undefined;
    listShareKey?: ShareKeyDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeFamily = _data["typeFamily"];
            if (Array.isArray(_data["listShareKey"])) {
                this.listShareKey = [] as any;
                for (let item of _data["listShareKey"])
                    this.listShareKey!.push(ShareKeyDto.fromJS(item));
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.familyKeys = _data["familyKeys"];
            this.familyType = _data["familyType"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeFamily"] = this.typeFamily;
        if (Array.isArray(this.listShareKey)) {
            data["listShareKey"] = [];
            for (let item of this.listShareKey)
                data["listShareKey"].push(item.toJSON());
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["familyKeys"] = this.familyKeys;
        data["familyType"] = this.familyType;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserInfoDto {
    typeFamily?: string | undefined;
    listShareKey?: ShareKeyDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    familyType?: string | undefined;
    isActive?: boolean;
    id?: number;
}

export class OrganizationUserPermissionDto implements IOrganizationUserPermissionDto {
    organizationId?: string;
    listTitle?: ValueTitleDto[] | undefined;

    constructor(data?: IOrganizationUserPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            if (Array.isArray(_data["listTitle"])) {
                this.listTitle = [] as any;
                for (let item of _data["listTitle"])
                    this.listTitle!.push(ValueTitleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUserPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        if (Array.isArray(this.listTitle)) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationUserPermissionDto {
    organizationId?: string;
    listTitle?: ValueTitleDto[] | undefined;
}

export class UserPermissionDto implements IUserPermissionDto {
    tenantListPermission?: ValuePermissionDto[] | undefined;
    organizationListPermission?: OrganizationUserPermissionDto[] | undefined;

    constructor(data?: IUserPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tenantListPermission"])) {
                this.tenantListPermission = [] as any;
                for (let item of _data["tenantListPermission"])
                    this.tenantListPermission!.push(ValuePermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["organizationListPermission"])) {
                this.organizationListPermission = [] as any;
                for (let item of _data["organizationListPermission"])
                    this.organizationListPermission!.push(OrganizationUserPermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tenantListPermission)) {
            data["tenantListPermission"] = [];
            for (let item of this.tenantListPermission)
                data["tenantListPermission"].push(item.toJSON());
        }
        if (Array.isArray(this.organizationListPermission)) {
            data["organizationListPermission"] = [];
            for (let item of this.organizationListPermission)
                data["organizationListPermission"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserPermissionDto {
    tenantListPermission?: ValuePermissionDto[] | undefined;
    organizationListPermission?: OrganizationUserPermissionDto[] | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    oldPass?: string | undefined;
    newPass?: string | undefined;
    id?: number;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPass = _data["oldPass"];
            this.newPass = _data["newPass"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPass"] = this.oldPass;
        data["newPass"] = this.newPass;
        data["id"] = this.id;
        return data;
    }
}

export interface IChangePasswordDto {
    oldPass?: string | undefined;
    newPass?: string | undefined;
    id?: number;
}

export class ChangePasswordInFamilyDto implements IChangePasswordInFamilyDto {
    userId?: number | undefined;
    oldPass?: string | undefined;
    newPass?: string | undefined;

    constructor(data?: IChangePasswordInFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.oldPass = _data["oldPass"];
            this.newPass = _data["newPass"];
        }
    }

    static fromJS(data: any): ChangePasswordInFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["oldPass"] = this.oldPass;
        data["newPass"] = this.newPass;
        return data;
    }
}

export interface IChangePasswordInFamilyDto {
    userId?: number | undefined;
    oldPass?: string | undefined;
    newPass?: string | undefined;
}

export class ChangeUserPasswordDto implements IChangeUserPasswordDto {
    userName?: string | undefined;
    oldPass?: string | undefined;
    newPass?: string | undefined;
    id?: number;

    constructor(data?: IChangeUserPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.oldPass = _data["oldPass"];
            this.newPass = _data["newPass"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChangeUserPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["oldPass"] = this.oldPass;
        data["newPass"] = this.newPass;
        data["id"] = this.id;
        return data;
    }
}

export interface IChangeUserPasswordDto {
    userName?: string | undefined;
    oldPass?: string | undefined;
    newPass?: string | undefined;
    id?: number;
}

export class ChangeUserPasswordInFamilyDto implements IChangeUserPasswordInFamilyDto {
    userName?: string | undefined;
    userId?: number | undefined;
    oldPass?: string | undefined;
    newPass?: string | undefined;

    constructor(data?: IChangeUserPasswordInFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.oldPass = _data["oldPass"];
            this.newPass = _data["newPass"];
        }
    }

    static fromJS(data: any): ChangeUserPasswordInFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserPasswordInFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["oldPass"] = this.oldPass;
        data["newPass"] = this.newPass;
        return data;
    }
}

export interface IChangeUserPasswordInFamilyDto {
    userName?: string | undefined;
    userId?: number | undefined;
    oldPass?: string | undefined;
    newPass?: string | undefined;
}

export class TenantUserDto implements ITenantUserDto {
    userId?: number;
    status?: string | undefined;
    tenantId?: number;
    name?: string | undefined;
    type?: string | undefined;
    permission?: string | undefined;
    codeData?: string | undefined;

    constructor(data?: ITenantUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.permission = _data["permission"];
            this.codeData = _data["codeData"];
        }
    }

    static fromJS(data: any): TenantUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["permission"] = this.permission;
        data["codeData"] = this.codeData;
        return data;
    }
}

export interface ITenantUserDto {
    userId?: number;
    status?: string | undefined;
    tenantId?: number;
    name?: string | undefined;
    type?: string | undefined;
    permission?: string | undefined;
    codeData?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}