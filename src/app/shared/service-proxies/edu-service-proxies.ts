//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_EDU_URL = new InjectionToken<string>('API_EDU_URL');

@Injectable()
export class ApplicationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenant (optional) 
     * @return Success
     */
    removeAllCache(tenant: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Application/RemoveAllCache?";
        if (tenant === null)
            throw new Error("The parameter 'tenant' cannot be null.");
        else if (tenant !== undefined)
            url_ += "tenant=" + encodeURIComponent("" + tenant) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAllCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAllCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveAllCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetCache(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Application/ResetCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AttachedCalendarClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: AttachedCalendarGuidGetDto | undefined): Observable<AttachedCalendarOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/AttachedCalendar/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachedCalendarOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachedCalendarOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<AttachedCalendarOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachedCalendarOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<AttachedCalendarOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/AttachedCalendar/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachedCalendarOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachedCalendarOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AttachedCalendarOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachedCalendarOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AttachedCalendarInputDto | undefined): Observable<AttachedCalendarInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/AttachedCalendar/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachedCalendarInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachedCalendarInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AttachedCalendarInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachedCalendarInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AttachedCalendarInputDto | undefined): Observable<AttachedCalendarInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/AttachedCalendar/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachedCalendarInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachedCalendarInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AttachedCalendarInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachedCalendarInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/AttachedCalendar/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: AttachedCalendarInputDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/AttachedCalendar/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BoDeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: GuidEntityDto | undefined): Observable<CauTrucDeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/BoDe/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CauTrucDeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CauTrucDeOutputDto[]>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CauTrucDeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CauTrucDeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BuildFileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    setLeson(tenantId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/BuildFile/SetLeson?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetLeson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetLeson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetLeson(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    setExercise(tenantId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/BuildFile/SetExercise?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetExercise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetExercise(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    setQuestion(tenantId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/BuildFile/SetQuestion?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetQuestion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    setExerciseClass(tenantId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/BuildFile/SetExerciseClass?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetExerciseClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetExerciseClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetExerciseClass(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    setSolveExercise(tenantId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/BuildFile/SetSolveExercise?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetSolveExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetSolveExercise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSetSolveExercise(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CacheClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetCahce(body: RemoveListCacheDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Cache/ResetCahce";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetCahce(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetCahce(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetCahce(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMenuBySubjects(body: CategoryGuidGetDto | undefined): Observable<MenuCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Category/GetMenuBySubjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuBySubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuBySubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuCategoryDto[]>;
        }));
    }

    protected processGetMenuBySubjects(response: HttpResponseBase): Observable<MenuCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListBySubjects(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Category/GetListBySubjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListBySubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListBySubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto[]>;
        }));
    }

    protected processGetListBySubjects(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Category/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Category/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteGroup(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Category/DeleteGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CategoryClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/CategoryClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: ClassGuidGetDto | undefined): Observable<ClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<ClassOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClassOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMeeting(body: GuidEntityDto | undefined): Observable<MeetingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetMeeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeeting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeeting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeetingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeetingDto>;
        }));
    }

    protected processGetMeeting(response: HttpResponseBase): Observable<MeetingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeetingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListMeeting(body: string[] | null | undefined): Observable<MeetingForMobileDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListMeeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListMeeting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMeeting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeetingForMobileDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeetingForMobileDto[]>;
        }));
    }

    protected processGetListMeeting(response: HttpResponseBase): Observable<MeetingForMobileDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MeetingForMobileDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListByUserId(body: ClassGuidGetDto | undefined): Observable<ClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassOutputDto[]>;
        }));
    }

    protected processGetListByUserId(response: HttpResponseBase): Observable<ClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByParentId(body: ClassGuidGetDto | undefined): Observable<MenuClassByParentDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetByParentId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuClassByParentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuClassByParentDto[]>;
        }));
    }

    protected processGetByParentId(response: HttpResponseBase): Observable<MenuClassByParentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuClassByParentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListStatisticalByStudent(body: ClassGuidGetDto | undefined): Observable<ClassStatisticalDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListStatisticalByStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListStatisticalByStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListStatisticalByStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassStatisticalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassStatisticalDto[]>;
        }));
    }

    protected processGetListStatisticalByStudent(response: HttpResponseBase): Observable<ClassStatisticalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassStatisticalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListStatisticalByParent(body: ClassGuidGetDto | undefined): Observable<StatisticalStudentClassDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListStatisticalByParent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListStatisticalByParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListStatisticalByParent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatisticalStudentClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatisticalStudentClassDto[]>;
        }));
    }

    protected processGetListStatisticalByParent(response: HttpResponseBase): Observable<StatisticalStudentClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatisticalStudentClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getParentByClassId(body: GuidEntityDto | undefined): Observable<ParentDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetParentByClassId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentByClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentByClassId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentDto[]>;
        }));
    }

    protected processGetParentByClassId(response: HttpResponseBase): Observable<ParentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListParentByClassId(body: string[] | null | undefined): Observable<ParentByClass[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListParentByClassId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListParentByClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListParentByClassId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentByClass[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentByClass[]>;
        }));
    }

    protected processGetListParentByClassId(response: HttpResponseBase): Observable<ParentByClass[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParentByClass.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllInfoListClass(): Observable<ClassInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetAllInfoListClass";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInfoListClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInfoListClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassInfoDto[]>;
        }));
    }

    protected processGetAllInfoListClass(response: HttpResponseBase): Observable<ClassInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getInfoClassByCourse(body: GuidEntityDto | undefined): Observable<ClassInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetInfoClassByCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoClassByCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoClassByCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassInfoDto[]>;
        }));
    }

    protected processGetInfoClassByCourse(response: HttpResponseBase): Observable<ClassInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getInfoClassById(body: GuidEntityDto | undefined): Observable<ClassInfoDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetInfoClassById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoClassById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoClassById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassInfoDto>;
        }));
    }

    protected processGetInfoClassById(response: HttpResponseBase): Observable<ClassInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListChatByClass(body: ClassGuidGetDto | undefined): Observable<ClassByChatOutput> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListChatByClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListChatByClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListChatByClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassByChatOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassByChatOutput>;
        }));
    }

    protected processGetListChatByClass(response: HttpResponseBase): Observable<ClassByChatOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassByChatOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListChatParent(body: ClassGuidGetDto | undefined): Observable<ClassParentDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Class/GetListChatParent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListChatParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListChatParent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassParentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassParentDto[]>;
        }));
    }

    protected processGetListChatParent(response: HttpResponseBase): Observable<ClassParentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassParentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ClassInputDto | undefined): Observable<ClassInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Class/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClassInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ClassInputDto | undefined): Observable<ClassInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Class/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClassInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Class/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSchedule(body: ClassInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Class/UpdateSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMeeting(body: CalendarDto | undefined): Observable<MeetingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Class/CreateMeeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMeeting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMeeting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeetingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeetingDto>;
        }));
    }

    protected processCreateMeeting(response: HttpResponseBase): Observable<MeetingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeetingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveCouserClass(body: MoveCouserClassOutputDto | undefined): Observable<ClassInputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Class/MoveCouserClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveCouserClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveCouserClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassInputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassInputDto[]>;
        }));
    }

    protected processMoveCouserClass(response: HttpResponseBase): Observable<ClassInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CourseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CourseGuidGetDto | undefined): Observable<CourseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Course/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CourseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<CourseOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Course/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CourseOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getListKhoaHocVaLopHocGiaoVienDay(): Observable<KhoaHocGiaoVienDayDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Course/GetListKhoaHocVaLopHocGiaoVienDay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListKhoaHocVaLopHocGiaoVienDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListKhoaHocVaLopHocGiaoVienDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KhoaHocGiaoVienDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KhoaHocGiaoVienDayDto[]>;
        }));
    }

    protected processGetListKhoaHocVaLopHocGiaoVienDay(response: HttpResponseBase): Observable<KhoaHocGiaoVienDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KhoaHocGiaoVienDayDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CourseInputDto | undefined): Observable<CourseInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Course/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CourseInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CourseInputDto | undefined): Observable<CourseInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Course/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CourseInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Course/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CourseClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CourseGuidGetDto | undefined): Observable<CourseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/CourseClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CourseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CurriculumClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<CurriculumOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Curriculum/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurriculumOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurriculumOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CurriculumOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurriculumOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CurriculumGuidGetDto | undefined): Observable<CurriculumOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Curriculum/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurriculumOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurriculumOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CurriculumOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurriculumOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CurriculumInputDto | undefined): Observable<CurriculumInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Curriculum/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurriculumInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurriculumInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CurriculumInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurriculumInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CurriculumInputDto | undefined): Observable<CurriculumInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Curriculum/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurriculumInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurriculumInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CurriculumInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurriculumInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Curriculum/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autoGenerateCurriculumClassByCourseId(body: GuidEntityDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Curriculum/AutoGenerateCurriculumClassByCourseId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoGenerateCurriculumClassByCourseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoGenerateCurriculumClassByCourseId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAutoGenerateCurriculumClassByCourseId(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getData(body: DataInputDto | undefined): Observable<ValueDataOuputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Data/GetData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueDataOuputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueDataOuputDto>;
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<ValueDataOuputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueDataOuputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportExcelData(body: DataInputDto | undefined): Observable<FileEntity> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Data/ExportExcelData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileEntity>;
        }));
    }

    protected processExportExcelData(response: HttpResponseBase): Observable<FileEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportInfoFamily(body: GuidEntityDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Data/ExportInfoFamily";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportInfoFamily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportInfoFamily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportInfoFamily(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setData(body: DataInputDto | undefined): Observable<DataOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Data/SetData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto>;
        }));
    }

    protected processSetData(response: HttpResponseBase): Observable<DataOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getNienKhoa(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataCategory/GetNienKhoa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNienKhoa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNienKhoa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetNienKhoa(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getKhoiHoc(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataCategory/GetKhoiHoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKhoiHoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKhoiHoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetKhoiHoc(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataGiaoVienClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGiaoVien(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataGiaoVien/GetGiaoVien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGiaoVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGiaoVien(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetGiaoVien(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataHocSinhClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHocSinhFullName(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataHocSinh/GetHocSinhFullName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHocSinhFullName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHocSinhFullName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetHocSinhFullName(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHocSinhName(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataHocSinh/GetHocSinhName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHocSinhName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHocSinhName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetHocSinhName(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHocSinhSurname(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataHocSinh/GetHocSinhSurname";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHocSinhSurname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHocSinhSurname(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetHocSinhSurname(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataKhoaHocClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getKhoaHoc(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataKhoaHoc/GetKhoaHoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKhoaHoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKhoaHoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetKhoaHoc(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataLopHocClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getLopHoc(body: StringEntityDto | undefined): Observable<DataOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/DataLopHoc/GetLopHoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLopHoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLopHoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto[]>;
        }));
    }

    protected processGetLopHoc(response: HttpResponseBase): Observable<DataOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EvaluateStudentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: EvaluateStudentGuidGetDto | undefined): Observable<EvaluateStudentOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/EvaluateStudent/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluateStudentOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluateStudentOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<EvaluateStudentOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EvaluateStudentOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<EvaluateStudentOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/EvaluateStudent/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluateStudentOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluateStudentOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EvaluateStudentOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluateStudentOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: EvaluateStudentInputDto | undefined): Observable<EvaluateStudentInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/EvaluateStudent/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluateStudentInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluateStudentInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EvaluateStudentInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluateStudentInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EvaluateStudentInputDto | undefined): Observable<EvaluateStudentInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/EvaluateStudent/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluateStudentInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluateStudentInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EvaluateStudentInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluateStudentInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/EvaluateStudent/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: EvaluateStudentInputDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/EvaluateStudent/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteByReferenceId(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/EvaluateStudent/DeleteByReferenceId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteByReferenceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteByReferenceId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteByReferenceId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EvaluationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<EvaluationDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Evaluation/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EvaluationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: EvaluationGuidGetDto | undefined): Observable<EvaluationDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Evaluation/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<EvaluationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EvaluationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: EvaluationDto | undefined): Observable<EvaluationDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Evaluation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EvaluationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EvaluationDto | undefined): Observable<EvaluationDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Evaluation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EvaluationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Evaluation/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: EvaluationDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Evaluation/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: EvaluationDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Evaluation/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lockOrActiveEvaluation(body: LockOrActiveEvaluationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Evaluation/LockOrActiveEvaluation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockOrActiveEvaluation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockOrActiveEvaluation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLockOrActiveEvaluation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: ExamGuidGetDto | undefined): Observable<ExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Exam/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<ExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Exam/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByStudent(body: GuidEntityDto | undefined): Observable<ExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Exam/GetByStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamOutputDto>;
        }));
    }

    protected processGetByStudent(response: HttpResponseBase): Observable<ExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ExamInputDto | undefined): Observable<ExamInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Exam/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ExamInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ExamInputDto | undefined): Observable<ExamInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Exam/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ExamInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Exam/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExerciseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: ExerciseGuidGetDto | undefined): Observable<ExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Exercise/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<ExerciseOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Exercise/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ExerciseOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListByCodeEduCategory(body: GetExerciseDto | undefined): Observable<ExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Exercise/GetListByCodeEduCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListByCodeEduCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListByCodeEduCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOutputDto[]>;
        }));
    }

    protected processGetListByCodeEduCategory(response: HttpResponseBase): Observable<ExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ExerciseInputDto | undefined): Observable<ExerciseInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Exercise/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ExerciseInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ExerciseInputDto | undefined): Observable<ExerciseInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Exercise/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ExerciseInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Exercise/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExerciseClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: ExerciseClassGuidGetDto | undefined): Observable<ExerciseClassDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClass/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ExerciseClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getById(body: GuidEntityDto | undefined): Observable<ExerciseClassDetailOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClass/GetById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassDetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassDetailOutputDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ExerciseClassDetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseClassDetailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllByLessonId(body: GetAllExerciseClassDetailDto | undefined): Observable<ExerciseClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClass/GetAllByLessonId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByLessonId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByLessonId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassOutputDto[]>;
        }));
    }

    protected processGetAllByLessonId(response: HttpResponseBase): Observable<ExerciseClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllBySessionId(body: GetExerciseClassBySessionDto | undefined): Observable<ExerciseClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClass/GetAllBySessionId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBySessionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBySessionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassOutputDto[]>;
        }));
    }

    protected processGetAllBySessionId(response: HttpResponseBase): Observable<ExerciseClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getExerciseByExerciseClassIds(body: string[] | null | undefined): Observable<ExerciseClassDetailOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClass/GetExerciseByExerciseClassIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExerciseByExerciseClassIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExerciseByExerciseClassIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassDetailOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassDetailOutputDto[]>;
        }));
    }

    protected processGetExerciseByExerciseClassIds(response: HttpResponseBase): Observable<ExerciseClassDetailOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassDetailOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllByLessonIdPrint(body: GetAllExerciseClassDetailDto | undefined): Observable<ExerciseClassDetailOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClass/GetAllByLessonIdPrint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByLessonIdPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByLessonIdPrint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassDetailOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassDetailOutputDto[]>;
        }));
    }

    protected processGetAllByLessonIdPrint(response: HttpResponseBase): Observable<ExerciseClassDetailOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassDetailOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseClass/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consign(body: ExerciseClassDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseClass/Consign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsign(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setCategory(body: ExerciseClassDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseClass/SetCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: ExerciseClassDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseClass/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExerciseClassClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getById(body: GuidEntityDto | undefined): Observable<ExerciseClassDetailOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClassClient/GetById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassDetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassDetailOutputDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ExerciseClassDetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseClassDetailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllByLessonId(body: GetAllExerciseClassDetailDto | undefined): Observable<ExerciseClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClassClient/GetAllByLessonId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByLessonId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByLessonId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassOutputDto[]>;
        }));
    }

    protected processGetAllByLessonId(response: HttpResponseBase): Observable<ExerciseClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllByLessonIdPrint(body: GetAllExerciseClassDetailDto | undefined): Observable<ExerciseClassDetailOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseClassClient/GetAllByLessonIdPrint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByLessonIdPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByLessonIdPrint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseClassDetailOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseClassDetailOutputDto[]>;
        }));
    }

    protected processGetAllByLessonIdPrint(response: HttpResponseBase): Observable<ExerciseClassDetailOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseClassDetailOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExerciseOrQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: GetExeOrQuesByCodeEduDto | undefined): Observable<ExerciseOrQuestionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseOrQuestion/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOrQuestionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOrQuestionOutputDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ExerciseOrQuestionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseOrQuestionOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: StringEntityDto | undefined): Observable<ExerciseOrQuestionOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseOrQuestion/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOrQuestionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOrQuestionOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ExerciseOrQuestionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseOrQuestionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: GetExeOrQuesByCodeEduDto | undefined): Observable<ExerciseOrQuestionDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ExerciseOrQuestion/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOrQuestionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOrQuestionDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ExerciseOrQuestionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseOrQuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    aBC(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseOrQuestion/ABC";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processABC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processABC(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processABC(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ExerciseOrQuestionInputDto | undefined): Observable<ExerciseOrQuestionOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseOrQuestion/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOrQuestionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOrQuestionOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ExerciseOrQuestionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseOrQuestionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ExerciseOrQuestionInputDto | undefined): Observable<ExerciseOrQuestionOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseOrQuestion/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExerciseOrQuestionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExerciseOrQuestionOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ExerciseOrQuestionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExerciseOrQuestionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ExerciseOrQuestion/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GoogleDriveClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFiles(body: GetGoogleDriveInputDto | undefined): Observable<PageGoogleDriveOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GoogleDrive/GetFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageGoogleDriveOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageGoogleDriveOutputDto>;
        }));
    }

    protected processGetFiles(response: HttpResponseBase): Observable<PageGoogleDriveOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageGoogleDriveOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shareFile(body: GoogleDriveInputDto | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GoogleDrive/ShareFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShareFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShareFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processShareFile(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lockShareFile(body: GoogleDriveInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GoogleDrive/LockShareFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockShareFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockShareFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLockShareFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadBasicImage(body: DriveFileDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GoogleDrive/UploadBasicImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadBasicImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadBasicImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadBasicImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GradeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<GradeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Grade/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GradeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: GradeGuidGetDto | undefined): Observable<GradeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Grade/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<GradeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListGradeStudent(body: GetListSolveExerciseStudentDto | undefined): Observable<GradeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Grade/GetListGradeStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListGradeStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListGradeStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeOutputDto[]>;
        }));
    }

    protected processGetListGradeStudent(response: HttpResponseBase): Observable<GradeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAcademicResult(body: GetAcademicResultDto | undefined): Observable<AcademicResultDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Grade/GetAcademicResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAcademicResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAcademicResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicResultDto>;
        }));
    }

    protected processGetAcademicResult(response: HttpResponseBase): Observable<AcademicResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportAcademicResult(body: GetAcademicResultDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Grade/ExportAcademicResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAcademicResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAcademicResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportAcademicResult(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportSMSAcademicResult(body: GetSMSAcademicResultDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Grade/ExportSMSAcademicResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportSMSAcademicResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportSMSAcademicResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportSMSAcademicResult(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: GradeInputDto | undefined): Observable<GradeInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Grade/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GradeInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: GradeInputDto | undefined): Observable<GradeInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Grade/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GradeInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Grade/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: GradeInputDto[] | null | undefined): Observable<GradeInputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Grade/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeInputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeInputDto[]>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<GradeInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradeInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GradingPracticeExamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: GradingPracticeExamInputDto | undefined): Observable<GradingPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/GradingPracticeExam/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradingPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradingPracticeExamOutputDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GradingPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradingPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: StringEntityDto | undefined): Observable<GradingPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/GradingPracticeExam/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradingPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradingPracticeExamOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GradingPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradingPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: GradingPracticeExamInputDto | undefined): Observable<GradingPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GradingPracticeExam/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradingPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradingPracticeExamOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GradingPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradingPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: GradingPracticeExamInputDto[] | null | undefined): Observable<GradingPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GradingPracticeExam/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradingPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradingPracticeExamOutputDto[]>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<GradingPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradingPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: GradingPracticeExamInputDto[] | null | undefined): Observable<GradingPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GradingPracticeExam/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradingPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradingPracticeExamOutputDto[]>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<GradingPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradingPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: GradingPracticeExamInputDto | undefined): Observable<GradingPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GradingPracticeExam/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradingPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradingPracticeExamOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GradingPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradingPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GradingPracticeExam/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GroupClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: GroupClassGuidGetDto | undefined): Observable<GroupClassDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/GroupClass/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupClassDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<GroupClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStudentByTeacher(body: GroupClassGuidGetDto | undefined): Observable<GroupClassDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/GroupClass/GetStudentByTeacher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentByTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentByTeacher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupClassDto[]>;
        }));
    }

    protected processGetStudentByTeacher(response: HttpResponseBase): Observable<GroupClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGroupClassByUserId(body: GetGroupClassDto | undefined): Observable<GroupClassDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/GroupClass/GetGroupClassByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupClassByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupClassByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupClassDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupClassDto[]>;
        }));
    }

    protected processGetGroupClassByUserId(response: HttpResponseBase): Observable<GroupClassDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupClassDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xuatDanhSachSLHocSinhNhom(body: StringEntityDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/GroupClass/XuatDanhSachSLHocSinhNhom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatDanhSachSLHocSinhNhom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatDanhSachSLHocSinhNhom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processXuatDanhSachSLHocSinhNhom(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: GroupClass[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GroupClass/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: GroupClassDto | undefined): Observable<GroupClassDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GroupClass/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupClassDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupClassDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GroupClassDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupClassDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: GroupClassDto | undefined): Observable<GroupClassDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GroupClass/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupClassDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupClassDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GroupClassDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupClassDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GroupClass/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: GroupClassDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GroupClass/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteList(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/GroupClass/DeleteList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HealthDeclarationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: HealthDeclarationGuidGetDto | undefined): Observable<HealthDeclarationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/HealthDeclaration/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthDeclarationOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthDeclarationOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<HealthDeclarationOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HealthDeclarationOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<HealthDeclarationOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/HealthDeclaration/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthDeclarationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthDeclarationOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HealthDeclarationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthDeclarationOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSearch(body: HealthDeclarationGuidGetDto | undefined): Observable<HealthDeclarationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/HealthDeclaration/GetSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthDeclarationOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthDeclarationOutputDto[]>;
        }));
    }

    protected processGetSearch(response: HttpResponseBase): Observable<HealthDeclarationOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HealthDeclarationOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: HealthDeclarationInputDto | undefined): Observable<HealthDeclarationInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/HealthDeclaration/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthDeclarationInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthDeclarationInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HealthDeclarationInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthDeclarationInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: HealthDeclarationInputDto | undefined): Observable<HealthDeclarationInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/HealthDeclaration/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthDeclarationInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthDeclarationInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HealthDeclarationInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthDeclarationInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/HealthDeclaration/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LearnTimeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param role (optional) 
     * @return Success
     */
    get(role: string | null | undefined): Observable<ClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LearnTime/Get?";
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClassOutputDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param role (optional) 
     * @return Success
     */
    getCourse(role: string | null | undefined): Observable<RoleCourseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LearnTime/GetCourse?";
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleCourseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleCourseOutputDto[]>;
        }));
    }

    protected processGetCourse(response: HttpResponseBase): Observable<RoleCourseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleCourseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LessonClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: LessonGuidGetDto | undefined): Observable<LessonOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Lesson/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<LessonOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LessonOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<LessonOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Lesson/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LessonOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LessonOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LessonInputDto | undefined): Observable<LessonInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Lesson/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LessonInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LessonInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LessonInputDto | undefined): Observable<LessonInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Lesson/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LessonInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LessonInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Lesson/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LessonClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: LessonClassGuidGetDto | undefined): Observable<LessonClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LessonClass/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonClassOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<LessonClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LessonClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<LessonClassOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LessonClass/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonClassOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonClassOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LessonClassOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LessonClassOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDayLearn(body: GuidEntityDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LessonClass/GetDayLearn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDayLearn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDayLearn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetDayLearn(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllSession(body: LessonClassGuidGetDto | undefined): Observable<SessionClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LessonClass/GetAllSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SessionClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SessionClassOutputDto[]>;
        }));
    }

    protected processGetAllSession(response: HttpResponseBase): Observable<SessionClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SessionClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCodeEduCategory(body: GetCodeEduCategoryDto | undefined): Observable<DetailEduCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LessonClass/GetCodeEduCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCodeEduCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCodeEduCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetailEduCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetailEduCategoryDto[]>;
        }));
    }

    protected processGetCodeEduCategory(response: HttpResponseBase): Observable<DetailEduCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DetailEduCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    convertDetailEduCategoryDto(body: string[] | null | undefined): Observable<DetailEduCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LessonClass/ConvertDetailEduCategoryDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertDetailEduCategoryDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertDetailEduCategoryDto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DetailEduCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DetailEduCategoryDto[]>;
        }));
    }

    protected processConvertDetailEduCategoryDto(response: HttpResponseBase): Observable<DetailEduCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DetailEduCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteSession(body: DeleteSessionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/DeleteSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListByTeacher(body: LessonByTeacherDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/CreateListByTeacher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateListByTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateListByTeacher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateListByTeacher(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateList(body: LessonClassDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/UpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTimeLesson(body: SetLessonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/SetTimeLesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTimeLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTimeLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetTimeLesson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consignLesson(body: SetLessonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/ConsignLesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsignLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsignLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsignLesson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setStatusLesson(body: SetLessonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/SetStatusLesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetStatusLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetStatusLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetStatusLesson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setFileLesson(body: SetFileLessonsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LessonClass/SetFileLesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFileLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFileLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetFileLesson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LichSuHocClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: LichSuHocInputDto | undefined): Observable<LichSuHocOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/LichSuHoc/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichSuHocOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichSuHocOutputDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LichSuHocOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LichSuHocOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LichSuHocInputDto | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LichSuHoc/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStatusAync(body: LichSuHocInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/LichSuHoc/UpdateStatusAync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatusAync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatusAync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStatusAync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LogClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LogInputDto | undefined): Observable<LogOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Log/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LogOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LogInputDto | undefined): Observable<LogOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Log/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LogOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Log/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MeetingConversationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMeeting(body: MeetingConversationDto | undefined): Observable<MeetingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/MeetingConversation/GetMeeting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeeting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeeting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeetingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeetingDto>;
        }));
    }

    protected processGetMeeting(response: HttpResponseBase): Observable<MeetingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeetingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: MeetingConversationDto | undefined): Observable<MeetingConversationDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/MeetingConversation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeetingConversationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeetingConversationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MeetingConversationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeetingConversationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotificationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishNotification(body: RelationNotificationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Notification/PublishNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublishNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class QuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: QuestionGuidGetDto | undefined): Observable<QuestionDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Question/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<QuestionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RegisterClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerStudent(body: RegisterStudentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Register/RegisterStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterStudent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerListStudent(body: StudentInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Register/RegisterListStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterListStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterListStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterListStudent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInfoStudentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Register/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRegister(body: RegisterInfoStudentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Register/UpdateRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateListRegisterAccount(body: ListRegisterAccountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Register/UpdateListRegisterAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateListRegisterAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateListRegisterAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateListRegisterAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReviewSessionGradeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<ReviewSessionGradeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ReviewSessionGrade/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewSessionGradeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: ReviewSessionGradeGuidGetDto | undefined): Observable<ReviewSessionGradeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ReviewSessionGrade/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewSessionGradeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: ReviewSessionGradeGuidGetDto | undefined): Observable<ReviewSessionGradeOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ReviewSessionGrade/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewSessionGradeOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDashboard(body: ReviewSessionGradeGuidGetDto | undefined): Observable<ReviewSessionGradeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/ReviewSessionGrade/GetDashboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto[]>;
        }));
    }

    protected processGetDashboard(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewSessionGradeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    random(body: RandomReviewGradeDto | undefined): Observable<ReviewSessionGradeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ReviewSessionGrade/Random";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRandom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRandom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto>;
        }));
    }

    protected processRandom(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewSessionGradeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    takePhoto(body: StudentReviewDto | undefined): Observable<ReviewSessionGradeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ReviewSessionGrade/TakePhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakePhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto>;
        }));
    }

    protected processTakePhoto(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewSessionGradeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reScore(body: StudentReviewDto | undefined): Observable<ReviewSessionGradeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ReviewSessionGrade/ReScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReScore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto>;
        }));
    }

    protected processReScore(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewSessionGradeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reviewSessionGrade(body: ReviewSessionGradeInputDto | undefined): Observable<ReviewSessionGradeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/ReviewSessionGrade/ReviewSessionGrade";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewSessionGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewSessionGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewSessionGradeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewSessionGradeOutputDto>;
        }));
    }

    protected processReviewSessionGrade(response: HttpResponseBase): Observable<ReviewSessionGradeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewSessionGradeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SchoolScoreClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SchoolScoreDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SchoolScore/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolScoreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolScoreDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchoolScoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolScoreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SchoolScoreGuidGetDto | undefined): Observable<SchoolScoreDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SchoolScore/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolScoreDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolScoreDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SchoolScoreDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolScoreDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SchoolScoreInputDto | undefined): Observable<SchoolScoreInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SchoolScore/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolScoreInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolScoreInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchoolScoreInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolScoreInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SchoolScoreInputDto | undefined): Observable<SchoolScoreInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SchoolScore/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolScoreInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolScoreInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchoolScoreInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchoolScoreInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SchoolScore/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: SchoolScoreInputDto[] | null | undefined): Observable<SchoolScoreInputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SchoolScore/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchoolScoreInputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchoolScoreInputDto[]>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<SchoolScoreInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolScoreInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SendEmailJobClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmail(body: SentmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SendEmailJob/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendListEmail(body: SentmailDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SendEmailJob/SendListEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendListEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendListEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendListEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByListName(body: string[] | null | undefined): Observable<SettingDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Setting/GetByListName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByListName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByListName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto[]>;
        }));
    }

    protected processGetByListName(response: HttpResponseBase): Observable<SettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SettingGuidGetDto | undefined): Observable<SettingDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Setting/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Setting/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SettingDto | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Setting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SettingDto | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Setting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Setting/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByListName(body: string[] | null | undefined): Observable<SettingDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SettingClient/GetByListName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByListName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByListName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto[]>;
        }));
    }

    protected processGetByListName(response: HttpResponseBase): Observable<SettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SettingGuidGetDto | undefined): Observable<SettingDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SettingClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SettingClient/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SolveExerciseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SolveExerciseGuidGetDto | undefined): Observable<SolveExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SolveExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SolveExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SolveExerciseOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SolveExerciseOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SolveExerciseOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHistorySubmit(body: SolveExerciseDto | undefined): Observable<SolveExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetHistorySubmit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistorySubmit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistorySubmit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseOutputDto[]>;
        }));
    }

    protected processGetHistorySubmit(response: HttpResponseBase): Observable<SolveExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SolveExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListSolveExerciseStudent(body: GetListSolveExerciseStudentDto | undefined): Observable<SolveExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetListSolveExerciseStudent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListSolveExerciseStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListSolveExerciseStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseOutputDto[]>;
        }));
    }

    protected processGetListSolveExerciseStudent(response: HttpResponseBase): Observable<SolveExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SolveExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStudentPrint(body: GetSolveExerciseStudentPrintDto | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetStudentPrint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentPrint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetStudentPrint(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSolveExerciseStudentPrint(body: GetSolveExerciseStudentPrintDto | undefined): Observable<SolveExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetSolveExerciseStudentPrint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSolveExerciseStudentPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSolveExerciseStudentPrint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseOutputDto[]>;
        }));
    }

    protected processGetSolveExerciseStudentPrint(response: HttpResponseBase): Observable<SolveExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SolveExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSolveExerciseInfor(body: GuidEntityDto | undefined): Observable<SolveExerciseInfoOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetSolveExerciseInfor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSolveExerciseInfor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSolveExerciseInfor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseInfoOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseInfoOutputDto>;
        }));
    }

    protected processGetSolveExerciseInfor(response: HttpResponseBase): Observable<SolveExerciseInfoOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SolveExerciseInfoOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListScoreByStudentId(body: GetListSolveExerciseStudentDto | undefined): Observable<SolveExerciseOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetListScoreByStudentId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListScoreByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListScoreByStudentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseOutputDto[]>;
        }));
    }

    protected processGetListScoreByStudentId(response: HttpResponseBase): Observable<SolveExerciseOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SolveExerciseOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFileByGrade(body: GetFileByGradeDto | undefined): Observable<FileByGradeDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SolveExercise/GetFileByGrade";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileByGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileByGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileByGradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileByGradeDto[]>;
        }));
    }

    protected processGetFileByGrade(response: HttpResponseBase): Observable<FileByGradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileByGradeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SolveExerciseDto | undefined): Observable<SolveExerciseDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SolveExercise/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SolveExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SolveExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SolveExerciseDto | undefined): Observable<SolveExerciseDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SolveExercise/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SolveExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SolveExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SolveExercise/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createByLesson(body: SolveLessonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SolveExercise/CreateByLesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateByLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateByLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateByLesson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hitScore(body: HitScoreDto | undefined): Observable<SolveExerciseDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SolveExercise/HitScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHitScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHitScore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolveExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolveExerciseDto>;
        }));
    }

    protected processHitScore(response: HttpResponseBase): Observable<SolveExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SolveExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteScore(body: DeleteScoreDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SolveExercise/DeleteScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteScore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteScore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StudentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: StudentGuidGetDto | undefined): Observable<StudentOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Student/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<StudentOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: StudentGuidGetDto | undefined): Observable<StudentOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Student/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StudentOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<StudentOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Student/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StudentOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: StudentDto | undefined): Observable<StudentDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Student/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StudentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StudentDto | undefined): Observable<StudentDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Student/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StudentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Student/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteList(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Student/DeleteList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListSchedule(body: RegisterScheduleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Student/CreateListSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateListSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateListSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateListSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StudentAnswerPracticeExamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: StudentAnswerPracticeExamInputDto | undefined): Observable<StudentAnswerPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentAnswerPracticeExam/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAnswerPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAnswerPracticeExamOutputDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StudentAnswerPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentAnswerPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: StringEntityDto | undefined): Observable<StudentAnswerPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentAnswerPracticeExam/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAnswerPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAnswerPracticeExamOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StudentAnswerPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAnswerPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: StudentAnswerPracticeExamInputDto | undefined): Observable<StudentAnswerPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentAnswerPracticeExam/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAnswerPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAnswerPracticeExamOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StudentAnswerPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAnswerPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: StudentAnswerPracticeExamInputDto[] | null | undefined): Observable<StudentAnswerPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentAnswerPracticeExam/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAnswerPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAnswerPracticeExamOutputDto[]>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<StudentAnswerPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentAnswerPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StudentAnswerPracticeExamInputDto | undefined): Observable<StudentAnswerPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentAnswerPracticeExam/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentAnswerPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentAnswerPracticeExamOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StudentAnswerPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentAnswerPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentAnswerPracticeExam/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StudentClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: StudentClassGuidGetDto | undefined): Observable<StudentClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentClassOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<StudentClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: StudentClassGuidGetDto | undefined): Observable<StudentClassOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentClassOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentClassOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StudentClassOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentClassOutputDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListByListUserId(body: number[] | null | undefined): Observable<StudentClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/GetListByListUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListByListUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListByListUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentClassOutputDto[]>;
        }));
    }

    protected processGetListByListUserId(response: HttpResponseBase): Observable<StudentClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByUserId(body: GetStudentClassDto | undefined): Observable<StudentClassOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/GetByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentClassOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentClassOutputDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<StudentClassOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentClassOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStudentNewByCourseId(body: GetStudentNewDto | undefined): Observable<StudentClassOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/GetStudentNewByCourseId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentNewByCourseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentNewByCourseId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentClassOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentClassOutputDto[]>;
        }));
    }

    protected processGetStudentNewByCourseId(response: HttpResponseBase): Observable<StudentClassOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentClassOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xuatDanhSachHocSinh(body: StringEntityDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/XuatDanhSachHocSinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatDanhSachHocSinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatDanhSachHocSinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processXuatDanhSachHocSinh(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xuatLogDanhSachHocSinh(body: StringEntityDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentClass/XuatLogDanhSachHocSinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatLogDanhSachHocSinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatLogDanhSachHocSinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processXuatLogDanhSachHocSinh(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerStudentClass(body: RegisterStudentClassDto | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/RegisterStudentClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterStudentClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterStudentClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processRegisterStudentClass(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    movedStudentClass(body: MovedStudentClassDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/MovedStudentClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMovedStudentClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMovedStudentClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMovedStudentClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteByUserIds(body: DeleteStudentClassDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/DeleteByUserIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteByUserIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteByUserIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteByUserIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tuitionStudentClass(body: TuitionStudentClassDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/TuitionStudentClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTuitionStudentClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTuitionStudentClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTuitionStudentClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateListTuitionStudentClass(body: UpdateTuitionStudentClassDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/UpdateListTuitionStudentClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateListTuitionStudentClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateListTuitionStudentClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateListTuitionStudentClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restoreListStudentClass(body: MovedStudentClassDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/RestoreListStudentClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreListStudentClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreListStudentClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestoreListStudentClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    movedStudentClassByCouse(body: StudentClassDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/MovedStudentClassByCouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMovedStudentClassByCouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMovedStudentClassByCouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMovedStudentClassByCouse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StudentClassDto | undefined): Observable<StudentClassDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentClassDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentClassDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StudentClassDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentClassDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeListCache(body: StudentClass[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/RemoveListCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveListCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveListCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveListCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentClass/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StudentPracticeExamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: StudentPracticeExamInputDto | undefined): Observable<StudentPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentPracticeExam/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentPracticeExamOutputDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StudentPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: StringEntityDto | undefined): Observable<StudentPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentPracticeExam/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentPracticeExamOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StudentPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: StudentPracticeExamInputDto | undefined): Observable<StudentPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentPracticeExam/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentPracticeExamOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StudentPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: StudentPracticeExamInputDto[] | null | undefined): Observable<StudentPracticeExamOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentPracticeExam/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentPracticeExamOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentPracticeExamOutputDto[]>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<StudentPracticeExamOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentPracticeExamOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StudentPracticeExamInputDto | undefined): Observable<StudentPracticeExamOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentPracticeExam/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentPracticeExamOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentPracticeExamOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StudentPracticeExamOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentPracticeExamOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentPracticeExam/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StudentStickerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<StudentStickerOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentSticker/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentStickerOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentStickerOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StudentStickerOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentStickerOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: StudentStickerGuidGetDto | undefined): Observable<StudentStickerOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentSticker/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentStickerOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentStickerOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<StudentStickerOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentStickerOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: StudentStickerInputDto | undefined): Observable<StudentStickerInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentSticker/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentStickerInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentStickerInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StudentStickerInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentStickerInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StudentStickerInputDto | undefined): Observable<StudentStickerInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentSticker/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentStickerInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentStickerInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StudentStickerInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentStickerInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentSticker/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: StudentStickerInputDto[] | null | undefined): Observable<StudentStickerInputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentSticker/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentStickerInputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentStickerInputDto[]>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<StudentStickerInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentStickerInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StudentTuitionFeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: StudentTuitionFeeGuidGetDto | undefined): Observable<StudentTuitionFeeDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentTuitionFee/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentTuitionFeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentTuitionFeeDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<StudentTuitionFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentTuitionFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<StudentTuitionFeeDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentTuitionFee/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentTuitionFeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentTuitionFeeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StudentTuitionFeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentTuitionFeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByCourse(body: GetTuitionFeeByCourseDto | undefined): Observable<TuitionFeeByCourseDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentTuitionFee/GetByCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeByCourseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeByCourseDto>;
        }));
    }

    protected processGetByCourse(response: HttpResponseBase): Observable<TuitionFeeByCourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TuitionFeeByCourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByListUser(body: GetTuitionFeeByCourseDto | undefined): Observable<TuitionFeeByCourseDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/StudentTuitionFee/GetByListUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByListUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeByCourseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeByCourseDto>;
        }));
    }

    protected processGetByListUser(response: HttpResponseBase): Observable<TuitionFeeByCourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TuitionFeeByCourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: StudentTuitionFeeDto[] | null | undefined): Observable<StudentTuitionFeeDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentTuitionFee/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentTuitionFeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentTuitionFeeDto[]>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<StudentTuitionFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudentTuitionFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: StudentTuitionFeeDto | undefined): Observable<StudentTuitionFeeDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentTuitionFee/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentTuitionFeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentTuitionFeeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StudentTuitionFeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentTuitionFeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StudentTuitionFeeDto | undefined): Observable<StudentTuitionFeeDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentTuitionFee/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentTuitionFeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentTuitionFeeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StudentTuitionFeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentTuitionFeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/StudentTuitionFee/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubjectClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SubjectGuidGetDto | undefined): Observable<SubjectOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Subject/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SubjectOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubjectOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SubjectOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Subject/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SubjectOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SubjectInputDto | undefined): Observable<SubjectOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Subject/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SubjectOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SubjectInputDto | undefined): Observable<SubjectOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Subject/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SubjectOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Subject/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SurveyListClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SurveyListGuidGetDto | undefined): Observable<SurveyListOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SurveyList/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyListOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyListOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SurveyListOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SurveyListOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SurveyListOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/SurveyList/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyListOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyListOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SurveyListOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurveyListOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SurveyListInputDto | undefined): Observable<SurveyListInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SurveyList/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyListInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyListInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SurveyListInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurveyListInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SurveyListInputDto | undefined): Observable<SurveyListInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SurveyList/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyListInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyListInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SurveyListInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurveyListInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/SurveyList/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeaccherSessionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<TeaccherSessionDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TeaccherSession/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeaccherSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeaccherSessionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TeaccherSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeaccherSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TeaccherSessionGuidGetDto | undefined): Observable<TeaccherSessionDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TeaccherSession/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeaccherSessionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeaccherSessionDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TeaccherSessionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeaccherSessionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAttendanceOfSesstionByUserId(body: TeaccherSessionFilterDto | undefined): Observable<TeaccherSessionDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TeaccherSession/GetAttendanceOfSesstionByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttendanceOfSesstionByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttendanceOfSesstionByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeaccherSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeaccherSessionDto>;
        }));
    }

    protected processGetAttendanceOfSesstionByUserId(response: HttpResponseBase): Observable<TeaccherSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeaccherSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAttendanceByClassAndSession(body: TeaccherSessionFilterDto | undefined): Observable<TeaccherSessionDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TeaccherSession/GetAttendanceByClassAndSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttendanceByClassAndSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttendanceByClassAndSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeaccherSessionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeaccherSessionDto[]>;
        }));
    }

    protected processGetAttendanceByClassAndSession(response: HttpResponseBase): Observable<TeaccherSessionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeaccherSessionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TeaccherSessionDto | undefined): Observable<TeaccherSessionDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeaccherSession/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeaccherSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeaccherSessionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TeaccherSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeaccherSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TeaccherSessionDto | undefined): Observable<TeaccherSessionDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeaccherSession/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeaccherSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeaccherSessionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TeaccherSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeaccherSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeaccherSession/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: TeaccherSessionDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeaccherSession/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param session (optional) 
     * @param classId (optional) 
     * @return Success
     */
    checkTeacher(session: number | undefined, classId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeaccherSession/CheckTeacher?";
        if (session === null)
            throw new Error("The parameter 'session' cannot be null.");
        else if (session !== undefined)
            url_ += "session=" + encodeURIComponent("" + session) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTeacher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCheckTeacher(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeacherClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByUserId(body: Int64EntityDto | undefined): Observable<TeacherOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Teacher/GetByUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherOutputDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<TeacherOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TeacherGuidGetDto | undefined): Observable<TeacherOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/Teacher/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TeacherOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeacherOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setSubjects(body: TeacherInputDto | undefined): Observable<TeacherInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/Teacher/SetSubjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetSubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherInputDto>;
        }));
    }

    protected processSetSubjects(response: HttpResponseBase): Observable<TeacherInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeacherClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TeacherClassGuidGetDto | undefined): Observable<TeacherClassOuputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TeacherClass/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherClassOuputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherClassOuputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TeacherClassOuputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeacherClassOuputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TeacherClassInputDto | undefined): Observable<TeacherClassInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeacherClass/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherClassInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherClassInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TeacherClassInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherClassInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TeacherClassInputDto | undefined): Observable<TeacherClassInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeacherClass/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeacherClassInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeacherClassInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TeacherClassInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherClassInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TeacherClass/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TuitionFeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TuitionFeeGuidGetDto | undefined): Observable<TuitionFeeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TuitionFee/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TuitionFeeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TuitionFeeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<TuitionFeeOutputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TuitionFee/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TuitionFeeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TuitionFeeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getByListId(body: string[] | null | undefined): Observable<TuitionFeeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/read/TuitionFee/GetByListId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeOutputDto[]>;
        }));
    }

    protected processGetByListId(response: HttpResponseBase): Observable<TuitionFeeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TuitionFeeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TuitionFeeInputDto | undefined): Observable<TuitionFeeInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TuitionFee/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeInputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TuitionFeeInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TuitionFeeInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateList(body: TuitionFeeInputDto[] | null | undefined): Observable<TuitionFeeInputDto[]> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TuitionFee/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeInputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeInputDto[]>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<TuitionFeeInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TuitionFeeInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TuitionFeeInputDto | undefined): Observable<TuitionFeeInputDto> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TuitionFee/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TuitionFeeInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TuitionFeeInputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TuitionFeeInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TuitionFeeInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/EDU/write/TuitionFee/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VaiTroClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_EDU_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: StringEntityDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/EDU/read/VaiTro/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class StringEntityDto implements IStringEntityDto {
    id?: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IStringEntityDto {
    id?: string | undefined;
}

export enum OperationCriteria {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class CriteriaRequestDto implements ICriteriaRequestDto {
    propertyName?: string | undefined;
    operation?: OperationCriteria;
    value?: string | undefined;

    constructor(data?: ICriteriaRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.operation = _data["operation"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CriteriaRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CriteriaRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data;
    }
}

export interface ICriteriaRequestDto {
    propertyName?: string | undefined;
    operation?: OperationCriteria;
    value?: string | undefined;
}

export class AttachedCalendarGuidGetDto implements IAttachedCalendarGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IAttachedCalendarGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): AttachedCalendarGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachedCalendarGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IAttachedCalendarGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class DetailEduCategoryDto implements IDetailEduCategoryDto {
    groupCode?: string | undefined;
    name?: string | undefined;
    isPass?: boolean | undefined;
    id?: string;

    constructor(data?: IDetailEduCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupCode = _data["groupCode"];
            this.name = _data["name"];
            this.isPass = _data["isPass"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DetailEduCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailEduCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCode"] = this.groupCode;
        data["name"] = this.name;
        data["isPass"] = this.isPass;
        data["id"] = this.id;
        return data;
    }
}

export interface IDetailEduCategoryDto {
    groupCode?: string | undefined;
    name?: string | undefined;
    isPass?: boolean | undefined;
    id?: string;
}

export class ScheduleDto implements IScheduleDto {
    classId?: string | undefined;
    studentId?: number | undefined;
    teacherId?: number | undefined;
    day?: string | undefined;
    weekdays?: string | undefined;
    session?: string | undefined;
    address?: string | undefined;

    constructor(data?: IScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.studentId = _data["studentId"];
            this.teacherId = _data["teacherId"];
            this.day = _data["day"];
            this.weekdays = _data["weekdays"];
            this.session = _data["session"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): ScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["studentId"] = this.studentId;
        data["teacherId"] = this.teacherId;
        data["day"] = this.day;
        data["weekdays"] = this.weekdays;
        data["session"] = this.session;
        data["address"] = this.address;
        return data;
    }
}

export interface IScheduleDto {
    classId?: string | undefined;
    studentId?: number | undefined;
    teacherId?: number | undefined;
    day?: string | undefined;
    weekdays?: string | undefined;
    session?: string | undefined;
    address?: string | undefined;
}

export class AttachedCalendarOutputDto implements IAttachedCalendarOutputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listSchedule?: ScheduleDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    lessonId?: string | undefined;
    exerciseId?: string | undefined;
    schoolYearId?: string | undefined;
    userId?: number | undefined;
    period?: string | undefined;
    scoreTestFirst?: string | undefined;
    numberAttachedExpected?: number | undefined;
    numberAttachedReality?: number | undefined;
    startDay?: string | undefined;
    endDay?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IAttachedCalendarOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            this.classId = _data["classId"];
            this.subjectId = _data["subjectId"];
            this.lessonId = _data["lessonId"];
            this.exerciseId = _data["exerciseId"];
            this.schoolYearId = _data["schoolYearId"];
            this.userId = _data["userId"];
            this.period = _data["period"];
            this.scoreTestFirst = _data["scoreTestFirst"];
            this.numberAttachedExpected = _data["numberAttachedExpected"];
            this.numberAttachedReality = _data["numberAttachedReality"];
            this.startDay = _data["startDay"];
            this.endDay = _data["endDay"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AttachedCalendarOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachedCalendarOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        data["classId"] = this.classId;
        data["subjectId"] = this.subjectId;
        data["lessonId"] = this.lessonId;
        data["exerciseId"] = this.exerciseId;
        data["schoolYearId"] = this.schoolYearId;
        data["userId"] = this.userId;
        data["period"] = this.period;
        data["scoreTestFirst"] = this.scoreTestFirst;
        data["numberAttachedExpected"] = this.numberAttachedExpected;
        data["numberAttachedReality"] = this.numberAttachedReality;
        data["startDay"] = this.startDay;
        data["endDay"] = this.endDay;
        data["score"] = this.score;
        data["comment"] = this.comment;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IAttachedCalendarOutputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listSchedule?: ScheduleDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    lessonId?: string | undefined;
    exerciseId?: string | undefined;
    schoolYearId?: string | undefined;
    userId?: number | undefined;
    period?: string | undefined;
    scoreTestFirst?: string | undefined;
    numberAttachedExpected?: number | undefined;
    numberAttachedReality?: number | undefined;
    startDay?: string | undefined;
    endDay?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GuidEntityDto implements IGuidEntityDto {
    id?: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGuidEntityDto {
    id?: string;
}

export class AttachedCalendarInputDto implements IAttachedCalendarInputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listSchedule?: ScheduleDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    lessonId?: string | undefined;
    exerciseId?: string | undefined;
    schoolYearId?: string | undefined;
    userId?: number | undefined;
    period?: string | undefined;
    scoreTestFirst?: string | undefined;
    numberAttachedExpected?: number | undefined;
    numberAttachedReality?: number | undefined;
    startDay?: string | undefined;
    endDay?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IAttachedCalendarInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            this.classId = _data["classId"];
            this.subjectId = _data["subjectId"];
            this.lessonId = _data["lessonId"];
            this.exerciseId = _data["exerciseId"];
            this.schoolYearId = _data["schoolYearId"];
            this.userId = _data["userId"];
            this.period = _data["period"];
            this.scoreTestFirst = _data["scoreTestFirst"];
            this.numberAttachedExpected = _data["numberAttachedExpected"];
            this.numberAttachedReality = _data["numberAttachedReality"];
            this.startDay = _data["startDay"];
            this.endDay = _data["endDay"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AttachedCalendarInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachedCalendarInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        data["classId"] = this.classId;
        data["subjectId"] = this.subjectId;
        data["lessonId"] = this.lessonId;
        data["exerciseId"] = this.exerciseId;
        data["schoolYearId"] = this.schoolYearId;
        data["userId"] = this.userId;
        data["period"] = this.period;
        data["scoreTestFirst"] = this.scoreTestFirst;
        data["numberAttachedExpected"] = this.numberAttachedExpected;
        data["numberAttachedReality"] = this.numberAttachedReality;
        data["startDay"] = this.startDay;
        data["endDay"] = this.endDay;
        data["score"] = this.score;
        data["comment"] = this.comment;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IAttachedCalendarInputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listSchedule?: ScheduleDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    lessonId?: string | undefined;
    exerciseId?: string | undefined;
    schoolYearId?: string | undefined;
    userId?: number | undefined;
    period?: string | undefined;
    scoreTestFirst?: string | undefined;
    numberAttachedExpected?: number | undefined;
    numberAttachedReality?: number | undefined;
    startDay?: string | undefined;
    endDay?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class BaiTapCauTrucDeOutputDto implements IBaiTapCauTrucDeOutputDto {
    id?: string;
    name?: string | undefined;

    constructor(data?: IBaiTapCauTrucDeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BaiTapCauTrucDeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaiTapCauTrucDeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IBaiTapCauTrucDeOutputDto {
    id?: string;
    name?: string | undefined;
}

export class CauTrucDeOutputDto implements ICauTrucDeOutputDto {
    name?: string | undefined;
    index?: number;
    type?: string | undefined;
    listBaiTap?: BaiTapCauTrucDeOutputDto[] | undefined;

    constructor(data?: ICauTrucDeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.index = _data["index"];
            this.type = _data["type"];
            if (Array.isArray(_data["listBaiTap"])) {
                this.listBaiTap = [] as any;
                for (let item of _data["listBaiTap"])
                    this.listBaiTap!.push(BaiTapCauTrucDeOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CauTrucDeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CauTrucDeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["index"] = this.index;
        data["type"] = this.type;
        if (Array.isArray(this.listBaiTap)) {
            data["listBaiTap"] = [];
            for (let item of this.listBaiTap)
                data["listBaiTap"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICauTrucDeOutputDto {
    name?: string | undefined;
    index?: number;
    type?: string | undefined;
    listBaiTap?: BaiTapCauTrucDeOutputDto[] | undefined;
}

export class RemoveListCacheDto implements IRemoveListCacheDto {
    tenantId?: number | undefined;
    keys?: string[] | undefined;
    listName?: string[] | undefined;
    listRef?: string[] | undefined;

    constructor(data?: IRemoveListCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["keys"])) {
                this.keys = [] as any;
                for (let item of _data["keys"])
                    this.keys!.push(item);
            }
            if (Array.isArray(_data["listName"])) {
                this.listName = [] as any;
                for (let item of _data["listName"])
                    this.listName!.push(item);
            }
            if (Array.isArray(_data["listRef"])) {
                this.listRef = [] as any;
                for (let item of _data["listRef"])
                    this.listRef!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveListCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveListCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item);
        }
        if (Array.isArray(this.listName)) {
            data["listName"] = [];
            for (let item of this.listName)
                data["listName"].push(item);
        }
        if (Array.isArray(this.listRef)) {
            data["listRef"] = [];
            for (let item of this.listRef)
                data["listRef"].push(item);
        }
        return data;
    }
}

export interface IRemoveListCacheDto {
    tenantId?: number | undefined;
    keys?: string[] | undefined;
    listName?: string[] | undefined;
    listRef?: string[] | undefined;
}

export class CategoryGuidGetDto implements ICategoryGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ICategoryGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): CategoryGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ICategoryGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class DetailSubjectDto implements IDetailSubjectDto {
    name?: string | undefined;
    id?: string;

    constructor(data?: IDetailSubjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DetailSubjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailSubjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IDetailSubjectDto {
    name?: string | undefined;
    id?: string;
}

export class MenuCategoryDto implements IMenuCategoryDto {
    group?: string | undefined;
    name?: string | undefined;
    listSubject?: DetailSubjectDto[] | undefined;
    id?: string;

    constructor(data?: IMenuCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.name = _data["name"];
            if (Array.isArray(_data["listSubject"])) {
                this.listSubject = [] as any;
                for (let item of _data["listSubject"])
                    this.listSubject!.push(DetailSubjectDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["name"] = this.name;
        if (Array.isArray(this.listSubject)) {
            data["listSubject"] = [];
            for (let item of this.listSubject)
                data["listSubject"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IMenuCategoryDto {
    group?: string | undefined;
    name?: string | undefined;
    listSubject?: DetailSubjectDto[] | undefined;
    id?: string;
}

export class CategoryOutputDto implements ICategoryOutputDto {
    isActive?: boolean;
    group?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
    ssoCategoryId?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ICategoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"];
            this.group = _data["group"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.ssoCategoryId = _data["ssoCategoryId"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        data["group"] = this.group;
        data["value"] = this.value;
        data["description"] = this.description;
        data["ssoCategoryId"] = this.ssoCategoryId;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategoryOutputDto {
    isActive?: boolean;
    group?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
    ssoCategoryId?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class CategoryInputDto implements ICategoryInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    isActive?: boolean;
    group?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
    ssoCategoryId?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ICategoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.group = _data["group"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.ssoCategoryId = _data["ssoCategoryId"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["group"] = this.group;
        data["value"] = this.value;
        data["description"] = this.description;
        data["ssoCategoryId"] = this.ssoCategoryId;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategoryInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    code?: string | undefined;
    isActive?: boolean;
    group?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
    ssoCategoryId?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ClassGuidGetDto implements IClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IClassGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): ClassGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class ScheduleClassDto implements IScheduleClassDto {
    day?: string | undefined;
    listTime?: string[] | undefined;

    constructor(data?: IScheduleClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"];
            if (Array.isArray(_data["listTime"])) {
                this.listTime = [] as any;
                for (let item of _data["listTime"])
                    this.listTime!.push(item);
            }
        }
    }

    static fromJS(data: any): ScheduleClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        if (Array.isArray(this.listTime)) {
            data["listTime"] = [];
            for (let item of this.listTime)
                data["listTime"].push(item);
        }
        return data;
    }
}

export interface IScheduleClassDto {
    day?: string | undefined;
    listTime?: string[] | undefined;
}

export class MeetingDto implements IMeetingDto {
    id?: string | undefined;
    meetingLink?: string | undefined;

    constructor(data?: IMeetingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.meetingLink = _data["meetingLink"];
        }
    }

    static fromJS(data: any): MeetingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["meetingLink"] = this.meetingLink;
        return data;
    }
}

export interface IMeetingDto {
    id?: string | undefined;
    meetingLink?: string | undefined;
}

export class ClassOutputDto implements IClassOutputDto {
    listSchedule?: ScheduleClassDto[] | undefined;
    meettingOuput?: MeetingDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleClassDto.fromJS(item));
            }
            this.meettingOuput = _data["meettingOuput"] ? MeetingDto.fromJS(_data["meettingOuput"]) : <any>undefined;
            this.isTruant = _data["isTruant"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["meettingOuput"] = this.meettingOuput ? this.meettingOuput.toJSON() : <any>undefined;
        data["isTruant"] = this.isTruant;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassOutputDto {
    listSchedule?: ScheduleClassDto[] | undefined;
    meettingOuput?: MeetingDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class MeetingForMobileDto implements IMeetingForMobileDto {
    id?: string | undefined;
    classId?: string | undefined;
    meetingLink?: string | undefined;

    constructor(data?: IMeetingForMobileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.classId = _data["classId"];
            this.meetingLink = _data["meetingLink"];
        }
    }

    static fromJS(data: any): MeetingForMobileDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingForMobileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["classId"] = this.classId;
        data["meetingLink"] = this.meetingLink;
        return data;
    }
}

export interface IMeetingForMobileDto {
    id?: string | undefined;
    classId?: string | undefined;
    meetingLink?: string | undefined;
}

export class ClassDto implements IClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class MenuClassByParentDto implements IMenuClassByParentDto {
    listClass?: ClassDto[] | undefined;
    userId?: number;
    studentName?: string | undefined;

    constructor(data?: IMenuClassByParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(ClassDto.fromJS(item));
            }
            this.userId = _data["userId"];
            this.studentName = _data["studentName"];
        }
    }

    static fromJS(data: any): MenuClassByParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuClassByParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        data["userId"] = this.userId;
        data["studentName"] = this.studentName;
        return data;
    }
}

export interface IMenuClassByParentDto {
    listClass?: ClassDto[] | undefined;
    userId?: number;
    studentName?: string | undefined;
}

export class FileEduDto implements IFileEduDto {
    group?: string | undefined;
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;

    constructor(data?: IFileEduDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnail = _data["thumbnail"];
            this.reference = _data["reference"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FileEduDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileEduDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["thumbnail"] = this.thumbnail;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface IFileEduDto {
    group?: string | undefined;
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;
}

export class LessonInputDto implements ILessonInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;
    content?: string | undefined;
    subjectId?: string;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ILessonInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.content = _data["content"];
            this.subjectId = _data["subjectId"];
            this.index = _data["index"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LessonInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["content"] = this.content;
        data["subjectId"] = this.subjectId;
        data["index"] = this.index;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ILessonInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;
    content?: string | undefined;
    subjectId?: string;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class LessonClassOutputDto implements ILessonClassOutputDto {
    numberExercise?: number | undefined;
    numberSubmit?: number | undefined;
    numberNoSubmit?: number | undefined;
    numberScore?: number | undefined;
    numberStudent?: number | undefined;
    numberGrade?: number | undefined;
    lesson?: LessonInputDto;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    lessonId?: string;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ILessonClassOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberExercise = _data["numberExercise"];
            this.numberSubmit = _data["numberSubmit"];
            this.numberNoSubmit = _data["numberNoSubmit"];
            this.numberScore = _data["numberScore"];
            this.numberStudent = _data["numberStudent"];
            this.numberGrade = _data["numberGrade"];
            this.lesson = _data["lesson"] ? LessonInputDto.fromJS(_data["lesson"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.lessonId = _data["lessonId"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LessonClassOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonClassOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberExercise"] = this.numberExercise;
        data["numberSubmit"] = this.numberSubmit;
        data["numberNoSubmit"] = this.numberNoSubmit;
        data["numberScore"] = this.numberScore;
        data["numberStudent"] = this.numberStudent;
        data["numberGrade"] = this.numberGrade;
        data["lesson"] = this.lesson ? this.lesson.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["lessonId"] = this.lessonId;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ILessonClassOutputDto {
    numberExercise?: number | undefined;
    numberSubmit?: number | undefined;
    numberNoSubmit?: number | undefined;
    numberScore?: number | undefined;
    numberStudent?: number | undefined;
    numberGrade?: number | undefined;
    lesson?: LessonInputDto;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    lessonId?: string;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class ClassStatisticalDto implements IClassStatisticalDto {
    meeting?: MeetingDto;
    listLessonClass?: LessonClassOutputDto[] | undefined;
    listSchedule?: ScheduleClassDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassStatisticalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.meeting = _data["meeting"] ? MeetingDto.fromJS(_data["meeting"]) : <any>undefined;
            if (Array.isArray(_data["listLessonClass"])) {
                this.listLessonClass = [] as any;
                for (let item of _data["listLessonClass"])
                    this.listLessonClass!.push(LessonClassOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleClassDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassStatisticalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassStatisticalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meeting"] = this.meeting ? this.meeting.toJSON() : <any>undefined;
        if (Array.isArray(this.listLessonClass)) {
            data["listLessonClass"] = [];
            for (let item of this.listLessonClass)
                data["listLessonClass"].push(item.toJSON());
        }
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassStatisticalDto {
    meeting?: MeetingDto;
    listLessonClass?: LessonClassOutputDto[] | undefined;
    listSchedule?: ScheduleClassDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class StatisticalStudentClassDto implements IStatisticalStudentClassDto {
    listClass?: ClassStatisticalDto[] | undefined;
    userId?: number;
    studentName?: string | undefined;

    constructor(data?: IStatisticalStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(ClassStatisticalDto.fromJS(item));
            }
            this.userId = _data["userId"];
            this.studentName = _data["studentName"];
        }
    }

    static fromJS(data: any): StatisticalStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticalStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        data["userId"] = this.userId;
        data["studentName"] = this.studentName;
        return data;
    }
}

export interface IStatisticalStudentClassDto {
    listClass?: ClassStatisticalDto[] | undefined;
    userId?: number;
    studentName?: string | undefined;
}

export class ParentDto implements IParentDto {
    userId?: number;
    role?: string | undefined;
    childId?: number;

    constructor(data?: IParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.role = _data["role"];
            this.childId = _data["childId"];
        }
    }

    static fromJS(data: any): ParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["role"] = this.role;
        data["childId"] = this.childId;
        return data;
    }
}

export interface IParentDto {
    userId?: number;
    role?: string | undefined;
    childId?: number;
}

export class ParentByClass implements IParentByClass {
    listParent?: ParentDto[] | undefined;
    classId?: string | undefined;

    constructor(data?: IParentByClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listParent"])) {
                this.listParent = [] as any;
                for (let item of _data["listParent"])
                    this.listParent!.push(ParentDto.fromJS(item));
            }
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): ParentByClass {
        data = typeof data === 'object' ? data : {};
        let result = new ParentByClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listParent)) {
            data["listParent"] = [];
            for (let item of this.listParent)
                data["listParent"].push(item.toJSON());
        }
        data["classId"] = this.classId;
        return data;
    }
}

export interface IParentByClass {
    listParent?: ParentDto[] | undefined;
    classId?: string | undefined;
}

export class StudentClassDto implements IStudentClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    isTruant?: boolean | undefined;
    note?: string | undefined;
    ngayTamNghi?: number | undefined;
    typeStudent?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.isTruant = _data["isTruant"];
            this.note = _data["note"];
            this.ngayTamNghi = _data["ngayTamNghi"];
            this.typeStudent = _data["typeStudent"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["isTruant"] = this.isTruant;
        data["note"] = this.note;
        data["ngayTamNghi"] = this.ngayTamNghi;
        data["typeStudent"] = this.typeStudent;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    isTruant?: boolean | undefined;
    note?: string | undefined;
    ngayTamNghi?: number | undefined;
    typeStudent?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TeacherClassDto implements ITeacherClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    position?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITeacherClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.position = _data["position"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TeacherClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["position"] = this.position;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITeacherClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    position?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ClassInfoDto implements IClassInfoDto {
    listStudent?: StudentClassDto[] | undefined;
    listTeacher?: TeacherClassDto[] | undefined;
    listParent?: ParentDto[] | undefined;
    listSchedule?: ScheduleClassDto[] | undefined;
    meettingOuput?: MeetingDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(StudentClassDto.fromJS(item));
            }
            if (Array.isArray(_data["listTeacher"])) {
                this.listTeacher = [] as any;
                for (let item of _data["listTeacher"])
                    this.listTeacher!.push(TeacherClassDto.fromJS(item));
            }
            if (Array.isArray(_data["listParent"])) {
                this.listParent = [] as any;
                for (let item of _data["listParent"])
                    this.listParent!.push(ParentDto.fromJS(item));
            }
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleClassDto.fromJS(item));
            }
            this.meettingOuput = _data["meettingOuput"] ? MeetingDto.fromJS(_data["meettingOuput"]) : <any>undefined;
            this.isTruant = _data["isTruant"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        if (Array.isArray(this.listTeacher)) {
            data["listTeacher"] = [];
            for (let item of this.listTeacher)
                data["listTeacher"].push(item.toJSON());
        }
        if (Array.isArray(this.listParent)) {
            data["listParent"] = [];
            for (let item of this.listParent)
                data["listParent"].push(item.toJSON());
        }
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["meettingOuput"] = this.meettingOuput ? this.meettingOuput.toJSON() : <any>undefined;
        data["isTruant"] = this.isTruant;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassInfoDto {
    listStudent?: StudentClassDto[] | undefined;
    listTeacher?: TeacherClassDto[] | undefined;
    listParent?: ParentDto[] | undefined;
    listSchedule?: ScheduleClassDto[] | undefined;
    meettingOuput?: MeetingDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TeacherClassOuputDto implements ITeacherClassOuputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    position?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITeacherClassOuputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.position = _data["position"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TeacherClassOuputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassOuputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["position"] = this.position;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITeacherClassOuputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    position?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class StudentClassOutputDto implements IStudentClassOutputDto {
    studentName?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    isTruant?: boolean | undefined;
    note?: string | undefined;
    ngayTamNghi?: number | undefined;
    typeStudent?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentClassOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.isTruant = _data["isTruant"];
            this.note = _data["note"];
            this.ngayTamNghi = _data["ngayTamNghi"];
            this.typeStudent = _data["typeStudent"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentClassOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClassOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["isTruant"] = this.isTruant;
        data["note"] = this.note;
        data["ngayTamNghi"] = this.ngayTamNghi;
        data["typeStudent"] = this.typeStudent;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentClassOutputDto {
    studentName?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    isTruant?: boolean | undefined;
    note?: string | undefined;
    ngayTamNghi?: number | undefined;
    typeStudent?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class CourseOutputDto implements ICourseOutputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listObject?: string[] | undefined;
    startDay?: Date | undefined;
    endDay?: Date | undefined;
    description?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ICourseOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listObject"])) {
                this.listObject = [] as any;
                for (let item of _data["listObject"])
                    this.listObject!.push(item);
            }
            this.startDay = _data["startDay"] ? new Date(_data["startDay"].toString()) : <any>undefined;
            this.endDay = _data["endDay"] ? new Date(_data["endDay"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.typeModuleId = _data["typeModuleId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CourseOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listObject)) {
            data["listObject"] = [];
            for (let item of this.listObject)
                data["listObject"].push(item);
        }
        data["startDay"] = this.startDay ? this.startDay.toISOString() : <any>undefined;
        data["endDay"] = this.endDay ? this.endDay.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["typeModuleId"] = this.typeModuleId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ICourseOutputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listObject?: string[] | undefined;
    startDay?: Date | undefined;
    endDay?: Date | undefined;
    description?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ClassChatOutputDto implements IClassChatOutputDto {
    listTeacher?: TeacherClassOuputDto[] | undefined;
    listStudent?: StudentClassOutputDto[] | undefined;
    listParent?: ParentDto[] | undefined;
    meetingDto?: MeetingDto;
    courseDto?: CourseOutputDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassChatOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listTeacher"])) {
                this.listTeacher = [] as any;
                for (let item of _data["listTeacher"])
                    this.listTeacher!.push(TeacherClassOuputDto.fromJS(item));
            }
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(StudentClassOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listParent"])) {
                this.listParent = [] as any;
                for (let item of _data["listParent"])
                    this.listParent!.push(ParentDto.fromJS(item));
            }
            this.meetingDto = _data["meetingDto"] ? MeetingDto.fromJS(_data["meetingDto"]) : <any>undefined;
            this.courseDto = _data["courseDto"] ? CourseOutputDto.fromJS(_data["courseDto"]) : <any>undefined;
            this.isTruant = _data["isTruant"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassChatOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassChatOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listTeacher)) {
            data["listTeacher"] = [];
            for (let item of this.listTeacher)
                data["listTeacher"].push(item.toJSON());
        }
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        if (Array.isArray(this.listParent)) {
            data["listParent"] = [];
            for (let item of this.listParent)
                data["listParent"].push(item.toJSON());
        }
        data["meetingDto"] = this.meetingDto ? this.meetingDto.toJSON() : <any>undefined;
        data["courseDto"] = this.courseDto ? this.courseDto.toJSON() : <any>undefined;
        data["isTruant"] = this.isTruant;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassChatOutputDto {
    listTeacher?: TeacherClassOuputDto[] | undefined;
    listStudent?: StudentClassOutputDto[] | undefined;
    listParent?: ParentDto[] | undefined;
    meetingDto?: MeetingDto;
    courseDto?: CourseOutputDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class Member implements IMember {
    typeUser?: string | undefined;
    userId?: number;
    fullName?: string | undefined;
    emailAddress?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeUser = _data["typeUser"];
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.emailAddress = _data["emailAddress"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeUser"] = this.typeUser;
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        return data;
    }
}

export interface IMember {
    typeUser?: string | undefined;
    userId?: number;
    fullName?: string | undefined;
    emailAddress?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
}

export class GroupHub implements IGroupHub {
    application?: string | undefined;
    key?: string | undefined;
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    role?: string | undefined;
    creationTime?: Date | undefined;
    lastModificationTime?: Date | undefined;
    value?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    meetingLink?: string | undefined;
    numberNotRead?: number | undefined;
    listMember?: Member[] | undefined;

    constructor(data?: IGroupHub) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"];
            this.key = _data["key"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.role = _data["role"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.meetingLink = _data["meetingLink"];
            this.numberNotRead = _data["numberNotRead"];
            if (Array.isArray(_data["listMember"])) {
                this.listMember = [] as any;
                for (let item of _data["listMember"])
                    this.listMember!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupHub {
        data = typeof data === 'object' ? data : {};
        let result = new GroupHub();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application;
        data["key"] = this.key;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["role"] = this.role;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["meetingLink"] = this.meetingLink;
        data["numberNotRead"] = this.numberNotRead;
        if (Array.isArray(this.listMember)) {
            data["listMember"] = [];
            for (let item of this.listMember)
                data["listMember"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupHub {
    application?: string | undefined;
    key?: string | undefined;
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    role?: string | undefined;
    creationTime?: Date | undefined;
    lastModificationTime?: Date | undefined;
    value?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    meetingLink?: string | undefined;
    numberNotRead?: number | undefined;
    listMember?: Member[] | undefined;
}

export class Notify implements INotify {
    groupId?: string | undefined;
    userId?: number | undefined;
    type?: string | undefined;
    role?: string | undefined;
    name?: string | undefined;
    numberNotRead?: number | undefined;
    value?: string | undefined;

    constructor(data?: INotify) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.userId = _data["userId"];
            this.type = _data["type"];
            this.role = _data["role"];
            this.name = _data["name"];
            this.numberNotRead = _data["numberNotRead"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Notify {
        data = typeof data === 'object' ? data : {};
        let result = new Notify();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["userId"] = this.userId;
        data["type"] = this.type;
        data["role"] = this.role;
        data["name"] = this.name;
        data["numberNotRead"] = this.numberNotRead;
        data["value"] = this.value;
        return data;
    }
}

export interface INotify {
    groupId?: string | undefined;
    userId?: number | undefined;
    type?: string | undefined;
    role?: string | undefined;
    name?: string | undefined;
    numberNotRead?: number | undefined;
    value?: string | undefined;
}

export class NumberNotify implements INumberNotify {
    total?: number;
    listNotify?: Notify[] | undefined;

    constructor(data?: INumberNotify) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["listNotify"])) {
                this.listNotify = [] as any;
                for (let item of _data["listNotify"])
                    this.listNotify!.push(Notify.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NumberNotify {
        data = typeof data === 'object' ? data : {};
        let result = new NumberNotify();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.listNotify)) {
            data["listNotify"] = [];
            for (let item of this.listNotify)
                data["listNotify"].push(item.toJSON());
        }
        return data;
    }
}

export interface INumberNotify {
    total?: number;
    listNotify?: Notify[] | undefined;
}

export class ClassByChatOutput implements IClassByChatOutput {
    listClass?: ClassChatOutputDto[] | undefined;
    listGroup?: GroupHub[] | undefined;
    listNotify?: NumberNotify;

    constructor(data?: IClassByChatOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(ClassChatOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listGroup"])) {
                this.listGroup = [] as any;
                for (let item of _data["listGroup"])
                    this.listGroup!.push(GroupHub.fromJS(item));
            }
            this.listNotify = _data["listNotify"] ? NumberNotify.fromJS(_data["listNotify"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClassByChatOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ClassByChatOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        if (Array.isArray(this.listGroup)) {
            data["listGroup"] = [];
            for (let item of this.listGroup)
                data["listGroup"].push(item.toJSON());
        }
        data["listNotify"] = this.listNotify ? this.listNotify.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClassByChatOutput {
    listClass?: ClassChatOutputDto[] | undefined;
    listGroup?: GroupHub[] | undefined;
    listNotify?: NumberNotify;
}

export class ClassParentDto implements IClassParentDto {
    listClass?: ClassDto[] | undefined;
    listGroup?: GroupHub[] | undefined;
    listNotify?: NumberNotify;
    userId?: number;
    studentName?: string | undefined;

    constructor(data?: IClassParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(ClassDto.fromJS(item));
            }
            if (Array.isArray(_data["listGroup"])) {
                this.listGroup = [] as any;
                for (let item of _data["listGroup"])
                    this.listGroup!.push(GroupHub.fromJS(item));
            }
            this.listNotify = _data["listNotify"] ? NumberNotify.fromJS(_data["listNotify"]) : <any>undefined;
            this.userId = _data["userId"];
            this.studentName = _data["studentName"];
        }
    }

    static fromJS(data: any): ClassParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        if (Array.isArray(this.listGroup)) {
            data["listGroup"] = [];
            for (let item of this.listGroup)
                data["listGroup"].push(item.toJSON());
        }
        data["listNotify"] = this.listNotify ? this.listNotify.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["studentName"] = this.studentName;
        return data;
    }
}

export interface IClassParentDto {
    listClass?: ClassDto[] | undefined;
    listGroup?: GroupHub[] | undefined;
    listNotify?: NumberNotify;
    userId?: number;
    studentName?: string | undefined;
}

export class ClassInputDto implements IClassInputDto {
    listSchedule?: ScheduleClassDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleClassDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassInputDto {
    listSchedule?: ScheduleClassDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class AttendeeDto implements IAttendeeDto {
    userId?: number;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAttendeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AttendeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttendeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["name"] = this.name;
        return data;
    }
}

export interface IAttendeeDto {
    userId?: number;
    email?: string | undefined;
    name?: string | undefined;
}

export class CalendarDto implements ICalendarDto {
    classId?: string;
    description?: string | undefined;
    summary?: string | undefined;
    location?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    conferenceEventId?: string | undefined;
    meeting?: MeetingDto;
    listStudent?: AttendeeDto[] | undefined;
    listTeacher?: AttendeeDto[] | undefined;

    constructor(data?: ICalendarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.location = _data["location"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.conferenceEventId = _data["conferenceEventId"];
            this.meeting = _data["meeting"] ? MeetingDto.fromJS(_data["meeting"]) : <any>undefined;
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(AttendeeDto.fromJS(item));
            }
            if (Array.isArray(_data["listTeacher"])) {
                this.listTeacher = [] as any;
                for (let item of _data["listTeacher"])
                    this.listTeacher!.push(AttendeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalendarDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["location"] = this.location;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["conferenceEventId"] = this.conferenceEventId;
        data["meeting"] = this.meeting ? this.meeting.toJSON() : <any>undefined;
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        if (Array.isArray(this.listTeacher)) {
            data["listTeacher"] = [];
            for (let item of this.listTeacher)
                data["listTeacher"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICalendarDto {
    classId?: string;
    description?: string | undefined;
    summary?: string | undefined;
    location?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    conferenceEventId?: string | undefined;
    meeting?: MeetingDto;
    listStudent?: AttendeeDto[] | undefined;
    listTeacher?: AttendeeDto[] | undefined;
}

export class MoveClassDto implements IMoveClassDto {
    listStudentClass?: StudentClassDto[] | undefined;
    listTeacherClass?: TeacherClassDto[] | undefined;
    listSchedule?: ScheduleClassDto[] | undefined;
    meettingOuput?: MeetingDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IMoveClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listStudentClass"])) {
                this.listStudentClass = [] as any;
                for (let item of _data["listStudentClass"])
                    this.listStudentClass!.push(StudentClassDto.fromJS(item));
            }
            if (Array.isArray(_data["listTeacherClass"])) {
                this.listTeacherClass = [] as any;
                for (let item of _data["listTeacherClass"])
                    this.listTeacherClass!.push(TeacherClassDto.fromJS(item));
            }
            if (Array.isArray(_data["listSchedule"])) {
                this.listSchedule = [] as any;
                for (let item of _data["listSchedule"])
                    this.listSchedule!.push(ScheduleClassDto.fromJS(item));
            }
            this.meettingOuput = _data["meettingOuput"] ? MeetingDto.fromJS(_data["meettingOuput"]) : <any>undefined;
            this.isTruant = _data["isTruant"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.description = _data["description"];
            this.objectTypeId = _data["objectTypeId"];
            this.tuition = _data["tuition"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MoveClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listStudentClass)) {
            data["listStudentClass"] = [];
            for (let item of this.listStudentClass)
                data["listStudentClass"].push(item.toJSON());
        }
        if (Array.isArray(this.listTeacherClass)) {
            data["listTeacherClass"] = [];
            for (let item of this.listTeacherClass)
                data["listTeacherClass"].push(item.toJSON());
        }
        if (Array.isArray(this.listSchedule)) {
            data["listSchedule"] = [];
            for (let item of this.listSchedule)
                data["listSchedule"].push(item.toJSON());
        }
        data["meettingOuput"] = this.meettingOuput ? this.meettingOuput.toJSON() : <any>undefined;
        data["isTruant"] = this.isTruant;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["description"] = this.description;
        data["objectTypeId"] = this.objectTypeId;
        data["tuition"] = this.tuition;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IMoveClassDto {
    listStudentClass?: StudentClassDto[] | undefined;
    listTeacherClass?: TeacherClassDto[] | undefined;
    listSchedule?: ScheduleClassDto[] | undefined;
    meettingOuput?: MeetingDto;
    isTruant?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    description?: string | undefined;
    objectTypeId?: string | undefined;
    tuition?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class MoveCouserClassOutputDto implements IMoveCouserClassOutputDto {
    courseId?: string;
    oldCourseId?: string;
    schoolYearNew?: string | undefined;
    listClass?: MoveClassDto[] | undefined;

    constructor(data?: IMoveCouserClassOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.oldCourseId = _data["oldCourseId"];
            this.schoolYearNew = _data["schoolYearNew"];
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(MoveClassDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MoveCouserClassOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveCouserClassOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["oldCourseId"] = this.oldCourseId;
        data["schoolYearNew"] = this.schoolYearNew;
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMoveCouserClassOutputDto {
    courseId?: string;
    oldCourseId?: string;
    schoolYearNew?: string | undefined;
    listClass?: MoveClassDto[] | undefined;
}

export class CourseGuidGetDto implements ICourseGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ICourseGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): CourseGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ICourseGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class LopHocGiaoVienDayDto implements ILopHocGiaoVienDayDto {
    id?: string;
    name?: string | undefined;
    courseId?: string;

    constructor(data?: ILopHocGiaoVienDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.courseId = _data["courseId"];
        }
    }

    static fromJS(data: any): LopHocGiaoVienDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new LopHocGiaoVienDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["courseId"] = this.courseId;
        return data;
    }
}

export interface ILopHocGiaoVienDayDto {
    id?: string;
    name?: string | undefined;
    courseId?: string;
}

export class KhoaHocGiaoVienDayDto implements IKhoaHocGiaoVienDayDto {
    id?: string;
    name?: string | undefined;
    lopHocs?: LopHocGiaoVienDayDto[] | undefined;

    constructor(data?: IKhoaHocGiaoVienDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["lopHocs"])) {
                this.lopHocs = [] as any;
                for (let item of _data["lopHocs"])
                    this.lopHocs!.push(LopHocGiaoVienDayDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KhoaHocGiaoVienDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhoaHocGiaoVienDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.lopHocs)) {
            data["lopHocs"] = [];
            for (let item of this.lopHocs)
                data["lopHocs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKhoaHocGiaoVienDayDto {
    id?: string;
    name?: string | undefined;
    lopHocs?: LopHocGiaoVienDayDto[] | undefined;
}

export class CourseInputDto implements ICourseInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listObject?: string[] | undefined;
    startDay?: Date | undefined;
    endDay?: Date | undefined;
    description?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ICourseInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listObject"])) {
                this.listObject = [] as any;
                for (let item of _data["listObject"])
                    this.listObject!.push(item);
            }
            this.startDay = _data["startDay"] ? new Date(_data["startDay"].toString()) : <any>undefined;
            this.endDay = _data["endDay"] ? new Date(_data["endDay"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.typeModuleId = _data["typeModuleId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CourseInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listObject)) {
            data["listObject"] = [];
            for (let item of this.listObject)
                data["listObject"].push(item);
        }
        data["startDay"] = this.startDay ? this.startDay.toISOString() : <any>undefined;
        data["endDay"] = this.endDay ? this.endDay.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["typeModuleId"] = this.typeModuleId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ICourseInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listObject?: string[] | undefined;
    startDay?: Date | undefined;
    endDay?: Date | undefined;
    description?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class SubjectOutputDto implements ISubjectOutputDto {
    objectTypeId?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ISubjectOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectTypeId = _data["objectTypeId"];
            this.typeModuleId = _data["typeModuleId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubjectOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectTypeId"] = this.objectTypeId;
        data["typeModuleId"] = this.typeModuleId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubjectOutputDto {
    objectTypeId?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class NameLessonDto implements INameLessonDto {
    name?: string | undefined;
    code?: string | undefined;
    number1?: number;
    id?: string;

    constructor(data?: INameLessonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.number1 = _data["number1"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NameLessonDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameLessonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["number1"] = this.number1;
        data["id"] = this.id;
        return data;
    }
}

export interface INameLessonDto {
    name?: string | undefined;
    code?: string | undefined;
    number1?: number;
    id?: string;
}

export class LessonByDayDto implements ILessonByDayDto {
    listLesson?: NameLessonDto[] | undefined;

    constructor(data?: ILessonByDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listLesson"])) {
                this.listLesson = [] as any;
                for (let item of _data["listLesson"])
                    this.listLesson!.push(NameLessonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LessonByDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonByDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listLesson)) {
            data["listLesson"] = [];
            for (let item of this.listLesson)
                data["listLesson"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILessonByDayDto {
    listLesson?: NameLessonDto[] | undefined;
}

export class CurriculumOutputDto implements ICurriculumOutputDto {
    course?: CourseOutputDto;
    subject?: SubjectOutputDto;
    courseId?: string;
    subjectId?: string;
    classId?: string | undefined;
    listLessonByDay?: LessonByDayDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ICurriculumOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.course = _data["course"] ? CourseOutputDto.fromJS(_data["course"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectOutputDto.fromJS(_data["subject"]) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.classId = _data["classId"];
            if (Array.isArray(_data["listLessonByDay"])) {
                this.listLessonByDay = [] as any;
                for (let item of _data["listLessonByDay"])
                    this.listLessonByDay!.push(LessonByDayDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CurriculumOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurriculumOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["classId"] = this.classId;
        if (Array.isArray(this.listLessonByDay)) {
            data["listLessonByDay"] = [];
            for (let item of this.listLessonByDay)
                data["listLessonByDay"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICurriculumOutputDto {
    course?: CourseOutputDto;
    subject?: SubjectOutputDto;
    courseId?: string;
    subjectId?: string;
    classId?: string | undefined;
    listLessonByDay?: LessonByDayDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class CurriculumGuidGetDto implements ICurriculumGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ICurriculumGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): CurriculumGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurriculumGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ICurriculumGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class CurriculumInputDto implements ICurriculumInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    classId?: string | undefined;
    listLessonByDay?: LessonByDayDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ICurriculumInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.classId = _data["classId"];
            if (Array.isArray(_data["listLessonByDay"])) {
                this.listLessonByDay = [] as any;
                for (let item of _data["listLessonByDay"])
                    this.listLessonByDay!.push(LessonByDayDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CurriculumInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurriculumInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["classId"] = this.classId;
        if (Array.isArray(this.listLessonByDay)) {
            data["listLessonByDay"] = [];
            for (let item of this.listLessonByDay)
                data["listLessonByDay"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ICurriculumInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string;
    subjectId?: string;
    classId?: string | undefined;
    listLessonByDay?: LessonByDayDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class DataInputDto implements IDataInputDto {
    tenantId?: number | undefined;
    entityId?: string | undefined;
    code?: string | undefined;
    value?: string | undefined;
    option?: string | undefined;
    actions?: string | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IDataInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.code = _data["code"];
            this.value = _data["value"];
            this.option = _data["option"];
            this.actions = _data["actions"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): DataInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["code"] = this.code;
        data["value"] = this.value;
        data["option"] = this.option;
        data["actions"] = this.actions;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IDataInputDto {
    tenantId?: number | undefined;
    entityId?: string | undefined;
    code?: string | undefined;
    value?: string | undefined;
    option?: string | undefined;
    actions?: string | undefined;
    cacheKey?: string | undefined;
}

export class ValueDataOuputDto implements IValueDataOuputDto {
    code?: string | undefined;
    value?: string | undefined;
    values?: string[] | undefined;

    constructor(data?: IValueDataOuputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.value = _data["value"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): ValueDataOuputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueDataOuputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["value"] = this.value;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IValueDataOuputDto {
    code?: string | undefined;
    value?: string | undefined;
    values?: string[] | undefined;
}

export class FileEntity implements IFileEntity {
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;

    constructor(data?: IFileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnail = _data["thumbnail"];
            this.reference = _data["reference"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["thumbnail"] = this.thumbnail;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface IFileEntity {
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;
}

export class FileDto implements IFileDto {
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnail = _data["thumbnail"];
            this.reference = _data["reference"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["thumbnail"] = this.thumbnail;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface IFileDto {
    tenantId?: number | undefined;
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    fileUrl?: string | undefined;
    thumbnail?: boolean | undefined;
    reference?: string | undefined;
    id?: string | undefined;
}

export class DataOutputDto implements IDataOutputDto {
    tenantId?: number | undefined;
    entityId?: string | undefined;
    value?: string | undefined;
    option?: string | undefined;
    actions?: string | undefined;
    cacheKey?: string | undefined;
    header?: string | undefined;
    total?: number;
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    groupCode?: string | undefined;
    isDefault?: boolean | undefined;
    data?: string | undefined;

    constructor(data?: IDataOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.value = _data["value"];
            this.option = _data["option"];
            this.actions = _data["actions"];
            this.cacheKey = _data["cacheKey"];
            this.header = _data["header"];
            this.total = _data["total"];
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.groupCode = _data["groupCode"];
            this.isDefault = _data["isDefault"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DataOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["value"] = this.value;
        data["option"] = this.option;
        data["actions"] = this.actions;
        data["cacheKey"] = this.cacheKey;
        data["header"] = this.header;
        data["total"] = this.total;
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["groupCode"] = this.groupCode;
        data["isDefault"] = this.isDefault;
        data["data"] = this.data;
        return data;
    }
}

export interface IDataOutputDto {
    tenantId?: number | undefined;
    entityId?: string | undefined;
    value?: string | undefined;
    option?: string | undefined;
    actions?: string | undefined;
    cacheKey?: string | undefined;
    header?: string | undefined;
    total?: number;
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    groupCode?: string | undefined;
    isDefault?: boolean | undefined;
    data?: string | undefined;
}

export class EvaluateStudentGuidGetDto implements IEvaluateStudentGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IEvaluateStudentGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): EvaluateStudentGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateStudentGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IEvaluateStudentGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class EvaluateStudentOutputDto implements IEvaluateStudentOutputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    userId?: number;
    day?: string | undefined;
    type?: string | undefined;
    referenceId?: string | undefined;
    codeEduCategories?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    hour?: string | undefined;
    address?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    typeAttachedId?: string | undefined;
    typeTuitionId?: string | undefined;
    contentAttached?: string | undefined;
    contentParentExchange?: string | undefined;
    stateAttached?: string | undefined;
    evaluate?: string | undefined;
    typeModuleId?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IEvaluateStudentOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.day = _data["day"];
            this.type = _data["type"];
            this.referenceId = _data["referenceId"];
            this.codeEduCategories = _data["codeEduCategories"];
            this.comment = _data["comment"];
            this.teacherId = _data["teacherId"];
            this.hour = _data["hour"];
            this.address = _data["address"];
            this.classId = _data["classId"];
            this.subjectId = _data["subjectId"];
            this.typeAttachedId = _data["typeAttachedId"];
            this.typeTuitionId = _data["typeTuitionId"];
            this.contentAttached = _data["contentAttached"];
            this.contentParentExchange = _data["contentParentExchange"];
            this.stateAttached = _data["stateAttached"];
            this.evaluate = _data["evaluate"];
            this.typeModuleId = _data["typeModuleId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EvaluateStudentOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateStudentOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["day"] = this.day;
        data["type"] = this.type;
        data["referenceId"] = this.referenceId;
        data["codeEduCategories"] = this.codeEduCategories;
        data["comment"] = this.comment;
        data["teacherId"] = this.teacherId;
        data["hour"] = this.hour;
        data["address"] = this.address;
        data["classId"] = this.classId;
        data["subjectId"] = this.subjectId;
        data["typeAttachedId"] = this.typeAttachedId;
        data["typeTuitionId"] = this.typeTuitionId;
        data["contentAttached"] = this.contentAttached;
        data["contentParentExchange"] = this.contentParentExchange;
        data["stateAttached"] = this.stateAttached;
        data["evaluate"] = this.evaluate;
        data["typeModuleId"] = this.typeModuleId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IEvaluateStudentOutputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    userId?: number;
    day?: string | undefined;
    type?: string | undefined;
    referenceId?: string | undefined;
    codeEduCategories?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    hour?: string | undefined;
    address?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    typeAttachedId?: string | undefined;
    typeTuitionId?: string | undefined;
    contentAttached?: string | undefined;
    contentParentExchange?: string | undefined;
    stateAttached?: string | undefined;
    evaluate?: string | undefined;
    typeModuleId?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class EvaluateStudentInputDto implements IEvaluateStudentInputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    userId?: number;
    day?: string | undefined;
    type?: string | undefined;
    referenceId?: string | undefined;
    codeEduCategories?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    hour?: string | undefined;
    address?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    typeAttachedId?: string | undefined;
    typeTuitionId?: string | undefined;
    contentAttached?: string | undefined;
    contentParentExchange?: string | undefined;
    stateAttached?: string | undefined;
    evaluate?: string | undefined;
    typeModuleId?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IEvaluateStudentInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.day = _data["day"];
            this.type = _data["type"];
            this.referenceId = _data["referenceId"];
            this.codeEduCategories = _data["codeEduCategories"];
            this.comment = _data["comment"];
            this.teacherId = _data["teacherId"];
            this.hour = _data["hour"];
            this.address = _data["address"];
            this.classId = _data["classId"];
            this.subjectId = _data["subjectId"];
            this.typeAttachedId = _data["typeAttachedId"];
            this.typeTuitionId = _data["typeTuitionId"];
            this.contentAttached = _data["contentAttached"];
            this.contentParentExchange = _data["contentParentExchange"];
            this.stateAttached = _data["stateAttached"];
            this.evaluate = _data["evaluate"];
            this.typeModuleId = _data["typeModuleId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EvaluateStudentInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateStudentInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["day"] = this.day;
        data["type"] = this.type;
        data["referenceId"] = this.referenceId;
        data["codeEduCategories"] = this.codeEduCategories;
        data["comment"] = this.comment;
        data["teacherId"] = this.teacherId;
        data["hour"] = this.hour;
        data["address"] = this.address;
        data["classId"] = this.classId;
        data["subjectId"] = this.subjectId;
        data["typeAttachedId"] = this.typeAttachedId;
        data["typeTuitionId"] = this.typeTuitionId;
        data["contentAttached"] = this.contentAttached;
        data["contentParentExchange"] = this.contentParentExchange;
        data["stateAttached"] = this.stateAttached;
        data["evaluate"] = this.evaluate;
        data["typeModuleId"] = this.typeModuleId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IEvaluateStudentInputDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    userId?: number;
    day?: string | undefined;
    type?: string | undefined;
    referenceId?: string | undefined;
    codeEduCategories?: string | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    hour?: string | undefined;
    address?: string | undefined;
    classId?: string | undefined;
    subjectId?: string | undefined;
    typeAttachedId?: string | undefined;
    typeTuitionId?: string | undefined;
    contentAttached?: string | undefined;
    contentParentExchange?: string | undefined;
    stateAttached?: string | undefined;
    evaluate?: string | undefined;
    typeModuleId?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class EvaluationCodeDto implements IEvaluationCodeDto {
    index?: number | undefined;
    order?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEvaluationCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.order = _data["order"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EvaluationCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["order"] = this.order;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["id"] = this.id;
        return data;
    }
}

export interface IEvaluationCodeDto {
    index?: number | undefined;
    order?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    id?: string | undefined;
}

export class EvaluationDto implements IEvaluationDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    type?: string | undefined;
    session?: number;
    userId?: number | undefined;
    listEvaluationCode?: EvaluationCodeDto[] | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IEvaluationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.type = _data["type"];
            this.session = _data["session"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["listEvaluationCode"])) {
                this.listEvaluationCode = [] as any;
                for (let item of _data["listEvaluationCode"])
                    this.listEvaluationCode!.push(EvaluationCodeDto.fromJS(item));
            }
            this.comment = _data["comment"];
            this.teacherId = _data["teacherId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EvaluationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["type"] = this.type;
        data["session"] = this.session;
        data["userId"] = this.userId;
        if (Array.isArray(this.listEvaluationCode)) {
            data["listEvaluationCode"] = [];
            for (let item of this.listEvaluationCode)
                data["listEvaluationCode"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["teacherId"] = this.teacherId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IEvaluationDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    type?: string | undefined;
    session?: number;
    userId?: number | undefined;
    listEvaluationCode?: EvaluationCodeDto[] | undefined;
    comment?: string | undefined;
    teacherId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class EvaluationGuidGetDto implements IEvaluationGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IEvaluationGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): EvaluationGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IEvaluationGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class LockOrActiveEvaluationDto implements ILockOrActiveEvaluationDto {
    classId?: string;
    session?: number;
    teacherId?: number | undefined;
    status?: string | undefined;

    constructor(data?: ILockOrActiveEvaluationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.session = _data["session"];
            this.teacherId = _data["teacherId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): LockOrActiveEvaluationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LockOrActiveEvaluationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["session"] = this.session;
        data["teacherId"] = this.teacherId;
        data["status"] = this.status;
        return data;
    }
}

export interface ILockOrActiveEvaluationDto {
    classId?: string;
    session?: number;
    teacherId?: number | undefined;
    status?: string | undefined;
}

export class ExamGuidGetDto implements IExamGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IExamGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): ExamGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IExamGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class QuestionDto implements IQuestionDto {
    exerciseId?: string;
    content?: string | undefined;
    index?: number;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.content = _data["content"];
            this.index = _data["index"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["content"] = this.content;
        data["index"] = this.index;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IQuestionDto {
    exerciseId?: string;
    content?: string | undefined;
    index?: number;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ExerciseOutputDto implements IExerciseOutputDto {
    listFile?: FileEduDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    lessonId?: string;
    content?: string | undefined;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExerciseOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listQuestion"])) {
                this.listQuestion = [] as any;
                for (let item of _data["listQuestion"])
                    this.listQuestion!.push(QuestionDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lessonId = _data["lessonId"];
            this.content = _data["content"];
            this.index = _data["index"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExerciseOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listQuestion)) {
            data["listQuestion"] = [];
            for (let item of this.listQuestion)
                data["listQuestion"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lessonId"] = this.lessonId;
        data["content"] = this.content;
        data["index"] = this.index;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExerciseOutputDto {
    listFile?: FileEduDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    lessonId?: string;
    content?: string | undefined;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ExamOutputDto implements IExamOutputDto {
    listExercise?: ExerciseOutputDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    conducts?: string | undefined;
    answers?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    content?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    index?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExamOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listExercise"])) {
                this.listExercise = [] as any;
                for (let item of _data["listExercise"])
                    this.listExercise!.push(ExerciseOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listQuestion"])) {
                this.listQuestion = [] as any;
                for (let item of _data["listQuestion"])
                    this.listQuestion!.push(QuestionDto.fromJS(item));
            }
            this.conducts = _data["conducts"];
            this.answers = _data["answers"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.schoolYearId = _data["schoolYearId"];
            this.content = _data["content"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.index = _data["index"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExamOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listExercise)) {
            data["listExercise"] = [];
            for (let item of this.listExercise)
                data["listExercise"].push(item.toJSON());
        }
        if (Array.isArray(this.listQuestion)) {
            data["listQuestion"] = [];
            for (let item of this.listQuestion)
                data["listQuestion"].push(item.toJSON());
        }
        data["conducts"] = this.conducts;
        data["answers"] = this.answers;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["schoolYearId"] = this.schoolYearId;
        data["content"] = this.content;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["index"] = this.index;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExamOutputDto {
    listExercise?: ExerciseOutputDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    conducts?: string | undefined;
    answers?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    content?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    index?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ExerciseInputDto implements IExerciseInputDto {
    listFile?: FileEduDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    lessonId?: string;
    content?: string | undefined;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExerciseInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listQuestion"])) {
                this.listQuestion = [] as any;
                for (let item of _data["listQuestion"])
                    this.listQuestion!.push(QuestionDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lessonId = _data["lessonId"];
            this.content = _data["content"];
            this.index = _data["index"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExerciseInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listQuestion)) {
            data["listQuestion"] = [];
            for (let item of this.listQuestion)
                data["listQuestion"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lessonId"] = this.lessonId;
        data["content"] = this.content;
        data["index"] = this.index;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExerciseInputDto {
    listFile?: FileEduDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    lessonId?: string;
    content?: string | undefined;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ExamInputDto implements IExamInputDto {
    listExercise?: ExerciseInputDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    conducts?: string | undefined;
    answers?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    content?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    index?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExamInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listExercise"])) {
                this.listExercise = [] as any;
                for (let item of _data["listExercise"])
                    this.listExercise!.push(ExerciseInputDto.fromJS(item));
            }
            if (Array.isArray(_data["listQuestion"])) {
                this.listQuestion = [] as any;
                for (let item of _data["listQuestion"])
                    this.listQuestion!.push(QuestionDto.fromJS(item));
            }
            this.conducts = _data["conducts"];
            this.answers = _data["answers"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.schoolYearId = _data["schoolYearId"];
            this.content = _data["content"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.index = _data["index"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExamInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listExercise)) {
            data["listExercise"] = [];
            for (let item of this.listExercise)
                data["listExercise"].push(item.toJSON());
        }
        if (Array.isArray(this.listQuestion)) {
            data["listQuestion"] = [];
            for (let item of this.listQuestion)
                data["listQuestion"].push(item.toJSON());
        }
        data["conducts"] = this.conducts;
        data["answers"] = this.answers;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["schoolYearId"] = this.schoolYearId;
        data["content"] = this.content;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["index"] = this.index;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExamInputDto {
    listExercise?: ExerciseInputDto[] | undefined;
    listQuestion?: QuestionDto[] | undefined;
    conducts?: string | undefined;
    answers?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    content?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    index?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ExerciseGuidGetDto implements IExerciseGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IExerciseGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): ExerciseGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IExerciseGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class GetExerciseDto implements IGetExerciseDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    lessonId?: string | undefined;
    userId?: number | undefined;

    constructor(data?: IGetExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.lessonId = _data["lessonId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): GetExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["lessonId"] = this.lessonId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IGetExerciseDto {
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    lessonId?: string | undefined;
    userId?: number | undefined;
}

export class ExerciseClassGuidGetDto implements IExerciseClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IExerciseClassGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): ExerciseClassGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseClassGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IExerciseClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class ExerciseClassDto implements IExerciseClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    userId?: number | undefined;
    lessonClassId?: string;
    exerciseId?: string;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExerciseClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.lessonClassId = _data["lessonClassId"];
            this.exerciseId = _data["exerciseId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExerciseClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["lessonClassId"] = this.lessonClassId;
        data["exerciseId"] = this.exerciseId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExerciseClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    userId?: number | undefined;
    lessonClassId?: string;
    exerciseId?: string;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ExerciseClassDetailOutputDto implements IExerciseClassDetailOutputDto {
    exercise?: ExerciseInputDto;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    userId?: number | undefined;
    lessonClassId?: string;
    exerciseId?: string;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExerciseClassDetailOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exercise = _data["exercise"] ? ExerciseInputDto.fromJS(_data["exercise"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.lessonClassId = _data["lessonClassId"];
            this.exerciseId = _data["exerciseId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExerciseClassDetailOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseClassDetailOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exercise"] = this.exercise ? this.exercise.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["lessonClassId"] = this.lessonClassId;
        data["exerciseId"] = this.exerciseId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExerciseClassDetailOutputDto {
    exercise?: ExerciseInputDto;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    userId?: number | undefined;
    lessonClassId?: string;
    exerciseId?: string;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetAllExerciseClassDetailDto implements IGetAllExerciseClassDetailDto {
    classId?: string;
    lessonClassId?: string;
    lessonId?: string;
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IGetAllExerciseClassDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            this.lessonId = _data["lessonId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllExerciseClassDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllExerciseClassDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        data["lessonId"] = this.lessonId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IGetAllExerciseClassDetailDto {
    classId?: string;
    lessonClassId?: string;
    lessonId?: string;
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class ExerciseClassOutputDto implements IExerciseClassOutputDto {
    exercise?: ExerciseInputDto;
    numberSubmit?: number | undefined;
    numberNoSubmit?: number | undefined;
    numberScore?: number | undefined;
    numberStudent?: number | undefined;
    isSubmit?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    userId?: number | undefined;
    lessonClassId?: string;
    exerciseId?: string;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IExerciseClassOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exercise = _data["exercise"] ? ExerciseInputDto.fromJS(_data["exercise"]) : <any>undefined;
            this.numberSubmit = _data["numberSubmit"];
            this.numberNoSubmit = _data["numberNoSubmit"];
            this.numberScore = _data["numberScore"];
            this.numberStudent = _data["numberStudent"];
            this.isSubmit = _data["isSubmit"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.lessonClassId = _data["lessonClassId"];
            this.exerciseId = _data["exerciseId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExerciseClassOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseClassOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exercise"] = this.exercise ? this.exercise.toJSON() : <any>undefined;
        data["numberSubmit"] = this.numberSubmit;
        data["numberNoSubmit"] = this.numberNoSubmit;
        data["numberScore"] = this.numberScore;
        data["numberStudent"] = this.numberStudent;
        data["isSubmit"] = this.isSubmit;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["lessonClassId"] = this.lessonClassId;
        data["exerciseId"] = this.exerciseId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IExerciseClassOutputDto {
    exercise?: ExerciseInputDto;
    numberSubmit?: number | undefined;
    numberNoSubmit?: number | undefined;
    numberScore?: number | undefined;
    numberStudent?: number | undefined;
    isSubmit?: boolean | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    userId?: number | undefined;
    lessonClassId?: string;
    exerciseId?: string;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetExerciseClassBySessionDto implements IGetExerciseClassBySessionDto {
    classId?: string | undefined;
    listLessonClassId?: string[] | undefined;
    listLessonId?: string[] | undefined;
    id?: string;

    constructor(data?: IGetExerciseClassBySessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            if (Array.isArray(_data["listLessonClassId"])) {
                this.listLessonClassId = [] as any;
                for (let item of _data["listLessonClassId"])
                    this.listLessonClassId!.push(item);
            }
            if (Array.isArray(_data["listLessonId"])) {
                this.listLessonId = [] as any;
                for (let item of _data["listLessonId"])
                    this.listLessonId!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetExerciseClassBySessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExerciseClassBySessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        if (Array.isArray(this.listLessonClassId)) {
            data["listLessonClassId"] = [];
            for (let item of this.listLessonClassId)
                data["listLessonClassId"].push(item);
        }
        if (Array.isArray(this.listLessonId)) {
            data["listLessonId"] = [];
            for (let item of this.listLessonId)
                data["listLessonId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetExerciseClassBySessionDto {
    classId?: string | undefined;
    listLessonClassId?: string[] | undefined;
    listLessonId?: string[] | undefined;
    id?: string;
}

export class GetExeOrQuesByCodeEduDto implements IGetExeOrQuesByCodeEduDto {
    tenantId?: number | undefined;
    subjectId?: string | undefined;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    schoolId?: string | undefined;
    schoolYearId?: string | undefined;
    semesterId?: string | undefined;
    gradeTypeId?: string | undefined;
    tournamentId?: string | undefined;
    groupCode?: string | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IGetExeOrQuesByCodeEduDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.lessonId = _data["lessonId"];
            this.schoolId = _data["schoolId"];
            this.schoolYearId = _data["schoolYearId"];
            this.semesterId = _data["semesterId"];
            this.gradeTypeId = _data["gradeTypeId"];
            this.tournamentId = _data["tournamentId"];
            this.groupCode = _data["groupCode"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetExeOrQuesByCodeEduDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExeOrQuesByCodeEduDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["lessonId"] = this.lessonId;
        data["schoolId"] = this.schoolId;
        data["schoolYearId"] = this.schoolYearId;
        data["semesterId"] = this.semesterId;
        data["gradeTypeId"] = this.gradeTypeId;
        data["tournamentId"] = this.tournamentId;
        data["groupCode"] = this.groupCode;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IGetExeOrQuesByCodeEduDto {
    tenantId?: number | undefined;
    subjectId?: string | undefined;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    schoolId?: string | undefined;
    schoolYearId?: string | undefined;
    semesterId?: string | undefined;
    gradeTypeId?: string | undefined;
    tournamentId?: string | undefined;
    groupCode?: string | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class AnswerQuestionDto implements IAnswerQuestionDto {
    keyAnswer?: string | undefined;
    name?: string | undefined;
    contentAnswer?: string | undefined;
    explain?: string | undefined;
    isCorrect?: boolean | undefined;
    time?: number | undefined;
    score?: string | undefined;
    level?: string | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;

    constructor(data?: IAnswerQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyAnswer = _data["keyAnswer"];
            this.name = _data["name"];
            this.contentAnswer = _data["contentAnswer"];
            this.explain = _data["explain"];
            this.isCorrect = _data["isCorrect"];
            this.time = _data["time"];
            this.score = _data["score"];
            this.level = _data["level"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AnswerQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyAnswer"] = this.keyAnswer;
        data["name"] = this.name;
        data["contentAnswer"] = this.contentAnswer;
        data["explain"] = this.explain;
        data["isCorrect"] = this.isCorrect;
        data["time"] = this.time;
        data["score"] = this.score;
        data["level"] = this.level;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAnswerQuestionDto {
    keyAnswer?: string | undefined;
    name?: string | undefined;
    contentAnswer?: string | undefined;
    explain?: string | undefined;
    isCorrect?: boolean | undefined;
    time?: number | undefined;
    score?: string | undefined;
    level?: string | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
}

export class ValueExerciseOrQuestionDto implements IValueExerciseOrQuestionDto {
    listAnswerQuestion?: AnswerQuestionDto[] | undefined;
    time?: number | undefined;
    score?: string | undefined;
    level?: string | undefined;

    constructor(data?: IValueExerciseOrQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listAnswerQuestion"])) {
                this.listAnswerQuestion = [] as any;
                for (let item of _data["listAnswerQuestion"])
                    this.listAnswerQuestion!.push(AnswerQuestionDto.fromJS(item));
            }
            this.time = _data["time"];
            this.score = _data["score"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): ValueExerciseOrQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueExerciseOrQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listAnswerQuestion)) {
            data["listAnswerQuestion"] = [];
            for (let item of this.listAnswerQuestion)
                data["listAnswerQuestion"].push(item.toJSON());
        }
        data["time"] = this.time;
        data["score"] = this.score;
        data["level"] = this.level;
        return data;
    }
}

export interface IValueExerciseOrQuestionDto {
    listAnswerQuestion?: AnswerQuestionDto[] | undefined;
    time?: number | undefined;
    score?: string | undefined;
    level?: string | undefined;
}

export class ExerciseOrQuestionOutputDto implements IExerciseOrQuestionOutputDto {
    conducts?: string | undefined;
    suggest?: string | undefined;
    learnTheTopic?: string | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    subjectId?: string;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    moreInfo?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    index?: number;
    files?: string | undefined;
    content?: string | undefined;
    groupCode?: string | undefined;
    type?: string | undefined;
    multipleChoice?: ValueExerciseOrQuestionDto;
    essay?: ValueExerciseOrQuestionDto;

    constructor(data?: IExerciseOrQuestionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conducts = _data["conducts"];
            this.suggest = _data["suggest"];
            this.learnTheTopic = _data["learnTheTopic"];
            this.answers = _data["answers"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.lessonId = _data["lessonId"];
            this.moreInfo = _data["moreInfo"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.content = _data["content"];
            this.groupCode = _data["groupCode"];
            this.type = _data["type"];
            this.multipleChoice = _data["multipleChoice"] ? ValueExerciseOrQuestionDto.fromJS(_data["multipleChoice"]) : <any>undefined;
            this.essay = _data["essay"] ? ValueExerciseOrQuestionDto.fromJS(_data["essay"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExerciseOrQuestionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseOrQuestionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conducts"] = this.conducts;
        data["suggest"] = this.suggest;
        data["learnTheTopic"] = this.learnTheTopic;
        data["answers"] = this.answers;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["lessonId"] = this.lessonId;
        data["moreInfo"] = this.moreInfo;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["index"] = this.index;
        data["files"] = this.files;
        data["content"] = this.content;
        data["groupCode"] = this.groupCode;
        data["type"] = this.type;
        data["multipleChoice"] = this.multipleChoice ? this.multipleChoice.toJSON() : <any>undefined;
        data["essay"] = this.essay ? this.essay.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExerciseOrQuestionOutputDto {
    conducts?: string | undefined;
    suggest?: string | undefined;
    learnTheTopic?: string | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    subjectId?: string;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    moreInfo?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    index?: number;
    files?: string | undefined;
    content?: string | undefined;
    groupCode?: string | undefined;
    type?: string | undefined;
    multipleChoice?: ValueExerciseOrQuestionDto;
    essay?: ValueExerciseOrQuestionDto;
}

export class ExerciseOrQuestionDto implements IExerciseOrQuestionDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    subjectId?: string;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    moreInfo?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    index?: number;
    files?: string | undefined;
    content?: string | undefined;
    groupCode?: string | undefined;
    type?: string | undefined;
    multipleChoice?: ValueExerciseOrQuestionDto;
    essay?: ValueExerciseOrQuestionDto;

    constructor(data?: IExerciseOrQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.lessonId = _data["lessonId"];
            this.moreInfo = _data["moreInfo"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.content = _data["content"];
            this.groupCode = _data["groupCode"];
            this.type = _data["type"];
            this.multipleChoice = _data["multipleChoice"] ? ValueExerciseOrQuestionDto.fromJS(_data["multipleChoice"]) : <any>undefined;
            this.essay = _data["essay"] ? ValueExerciseOrQuestionDto.fromJS(_data["essay"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExerciseOrQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseOrQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["lessonId"] = this.lessonId;
        data["moreInfo"] = this.moreInfo;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["index"] = this.index;
        data["files"] = this.files;
        data["content"] = this.content;
        data["groupCode"] = this.groupCode;
        data["type"] = this.type;
        data["multipleChoice"] = this.multipleChoice ? this.multipleChoice.toJSON() : <any>undefined;
        data["essay"] = this.essay ? this.essay.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExerciseOrQuestionDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    subjectId?: string;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    moreInfo?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    index?: number;
    files?: string | undefined;
    content?: string | undefined;
    groupCode?: string | undefined;
    type?: string | undefined;
    multipleChoice?: ValueExerciseOrQuestionDto;
    essay?: ValueExerciseOrQuestionDto;
}

export class ExerciseOrQuestionInputDto implements IExerciseOrQuestionInputDto {
    conducts?: string | undefined;
    suggest?: string | undefined;
    learnTheTopic?: string | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    subjectId?: string;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    moreInfo?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    index?: number;
    files?: string | undefined;
    content?: string | undefined;
    groupCode?: string | undefined;
    type?: string | undefined;
    multipleChoice?: ValueExerciseOrQuestionDto;
    essay?: ValueExerciseOrQuestionDto;

    constructor(data?: IExerciseOrQuestionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conducts = _data["conducts"];
            this.suggest = _data["suggest"];
            this.learnTheTopic = _data["learnTheTopic"];
            this.answers = _data["answers"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.lessonId = _data["lessonId"];
            this.moreInfo = _data["moreInfo"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.content = _data["content"];
            this.groupCode = _data["groupCode"];
            this.type = _data["type"];
            this.multipleChoice = _data["multipleChoice"] ? ValueExerciseOrQuestionDto.fromJS(_data["multipleChoice"]) : <any>undefined;
            this.essay = _data["essay"] ? ValueExerciseOrQuestionDto.fromJS(_data["essay"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExerciseOrQuestionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseOrQuestionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conducts"] = this.conducts;
        data["suggest"] = this.suggest;
        data["learnTheTopic"] = this.learnTheTopic;
        data["answers"] = this.answers;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["lessonId"] = this.lessonId;
        data["moreInfo"] = this.moreInfo;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["index"] = this.index;
        data["files"] = this.files;
        data["content"] = this.content;
        data["groupCode"] = this.groupCode;
        data["type"] = this.type;
        data["multipleChoice"] = this.multipleChoice ? this.multipleChoice.toJSON() : <any>undefined;
        data["essay"] = this.essay ? this.essay.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExerciseOrQuestionInputDto {
    conducts?: string | undefined;
    suggest?: string | undefined;
    learnTheTopic?: string | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    subjectId?: string;
    objectTypeId?: string | undefined;
    lessonId?: string | undefined;
    moreInfo?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    index?: number;
    files?: string | undefined;
    content?: string | undefined;
    groupCode?: string | undefined;
    type?: string | undefined;
    multipleChoice?: ValueExerciseOrQuestionDto;
    essay?: ValueExerciseOrQuestionDto;
}

export class GetGoogleDriveInputDto implements IGetGoogleDriveInputDto {
    folderId?: string | undefined;
    pageToken?: string | undefined;

    constructor(data?: IGetGoogleDriveInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): GetGoogleDriveInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGoogleDriveInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

export interface IGetGoogleDriveInputDto {
    folderId?: string | undefined;
    pageToken?: string | undefined;
}

export class GoogleDriveOutputDto implements IGoogleDriveOutputDto {
    id?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    size?: number | undefined;
    link?: string | undefined;

    constructor(data?: IGoogleDriveOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
            this.link = _data["link"];
        }
    }

    static fromJS(data: any): GoogleDriveOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleDriveOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        data["link"] = this.link;
        return data;
    }
}

export interface IGoogleDriveOutputDto {
    id?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    size?: number | undefined;
    link?: string | undefined;
}

export class PageGoogleDriveOutputDto implements IPageGoogleDriveOutputDto {
    pageToken?: string | undefined;
    driveDatas?: GoogleDriveOutputDto[] | undefined;

    constructor(data?: IPageGoogleDriveOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageToken = _data["pageToken"];
            if (Array.isArray(_data["driveDatas"])) {
                this.driveDatas = [] as any;
                for (let item of _data["driveDatas"])
                    this.driveDatas!.push(GoogleDriveOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageGoogleDriveOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageGoogleDriveOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageToken"] = this.pageToken;
        if (Array.isArray(this.driveDatas)) {
            data["driveDatas"] = [];
            for (let item of this.driveDatas)
                data["driveDatas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageGoogleDriveOutputDto {
    pageToken?: string | undefined;
    driveDatas?: GoogleDriveOutputDto[] | undefined;
}

export class GoogleDriveInputDto implements IGoogleDriveInputDto {
    fileIds?: string[] | undefined;

    constructor(data?: IGoogleDriveInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fileIds"])) {
                this.fileIds = [] as any;
                for (let item of _data["fileIds"])
                    this.fileIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GoogleDriveInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleDriveInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fileIds)) {
            data["fileIds"] = [];
            for (let item of this.fileIds)
                data["fileIds"].push(item);
        }
        return data;
    }
}

export interface IGoogleDriveInputDto {
    fileIds?: string[] | undefined;
}

export class DriveFileDto implements IDriveFileDto {
    name?: string | undefined;
    mimeType?: string | undefined;
    data?: string | undefined;

    constructor(data?: IDriveFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DriveFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriveFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["data"] = this.data;
        return data;
    }
}

export interface IDriveFileDto {
    name?: string | undefined;
    mimeType?: string | undefined;
    data?: string | undefined;
}

export class ValueSolveGradeDto implements IValueSolveGradeDto {
    solveExerciseId?: string;
    teacherScoreId?: string | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;

    constructor(data?: IValueSolveGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.solveExerciseId = _data["solveExerciseId"];
            this.teacherScoreId = _data["teacherScoreId"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValueSolveGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueSolveGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["solveExerciseId"] = this.solveExerciseId;
        data["teacherScoreId"] = this.teacherScoreId;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValueSolveGradeDto {
    solveExerciseId?: string;
    teacherScoreId?: string | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
}

export class GradeOutputDto implements IGradeOutputDto {
    listSolveExercise?: ValueSolveGradeDto[] | undefined;
    listLessonClassId?: string[] | undefined;
    totalMonthSticker?: number | undefined;
    totalSticker?: number | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    gradeTypeId?: string | undefined;
    userId?: number | undefined;
    classId?: string | undefined;
    reasonRegrade?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IGradeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listSolveExercise"])) {
                this.listSolveExercise = [] as any;
                for (let item of _data["listSolveExercise"])
                    this.listSolveExercise!.push(ValueSolveGradeDto.fromJS(item));
            }
            if (Array.isArray(_data["listLessonClassId"])) {
                this.listLessonClassId = [] as any;
                for (let item of _data["listLessonClassId"])
                    this.listLessonClassId!.push(item);
            }
            this.totalMonthSticker = _data["totalMonthSticker"];
            this.totalSticker = _data["totalSticker"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            this.gradeTypeId = _data["gradeTypeId"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
            this.reasonRegrade = _data["reasonRegrade"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GradeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listSolveExercise)) {
            data["listSolveExercise"] = [];
            for (let item of this.listSolveExercise)
                data["listSolveExercise"].push(item.toJSON());
        }
        if (Array.isArray(this.listLessonClassId)) {
            data["listLessonClassId"] = [];
            for (let item of this.listLessonClassId)
                data["listLessonClassId"].push(item);
        }
        data["totalMonthSticker"] = this.totalMonthSticker;
        data["totalSticker"] = this.totalSticker;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["score"] = this.score;
        data["comment"] = this.comment;
        data["gradeTypeId"] = this.gradeTypeId;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        data["reasonRegrade"] = this.reasonRegrade;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IGradeOutputDto {
    listSolveExercise?: ValueSolveGradeDto[] | undefined;
    listLessonClassId?: string[] | undefined;
    totalMonthSticker?: number | undefined;
    totalSticker?: number | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    gradeTypeId?: string | undefined;
    userId?: number | undefined;
    classId?: string | undefined;
    reasonRegrade?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GradeGuidGetDto implements IGradeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IGradeGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GradeGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IGradeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class GetListSolveExerciseStudentDto implements IGetListSolveExerciseStudentDto {
    classId?: string;
    listLessonClassId?: string[] | undefined;
    listExerciseClassId?: string[] | undefined;
    userId?: number | undefined;
    status?: string | undefined;
    categoryId?: string | undefined;
    gradeTypeId?: string | undefined;
    session?: number;

    constructor(data?: IGetListSolveExerciseStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            if (Array.isArray(_data["listLessonClassId"])) {
                this.listLessonClassId = [] as any;
                for (let item of _data["listLessonClassId"])
                    this.listLessonClassId!.push(item);
            }
            if (Array.isArray(_data["listExerciseClassId"])) {
                this.listExerciseClassId = [] as any;
                for (let item of _data["listExerciseClassId"])
                    this.listExerciseClassId!.push(item);
            }
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.categoryId = _data["categoryId"];
            this.gradeTypeId = _data["gradeTypeId"];
            this.session = _data["session"];
        }
    }

    static fromJS(data: any): GetListSolveExerciseStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListSolveExerciseStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        if (Array.isArray(this.listLessonClassId)) {
            data["listLessonClassId"] = [];
            for (let item of this.listLessonClassId)
                data["listLessonClassId"].push(item);
        }
        if (Array.isArray(this.listExerciseClassId)) {
            data["listExerciseClassId"] = [];
            for (let item of this.listExerciseClassId)
                data["listExerciseClassId"].push(item);
        }
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["categoryId"] = this.categoryId;
        data["gradeTypeId"] = this.gradeTypeId;
        data["session"] = this.session;
        return data;
    }
}

export interface IGetListSolveExerciseStudentDto {
    classId?: string;
    listLessonClassId?: string[] | undefined;
    listExerciseClassId?: string[] | undefined;
    userId?: number | undefined;
    status?: string | undefined;
    categoryId?: string | undefined;
    gradeTypeId?: string | undefined;
    session?: number;
}

export class GetAcademicResultDto implements IGetAcademicResultDto {
    option?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    classId?: string | undefined;
    courseId?: string | undefined;
    schoolYear?: string | undefined;
    objectTypeId?: string | undefined;
    subjectId?: string | undefined;
    listUserId?: number[] | undefined;
    numberGroup?: number | undefined;
    numberOfSessionMin?: number | undefined;

    constructor(data?: IGetAcademicResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.option = _data["option"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.courseId = _data["courseId"];
            this.schoolYear = _data["schoolYear"];
            this.objectTypeId = _data["objectTypeId"];
            this.subjectId = _data["subjectId"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
            this.numberGroup = _data["numberGroup"];
            this.numberOfSessionMin = _data["numberOfSessionMin"];
        }
    }

    static fromJS(data: any): GetAcademicResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAcademicResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["option"] = this.option;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["courseId"] = this.courseId;
        data["schoolYear"] = this.schoolYear;
        data["objectTypeId"] = this.objectTypeId;
        data["subjectId"] = this.subjectId;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        data["numberGroup"] = this.numberGroup;
        data["numberOfSessionMin"] = this.numberOfSessionMin;
        return data;
    }
}

export interface IGetAcademicResultDto {
    option?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    classId?: string | undefined;
    courseId?: string | undefined;
    schoolYear?: string | undefined;
    objectTypeId?: string | undefined;
    subjectId?: string | undefined;
    listUserId?: number[] | undefined;
    numberGroup?: number | undefined;
    numberOfSessionMin?: number | undefined;
}

export class DetailAcademicResultDto implements IDetailAcademicResultDto {
    session?: number | undefined;
    classId?: string | undefined;
    score?: string | undefined;
    teacherScoreName?: string | undefined;
    dateScore?: Date | undefined;
    status?: string | undefined;
    comment?: string | undefined;
    evaluationCodes?: string | undefined;
    listEvaluationCode?: EvaluationCodeDto[] | undefined;

    constructor(data?: IDetailAcademicResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.session = _data["session"];
            this.classId = _data["classId"];
            this.score = _data["score"];
            this.teacherScoreName = _data["teacherScoreName"];
            this.dateScore = _data["dateScore"] ? new Date(_data["dateScore"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.evaluationCodes = _data["evaluationCodes"];
            if (Array.isArray(_data["listEvaluationCode"])) {
                this.listEvaluationCode = [] as any;
                for (let item of _data["listEvaluationCode"])
                    this.listEvaluationCode!.push(EvaluationCodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DetailAcademicResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailAcademicResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["session"] = this.session;
        data["classId"] = this.classId;
        data["score"] = this.score;
        data["teacherScoreName"] = this.teacherScoreName;
        data["dateScore"] = this.dateScore ? this.dateScore.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["evaluationCodes"] = this.evaluationCodes;
        if (Array.isArray(this.listEvaluationCode)) {
            data["listEvaluationCode"] = [];
            for (let item of this.listEvaluationCode)
                data["listEvaluationCode"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDetailAcademicResultDto {
    session?: number | undefined;
    classId?: string | undefined;
    score?: string | undefined;
    teacherScoreName?: string | undefined;
    dateScore?: Date | undefined;
    status?: string | undefined;
    comment?: string | undefined;
    evaluationCodes?: string | undefined;
    listEvaluationCode?: EvaluationCodeDto[] | undefined;
}

export class StudentAcademicResultDto implements IStudentAcademicResultDto {
    userId?: number | undefined;
    avgScore?: number | undefined;
    numberOfSession?: number | undefined;
    group?: number | undefined;
    hideValue?: string | undefined;
    isTruant?: boolean | undefined;
    classId?: string | undefined;
    academicResults?: string | undefined;
    listAcademicResult?: DetailAcademicResultDto[] | undefined;
    totalSticker?: number | undefined;

    constructor(data?: IStudentAcademicResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.avgScore = _data["avgScore"];
            this.numberOfSession = _data["numberOfSession"];
            this.group = _data["group"];
            this.hideValue = _data["hideValue"];
            this.isTruant = _data["isTruant"];
            this.classId = _data["classId"];
            this.academicResults = _data["academicResults"];
            if (Array.isArray(_data["listAcademicResult"])) {
                this.listAcademicResult = [] as any;
                for (let item of _data["listAcademicResult"])
                    this.listAcademicResult!.push(DetailAcademicResultDto.fromJS(item));
            }
            this.totalSticker = _data["totalSticker"];
        }
    }

    static fromJS(data: any): StudentAcademicResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAcademicResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["avgScore"] = this.avgScore;
        data["numberOfSession"] = this.numberOfSession;
        data["group"] = this.group;
        data["hideValue"] = this.hideValue;
        data["isTruant"] = this.isTruant;
        data["classId"] = this.classId;
        data["academicResults"] = this.academicResults;
        if (Array.isArray(this.listAcademicResult)) {
            data["listAcademicResult"] = [];
            for (let item of this.listAcademicResult)
                data["listAcademicResult"].push(item.toJSON());
        }
        data["totalSticker"] = this.totalSticker;
        return data;
    }
}

export interface IStudentAcademicResultDto {
    userId?: number | undefined;
    avgScore?: number | undefined;
    numberOfSession?: number | undefined;
    group?: number | undefined;
    hideValue?: string | undefined;
    isTruant?: boolean | undefined;
    classId?: string | undefined;
    academicResults?: string | undefined;
    listAcademicResult?: DetailAcademicResultDto[] | undefined;
    totalSticker?: number | undefined;
}

export class DetailLessonClassDto implements IDetailLessonClassDto {
    startDate?: Date;
    classId?: string;
    session?: number;

    constructor(data?: IDetailLessonClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.session = _data["session"];
        }
    }

    static fromJS(data: any): DetailLessonClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailLessonClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["session"] = this.session;
        return data;
    }
}

export interface IDetailLessonClassDto {
    startDate?: Date;
    classId?: string;
    session?: number;
}

export class GroupScoreDto implements IGroupScoreDto {
    classId?: string | undefined;
    groupName?: number | undefined;
    from?: number | undefined;
    to?: number | undefined;

    constructor(data?: IGroupScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.groupName = _data["groupName"];
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): GroupScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["groupName"] = this.groupName;
        data["from"] = this.from;
        data["to"] = this.to;
        return data;
    }
}

export interface IGroupScoreDto {
    classId?: string | undefined;
    groupName?: number | undefined;
    from?: number | undefined;
    to?: number | undefined;
}

export class ClassInfoAcademicDto implements IClassInfoAcademicDto {
    name?: string | undefined;
    code?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    subjectName?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IClassInfoAcademicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.subjectName = _data["subjectName"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClassInfoAcademicDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassInfoAcademicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["subjectName"] = this.subjectName;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IClassInfoAcademicDto {
    name?: string | undefined;
    code?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    subjectName?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class UserInfoDto implements IUserInfoDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    isActive?: boolean;
    type?: string | undefined;
    id?: number;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.familyKeys = _data["familyKeys"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["familyKeys"] = this.familyKeys;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserInfoDto {
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    familyKeys?: string | undefined;
    isActive?: boolean;
    type?: string | undefined;
    id?: number;
}

export class AcademicResultDto implements IAcademicResultDto {
    listStudent?: StudentAcademicResultDto[] | undefined;
    listLession?: DetailLessonClassDto[] | undefined;
    listGroupScore?: GroupScoreDto[] | undefined;
    listClassInfoAcademic?: ClassInfoAcademicDto[] | undefined;
    listUserInfo?: UserInfoDto[] | undefined;
    listUserInfoFamily?: UserInfoDto[] | undefined;
    students?: string | undefined;
    lessons?: string | undefined;
    groupScores?: string | undefined;
    classInfoAcademics?: string | undefined;
    userInfos?: string | undefined;
    userInfoFamilys?: string | undefined;

    constructor(data?: IAcademicResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(StudentAcademicResultDto.fromJS(item));
            }
            if (Array.isArray(_data["listLession"])) {
                this.listLession = [] as any;
                for (let item of _data["listLession"])
                    this.listLession!.push(DetailLessonClassDto.fromJS(item));
            }
            if (Array.isArray(_data["listGroupScore"])) {
                this.listGroupScore = [] as any;
                for (let item of _data["listGroupScore"])
                    this.listGroupScore!.push(GroupScoreDto.fromJS(item));
            }
            if (Array.isArray(_data["listClassInfoAcademic"])) {
                this.listClassInfoAcademic = [] as any;
                for (let item of _data["listClassInfoAcademic"])
                    this.listClassInfoAcademic!.push(ClassInfoAcademicDto.fromJS(item));
            }
            if (Array.isArray(_data["listUserInfo"])) {
                this.listUserInfo = [] as any;
                for (let item of _data["listUserInfo"])
                    this.listUserInfo!.push(UserInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["listUserInfoFamily"])) {
                this.listUserInfoFamily = [] as any;
                for (let item of _data["listUserInfoFamily"])
                    this.listUserInfoFamily!.push(UserInfoDto.fromJS(item));
            }
            this.students = _data["students"];
            this.lessons = _data["lessons"];
            this.groupScores = _data["groupScores"];
            this.classInfoAcademics = _data["classInfoAcademics"];
            this.userInfos = _data["userInfos"];
            this.userInfoFamilys = _data["userInfoFamilys"];
        }
    }

    static fromJS(data: any): AcademicResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        if (Array.isArray(this.listLession)) {
            data["listLession"] = [];
            for (let item of this.listLession)
                data["listLession"].push(item.toJSON());
        }
        if (Array.isArray(this.listGroupScore)) {
            data["listGroupScore"] = [];
            for (let item of this.listGroupScore)
                data["listGroupScore"].push(item.toJSON());
        }
        if (Array.isArray(this.listClassInfoAcademic)) {
            data["listClassInfoAcademic"] = [];
            for (let item of this.listClassInfoAcademic)
                data["listClassInfoAcademic"].push(item.toJSON());
        }
        if (Array.isArray(this.listUserInfo)) {
            data["listUserInfo"] = [];
            for (let item of this.listUserInfo)
                data["listUserInfo"].push(item.toJSON());
        }
        if (Array.isArray(this.listUserInfoFamily)) {
            data["listUserInfoFamily"] = [];
            for (let item of this.listUserInfoFamily)
                data["listUserInfoFamily"].push(item.toJSON());
        }
        data["students"] = this.students;
        data["lessons"] = this.lessons;
        data["groupScores"] = this.groupScores;
        data["classInfoAcademics"] = this.classInfoAcademics;
        data["userInfos"] = this.userInfos;
        data["userInfoFamilys"] = this.userInfoFamilys;
        return data;
    }
}

export interface IAcademicResultDto {
    listStudent?: StudentAcademicResultDto[] | undefined;
    listLession?: DetailLessonClassDto[] | undefined;
    listGroupScore?: GroupScoreDto[] | undefined;
    listClassInfoAcademic?: ClassInfoAcademicDto[] | undefined;
    listUserInfo?: UserInfoDto[] | undefined;
    listUserInfoFamily?: UserInfoDto[] | undefined;
    students?: string | undefined;
    lessons?: string | undefined;
    groupScores?: string | undefined;
    classInfoAcademics?: string | undefined;
    userInfos?: string | undefined;
    userInfoFamilys?: string | undefined;
}

export class GetSMSAcademicResultDto implements IGetSMSAcademicResultDto {
    content?: string | undefined;
    month?: number | undefined;
    courseId?: string;
    listUserId?: number[] | undefined;

    constructor(data?: IGetSMSAcademicResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.month = _data["month"];
            this.courseId = _data["courseId"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
        }
    }

    static fromJS(data: any): GetSMSAcademicResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSMSAcademicResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["month"] = this.month;
        data["courseId"] = this.courseId;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        return data;
    }
}

export interface IGetSMSAcademicResultDto {
    content?: string | undefined;
    month?: number | undefined;
    courseId?: string;
    listUserId?: number[] | undefined;
}

export class SolveExerciseScoreDto implements ISolveExerciseScoreDto {
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    exerciseClassId?: string | undefined;
    questionId?: string | undefined;
    userId?: number | undefined;
    category?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    codeData?: string | undefined;

    constructor(data?: ISolveExerciseScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            this.exerciseClassId = _data["exerciseClassId"];
            this.questionId = _data["questionId"];
            this.userId = _data["userId"];
            this.category = _data["category"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.codeData = _data["codeData"];
        }
    }

    static fromJS(data: any): SolveExerciseScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveExerciseScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        data["exerciseClassId"] = this.exerciseClassId;
        data["questionId"] = this.questionId;
        data["userId"] = this.userId;
        data["category"] = this.category;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["codeData"] = this.codeData;
        return data;
    }
}

export interface ISolveExerciseScoreDto {
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    exerciseClassId?: string | undefined;
    questionId?: string | undefined;
    userId?: number | undefined;
    category?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    codeData?: string | undefined;
}

export class GradeInputDto implements IGradeInputDto {
    positionTeacherId?: string | undefined;
    listSolveExerciseId?: string[] | undefined;
    listSolveExercise?: SolveExerciseScoreDto[] | undefined;
    listLessonClassId?: string[] | undefined;
    listExerciseId?: string[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    gradeTypeId?: string | undefined;
    userId?: number | undefined;
    classId?: string | undefined;
    reasonRegrade?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IGradeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.positionTeacherId = _data["positionTeacherId"];
            if (Array.isArray(_data["listSolveExerciseId"])) {
                this.listSolveExerciseId = [] as any;
                for (let item of _data["listSolveExerciseId"])
                    this.listSolveExerciseId!.push(item);
            }
            if (Array.isArray(_data["listSolveExercise"])) {
                this.listSolveExercise = [] as any;
                for (let item of _data["listSolveExercise"])
                    this.listSolveExercise!.push(SolveExerciseScoreDto.fromJS(item));
            }
            if (Array.isArray(_data["listLessonClassId"])) {
                this.listLessonClassId = [] as any;
                for (let item of _data["listLessonClassId"])
                    this.listLessonClassId!.push(item);
            }
            if (Array.isArray(_data["listExerciseId"])) {
                this.listExerciseId = [] as any;
                for (let item of _data["listExerciseId"])
                    this.listExerciseId!.push(item);
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            this.gradeTypeId = _data["gradeTypeId"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
            this.reasonRegrade = _data["reasonRegrade"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GradeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["positionTeacherId"] = this.positionTeacherId;
        if (Array.isArray(this.listSolveExerciseId)) {
            data["listSolveExerciseId"] = [];
            for (let item of this.listSolveExerciseId)
                data["listSolveExerciseId"].push(item);
        }
        if (Array.isArray(this.listSolveExercise)) {
            data["listSolveExercise"] = [];
            for (let item of this.listSolveExercise)
                data["listSolveExercise"].push(item.toJSON());
        }
        if (Array.isArray(this.listLessonClassId)) {
            data["listLessonClassId"] = [];
            for (let item of this.listLessonClassId)
                data["listLessonClassId"].push(item);
        }
        if (Array.isArray(this.listExerciseId)) {
            data["listExerciseId"] = [];
            for (let item of this.listExerciseId)
                data["listExerciseId"].push(item);
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["score"] = this.score;
        data["comment"] = this.comment;
        data["gradeTypeId"] = this.gradeTypeId;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        data["reasonRegrade"] = this.reasonRegrade;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IGradeInputDto {
    positionTeacherId?: string | undefined;
    listSolveExerciseId?: string[] | undefined;
    listSolveExercise?: SolveExerciseScoreDto[] | undefined;
    listLessonClassId?: string[] | undefined;
    listExerciseId?: string[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    gradeTypeId?: string | undefined;
    userId?: number | undefined;
    classId?: string | undefined;
    reasonRegrade?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GradingPracticeExamInputDto implements IGradingPracticeExamInputDto {
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    studentUserId?: number | undefined;
    classId?: string | undefined;
    teacherUserId?: number | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyStudentAnswerPracticeExam?: string | undefined;
    typeGarding?: string | undefined;
    files?: string | undefined;
    score?: string | undefined;
    time?: number | undefined;
    comment?: string | undefined;

    constructor(data?: IGradingPracticeExamInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.studentUserId = _data["studentUserId"];
            this.classId = _data["classId"];
            this.teacherUserId = _data["teacherUserId"];
            this.keyStudentPracticeExam = _data["keyStudentPracticeExam"];
            this.keyStudentAnswerPracticeExam = _data["keyStudentAnswerPracticeExam"];
            this.typeGarding = _data["typeGarding"];
            this.files = _data["files"];
            this.score = _data["score"];
            this.time = _data["time"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): GradingPracticeExamInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradingPracticeExamInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["studentUserId"] = this.studentUserId;
        data["classId"] = this.classId;
        data["teacherUserId"] = this.teacherUserId;
        data["keyStudentPracticeExam"] = this.keyStudentPracticeExam;
        data["keyStudentAnswerPracticeExam"] = this.keyStudentAnswerPracticeExam;
        data["typeGarding"] = this.typeGarding;
        data["files"] = this.files;
        data["score"] = this.score;
        data["time"] = this.time;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IGradingPracticeExamInputDto {
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    studentUserId?: number | undefined;
    classId?: string | undefined;
    teacherUserId?: number | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyStudentAnswerPracticeExam?: string | undefined;
    typeGarding?: string | undefined;
    files?: string | undefined;
    score?: string | undefined;
    time?: number | undefined;
    comment?: string | undefined;
}

export class GradingPracticeExamOutputDto implements IGradingPracticeExamOutputDto {
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    studentUserId?: number | undefined;
    classId?: string | undefined;
    teacherUserId?: number | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyStudentAnswerPracticeExam?: string | undefined;
    typeGarding?: string | undefined;
    files?: string | undefined;
    score?: string | undefined;
    time?: number | undefined;
    comment?: string | undefined;

    constructor(data?: IGradingPracticeExamOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.studentUserId = _data["studentUserId"];
            this.classId = _data["classId"];
            this.teacherUserId = _data["teacherUserId"];
            this.keyStudentPracticeExam = _data["keyStudentPracticeExam"];
            this.keyStudentAnswerPracticeExam = _data["keyStudentAnswerPracticeExam"];
            this.typeGarding = _data["typeGarding"];
            this.files = _data["files"];
            this.score = _data["score"];
            this.time = _data["time"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): GradingPracticeExamOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradingPracticeExamOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["studentUserId"] = this.studentUserId;
        data["classId"] = this.classId;
        data["teacherUserId"] = this.teacherUserId;
        data["keyStudentPracticeExam"] = this.keyStudentPracticeExam;
        data["keyStudentAnswerPracticeExam"] = this.keyStudentAnswerPracticeExam;
        data["typeGarding"] = this.typeGarding;
        data["files"] = this.files;
        data["score"] = this.score;
        data["time"] = this.time;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IGradingPracticeExamOutputDto {
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    studentUserId?: number | undefined;
    classId?: string | undefined;
    teacherUserId?: number | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyStudentAnswerPracticeExam?: string | undefined;
    typeGarding?: string | undefined;
    files?: string | undefined;
    score?: string | undefined;
    time?: number | undefined;
    comment?: string | undefined;
}

export class GroupClassGuidGetDto implements IGroupClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IGroupClassGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): GroupClassGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupClassGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IGroupClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class GroupClassDto implements IGroupClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    groupKey?: string | undefined;
    session?: number | undefined;
    typeUserId?: string | undefined;
    typeGroup?: string | undefined;
    statusStudentSession?: string | undefined;
    evaluateRegulationss?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IGroupClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.groupKey = _data["groupKey"];
            this.session = _data["session"];
            this.typeUserId = _data["typeUserId"];
            this.typeGroup = _data["typeGroup"];
            this.statusStudentSession = _data["statusStudentSession"];
            this.evaluateRegulationss = _data["evaluateRegulationss"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["groupKey"] = this.groupKey;
        data["session"] = this.session;
        data["typeUserId"] = this.typeUserId;
        data["typeGroup"] = this.typeGroup;
        data["statusStudentSession"] = this.statusStudentSession;
        data["evaluateRegulationss"] = this.evaluateRegulationss;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IGroupClassDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    groupKey?: string | undefined;
    session?: number | undefined;
    typeUserId?: string | undefined;
    typeGroup?: string | undefined;
    statusStudentSession?: string | undefined;
    evaluateRegulationss?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetGroupClassDto implements IGetGroupClassDto {
    option?: string | undefined;
    classId?: string;
    categoryId?: string | undefined;
    userId?: number | undefined;
    typeUser?: string | undefined;
    statusStudentClass?: string | undefined;
    hideValueStudentClass?: string | undefined;

    constructor(data?: IGetGroupClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.option = _data["option"];
            this.classId = _data["classId"];
            this.categoryId = _data["categoryId"];
            this.userId = _data["userId"];
            this.typeUser = _data["typeUser"];
            this.statusStudentClass = _data["statusStudentClass"];
            this.hideValueStudentClass = _data["hideValueStudentClass"];
        }
    }

    static fromJS(data: any): GetGroupClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGroupClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["option"] = this.option;
        data["classId"] = this.classId;
        data["categoryId"] = this.categoryId;
        data["userId"] = this.userId;
        data["typeUser"] = this.typeUser;
        data["statusStudentClass"] = this.statusStudentClass;
        data["hideValueStudentClass"] = this.hideValueStudentClass;
        return data;
    }
}

export interface IGetGroupClassDto {
    option?: string | undefined;
    classId?: string;
    categoryId?: string | undefined;
    userId?: number | undefined;
    typeUser?: string | undefined;
    statusStudentClass?: string | undefined;
    hideValueStudentClass?: string | undefined;
}

export class GroupClass implements IGroupClass {
    classId?: string;
    userId?: number;
    groupKey?: string | undefined;
    session?: number | undefined;
    typeUserId?: string | undefined;
    typeGroup?: string | undefined;
    statusStudentSession?: string | undefined;
    evaluateRegulationss?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    search?: string | undefined;
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    entityId?: string | undefined;
    hideValue?: string | undefined;
    language?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    id?: string;

    constructor(data?: IGroupClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.groupKey = _data["groupKey"];
            this.session = _data["session"];
            this.typeUserId = _data["typeUserId"];
            this.typeGroup = _data["typeGroup"];
            this.statusStudentSession = _data["statusStudentSession"];
            this.evaluateRegulationss = _data["evaluateRegulationss"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.search = _data["search"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.entityId = _data["entityId"];
            this.hideValue = _data["hideValue"];
            this.language = _data["language"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupClass {
        data = typeof data === 'object' ? data : {};
        let result = new GroupClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["groupKey"] = this.groupKey;
        data["session"] = this.session;
        data["typeUserId"] = this.typeUserId;
        data["typeGroup"] = this.typeGroup;
        data["statusStudentSession"] = this.statusStudentSession;
        data["evaluateRegulationss"] = this.evaluateRegulationss;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["search"] = this.search;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["entityId"] = this.entityId;
        data["hideValue"] = this.hideValue;
        data["language"] = this.language;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IGroupClass {
    classId?: string;
    userId?: number;
    groupKey?: string | undefined;
    session?: number | undefined;
    typeUserId?: string | undefined;
    typeGroup?: string | undefined;
    statusStudentSession?: string | undefined;
    evaluateRegulationss?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    search?: string | undefined;
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    entityId?: string | undefined;
    hideValue?: string | undefined;
    language?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    id?: string;
}

export class HealthDeclarationGuidGetDto implements IHealthDeclarationGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IHealthDeclarationGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): HealthDeclarationGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthDeclarationGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IHealthDeclarationGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class HealthDeclarationOutputDto implements IHealthDeclarationOutputDto {
    listClassId?: string[] | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    familyKeys?: string | undefined;
    valueDeclarations?: string | undefined;
    courseId?: string | undefined;
    classIds?: string | undefined;
    userId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: IHealthDeclarationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listClassId"])) {
                this.listClassId = [] as any;
                for (let item of _data["listClassId"])
                    this.listClassId!.push(item);
            }
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.familyKeys = _data["familyKeys"];
            this.valueDeclarations = _data["valueDeclarations"];
            this.courseId = _data["courseId"];
            this.classIds = _data["classIds"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HealthDeclarationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthDeclarationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listClassId)) {
            data["listClassId"] = [];
            for (let item of this.listClassId)
                data["listClassId"].push(item);
        }
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["familyKeys"] = this.familyKeys;
        data["valueDeclarations"] = this.valueDeclarations;
        data["courseId"] = this.courseId;
        data["classIds"] = this.classIds;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IHealthDeclarationOutputDto {
    listClassId?: string[] | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    familyKeys?: string | undefined;
    valueDeclarations?: string | undefined;
    courseId?: string | undefined;
    classIds?: string | undefined;
    userId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class HealthDeclarationInputDto implements IHealthDeclarationInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listClassId?: string[] | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    familyKeys?: string | undefined;
    valueDeclarations?: string | undefined;
    courseId?: string | undefined;
    classIds?: string | undefined;
    userId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IHealthDeclarationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listClassId"])) {
                this.listClassId = [] as any;
                for (let item of _data["listClassId"])
                    this.listClassId!.push(item);
            }
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.familyKeys = _data["familyKeys"];
            this.valueDeclarations = _data["valueDeclarations"];
            this.courseId = _data["courseId"];
            this.classIds = _data["classIds"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HealthDeclarationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthDeclarationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listClassId)) {
            data["listClassId"] = [];
            for (let item of this.listClassId)
                data["listClassId"].push(item);
        }
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["familyKeys"] = this.familyKeys;
        data["valueDeclarations"] = this.valueDeclarations;
        data["courseId"] = this.courseId;
        data["classIds"] = this.classIds;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IHealthDeclarationInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listClassId?: string[] | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    familyKeys?: string | undefined;
    valueDeclarations?: string | undefined;
    courseId?: string | undefined;
    classIds?: string | undefined;
    userId?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class RoleCourseOutputDto implements IRoleCourseOutputDto {
    userId?: number | undefined;
    listClass?: ClassOutputDto[] | undefined;
    name?: string | undefined;
    code?: string | undefined;
    startDay?: Date | undefined;
    endDay?: Date | undefined;
    id?: string;

    constructor(data?: IRoleCourseOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(ClassOutputDto.fromJS(item));
            }
            this.name = _data["name"];
            this.code = _data["code"];
            this.startDay = _data["startDay"] ? new Date(_data["startDay"].toString()) : <any>undefined;
            this.endDay = _data["endDay"] ? new Date(_data["endDay"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleCourseOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleCourseOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["code"] = this.code;
        data["startDay"] = this.startDay ? this.startDay.toISOString() : <any>undefined;
        data["endDay"] = this.endDay ? this.endDay.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleCourseOutputDto {
    userId?: number | undefined;
    listClass?: ClassOutputDto[] | undefined;
    name?: string | undefined;
    code?: string | undefined;
    startDay?: Date | undefined;
    endDay?: Date | undefined;
    id?: string;
}

export class LessonGuidGetDto implements ILessonGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ILessonGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): LessonGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ILessonGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class LessonOutputDto implements ILessonOutputDto {
    listExercise?: ExerciseOutputDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;
    content?: string | undefined;
    subjectId?: string;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ILessonOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listExercise"])) {
                this.listExercise = [] as any;
                for (let item of _data["listExercise"])
                    this.listExercise!.push(ExerciseOutputDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.content = _data["content"];
            this.subjectId = _data["subjectId"];
            this.index = _data["index"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LessonOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listExercise)) {
            data["listExercise"] = [];
            for (let item of this.listExercise)
                data["listExercise"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["content"] = this.content;
        data["subjectId"] = this.subjectId;
        data["index"] = this.index;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ILessonOutputDto {
    listExercise?: ExerciseOutputDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;
    content?: string | undefined;
    subjectId?: string;
    index?: number;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class LessonClassGuidGetDto implements ILessonClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ILessonClassGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): LessonClassGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonClassGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ILessonClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class LessonClassDto implements ILessonClassDto {
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    lessonId?: string;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ILessonClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.lessonId = _data["lessonId"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LessonClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["lessonId"] = this.lessonId;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ILessonClassDto {
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    lessonId?: string;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class SessionClassOutputDto implements ISessionClassOutputDto {
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    className?: string | undefined;
    listLessonClass?: LessonClassDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ISessionClassOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.className = _data["className"];
            if (Array.isArray(_data["listLessonClass"])) {
                this.listLessonClass = [] as any;
                for (let item of _data["listLessonClass"])
                    this.listLessonClass!.push(LessonClassDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SessionClassOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionClassOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["className"] = this.className;
        if (Array.isArray(this.listLessonClass)) {
            data["listLessonClass"] = [];
            for (let item of this.listLessonClass)
                data["listLessonClass"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ISessionClassOutputDto {
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    className?: string | undefined;
    listLessonClass?: LessonClassDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class GetCodeEduCategoryDto implements IGetCodeEduCategoryDto {
    listLessonClassId?: string[] | undefined;

    constructor(data?: IGetCodeEduCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listLessonClassId"])) {
                this.listLessonClassId = [] as any;
                for (let item of _data["listLessonClassId"])
                    this.listLessonClassId!.push(item);
            }
        }
    }

    static fromJS(data: any): GetCodeEduCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCodeEduCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listLessonClassId)) {
            data["listLessonClassId"] = [];
            for (let item of this.listLessonClassId)
                data["listLessonClassId"].push(item);
        }
        return data;
    }
}

export interface IGetCodeEduCategoryDto {
    listLessonClassId?: string[] | undefined;
}

export class DeleteSessionDto implements IDeleteSessionDto {
    classId?: string;
    session?: number | undefined;
    isDeleteGrade?: boolean | undefined;
    id?: string;

    constructor(data?: IDeleteSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.session = _data["session"];
            this.isDeleteGrade = _data["isDeleteGrade"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["session"] = this.session;
        data["isDeleteGrade"] = this.isDeleteGrade;
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteSessionDto {
    classId?: string;
    session?: number | undefined;
    isDeleteGrade?: boolean | undefined;
    id?: string;
}

export class LessonByTeacherDto implements ILessonByTeacherDto {
    listExercise?: ExerciseClassDto[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    lessonId?: string;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ILessonByTeacherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listExercise"])) {
                this.listExercise = [] as any;
                for (let item of _data["listExercise"])
                    this.listExercise!.push(ExerciseClassDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.lessonId = _data["lessonId"];
            this.typeModuleId = _data["typeModuleId"];
            this.teacherId = _data["teacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LessonByTeacherDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonByTeacherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listExercise)) {
            data["listExercise"] = [];
            for (let item of this.listExercise)
                data["listExercise"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["lessonId"] = this.lessonId;
        data["typeModuleId"] = this.typeModuleId;
        data["teacherId"] = this.teacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ILessonByTeacherDto {
    listExercise?: ExerciseClassDto[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    classId?: string | undefined;
    lessonId?: string;
    typeModuleId?: string | undefined;
    teacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class SetLessonDto implements ISetLessonDto {
    listId?: string[] | undefined;
    classId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    bool3?: boolean | undefined;
    bool2?: boolean | undefined;
    bool1?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    number1?: number;
    status?: string | undefined;
    value1?: string | undefined;
    isDeleteGrade?: boolean | undefined;

    constructor(data?: ISetLessonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listId"])) {
                this.listId = [] as any;
                for (let item of _data["listId"])
                    this.listId!.push(item);
            }
            this.classId = _data["classId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.bool3 = _data["bool3"];
            this.bool2 = _data["bool2"];
            this.bool1 = _data["bool1"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.number1 = _data["number1"];
            this.status = _data["status"];
            this.value1 = _data["value1"];
            this.isDeleteGrade = _data["isDeleteGrade"];
        }
    }

    static fromJS(data: any): SetLessonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetLessonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listId)) {
            data["listId"] = [];
            for (let item of this.listId)
                data["listId"].push(item);
        }
        data["classId"] = this.classId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["bool3"] = this.bool3;
        data["bool2"] = this.bool2;
        data["bool1"] = this.bool1;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["number1"] = this.number1;
        data["status"] = this.status;
        data["value1"] = this.value1;
        data["isDeleteGrade"] = this.isDeleteGrade;
        return data;
    }
}

export interface ISetLessonDto {
    listId?: string[] | undefined;
    classId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    bool3?: boolean | undefined;
    bool2?: boolean | undefined;
    bool1?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    number1?: number;
    status?: string | undefined;
    value1?: string | undefined;
    isDeleteGrade?: boolean | undefined;
}

export class InfoDetailUserDto implements IInfoDetailUserDto {
    userName?: string | undefined;
    emailAddress?: string | undefined;
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    fullName?: string | undefined;
    orgId?: string | undefined;
    orgName?: string | undefined;

    constructor(data?: IInfoDetailUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.fullName = _data["fullName"];
            this.orgId = _data["orgId"];
            this.orgName = _data["orgName"];
        }
    }

    static fromJS(data: any): InfoDetailUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoDetailUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["orgId"] = this.orgId;
        data["orgName"] = this.orgName;
        return data;
    }
}

export interface IInfoDetailUserDto {
    userName?: string | undefined;
    emailAddress?: string | undefined;
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    fullName?: string | undefined;
    orgId?: string | undefined;
    orgName?: string | undefined;
}

export class SetFileLessonsDto implements ISetFileLessonsDto {
    listId?: string[] | undefined;
    classId?: string | undefined;
    number1?: number;
    action?: string | undefined;
    comment?: string | undefined;
    settingName?: string | undefined;
    date?: Date | undefined;
    currentUser?: InfoDetailUserDto;
    listFile?: FileEduDto[] | undefined;

    constructor(data?: ISetFileLessonsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listId"])) {
                this.listId = [] as any;
                for (let item of _data["listId"])
                    this.listId!.push(item);
            }
            this.classId = _data["classId"];
            this.number1 = _data["number1"];
            this.action = _data["action"];
            this.comment = _data["comment"];
            this.settingName = _data["settingName"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.currentUser = _data["currentUser"] ? InfoDetailUserDto.fromJS(_data["currentUser"]) : <any>undefined;
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetFileLessonsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetFileLessonsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listId)) {
            data["listId"] = [];
            for (let item of this.listId)
                data["listId"].push(item);
        }
        data["classId"] = this.classId;
        data["number1"] = this.number1;
        data["action"] = this.action;
        data["comment"] = this.comment;
        data["settingName"] = this.settingName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISetFileLessonsDto {
    listId?: string[] | undefined;
    classId?: string | undefined;
    number1?: number;
    action?: string | undefined;
    comment?: string | undefined;
    settingName?: string | undefined;
    date?: Date | undefined;
    currentUser?: InfoDetailUserDto;
    listFile?: FileEduDto[] | undefined;
}

export class LichSuHocInputDto implements ILichSuHocInputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    userId?: number | undefined;
    fullName?: string | undefined;
    meetingLink?: string | undefined;
    lopHocId?: string | undefined;
    ghiChu?: string | undefined;
    status?: string | undefined;
    creationTime?: number | undefined;
    creatorUserId?: number | undefined;

    constructor(data?: ILichSuHocInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.meetingLink = _data["meetingLink"];
            this.lopHocId = _data["lopHocId"];
            this.ghiChu = _data["ghiChu"];
            this.status = _data["status"];
            this.creationTime = _data["creationTime"];
            this.creatorUserId = _data["creatorUserId"];
        }
    }

    static fromJS(data: any): LichSuHocInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuHocInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["meetingLink"] = this.meetingLink;
        data["lopHocId"] = this.lopHocId;
        data["ghiChu"] = this.ghiChu;
        data["status"] = this.status;
        data["creationTime"] = this.creationTime;
        data["creatorUserId"] = this.creatorUserId;
        return data;
    }
}

export interface ILichSuHocInputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    userId?: number | undefined;
    fullName?: string | undefined;
    meetingLink?: string | undefined;
    lopHocId?: string | undefined;
    ghiChu?: string | undefined;
    status?: string | undefined;
    creationTime?: number | undefined;
    creatorUserId?: number | undefined;
}

export class LichSuHocOutputDto implements ILichSuHocOutputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    userId?: number | undefined;
    fullName?: string | undefined;
    meetingLink?: string | undefined;
    lopHocId?: string | undefined;
    ghiChu?: string | undefined;
    status?: string | undefined;
    creationTime?: number | undefined;
    creatorUserId?: number | undefined;

    constructor(data?: ILichSuHocOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.meetingLink = _data["meetingLink"];
            this.lopHocId = _data["lopHocId"];
            this.ghiChu = _data["ghiChu"];
            this.status = _data["status"];
            this.creationTime = _data["creationTime"];
            this.creatorUserId = _data["creatorUserId"];
        }
    }

    static fromJS(data: any): LichSuHocOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichSuHocOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["meetingLink"] = this.meetingLink;
        data["lopHocId"] = this.lopHocId;
        data["ghiChu"] = this.ghiChu;
        data["status"] = this.status;
        data["creationTime"] = this.creationTime;
        data["creatorUserId"] = this.creatorUserId;
        return data;
    }
}

export interface ILichSuHocOutputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    userId?: number | undefined;
    fullName?: string | undefined;
    meetingLink?: string | undefined;
    lopHocId?: string | undefined;
    ghiChu?: string | undefined;
    status?: string | undefined;
    creationTime?: number | undefined;
    creatorUserId?: number | undefined;
}

export class LogInputDto implements ILogInputDto {
    userId?: number | undefined;
    value?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    action?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ILogInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.action = _data["action"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LogInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["key"] = this.key;
        data["type"] = this.type;
        data["action"] = this.action;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ILogInputDto {
    userId?: number | undefined;
    value?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    action?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class LogOutputDto implements ILogOutputDto {
    ngayTao?: number;
    userId?: number | undefined;
    value?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    action?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ILogOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayTao = _data["ngayTao"];
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.action = _data["action"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LogOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayTao"] = this.ngayTao;
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["key"] = this.key;
        data["type"] = this.type;
        data["action"] = this.action;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ILogOutputDto {
    ngayTao?: number;
    userId?: number | undefined;
    value?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    action?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class MeetingConversationDto implements IMeetingConversationDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string | undefined;
    senderId?: number | undefined;
    receiverId?: number | undefined;
    meeting?: MeetingDto;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IMeetingConversationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.senderId = _data["senderId"];
            this.receiverId = _data["receiverId"];
            this.meeting = _data["meeting"] ? MeetingDto.fromJS(_data["meeting"]) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MeetingConversationDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingConversationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["senderId"] = this.senderId;
        data["receiverId"] = this.receiverId;
        data["meeting"] = this.meeting ? this.meeting.toJSON() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IMeetingConversationDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string | undefined;
    senderId?: number | undefined;
    receiverId?: number | undefined;
    meeting?: MeetingDto;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class RelationNotificationDto implements IRelationNotificationDto {
    notificationName?: string | undefined;
    tenantId?: number | undefined;
    tenantName?: string | undefined;
    tenancyName?: string | undefined;
    listUserId?: number[] | undefined;
    userFullName?: string | undefined;
    creatorUserId?: number | undefined;
    creatorUserFullName?: string | undefined;
    entityId?: any | undefined;
    tableName?: string | undefined;
    action?: string | undefined;
    message?: string | undefined;
    tag?: string | undefined;
    readonly type?: string | undefined;
    properties?: { [key: string]: any; } | undefined;

    constructor(data?: IRelationNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationName = _data["notificationName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.tenancyName = _data["tenancyName"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
            this.userFullName = _data["userFullName"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserFullName = _data["creatorUserFullName"];
            this.entityId = _data["entityId"];
            this.tableName = _data["tableName"];
            this.action = _data["action"];
            this.message = _data["message"];
            this.tag = _data["tag"];
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): RelationNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelationNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationName"] = this.notificationName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["tenancyName"] = this.tenancyName;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        data["userFullName"] = this.userFullName;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserFullName"] = this.creatorUserFullName;
        data["entityId"] = this.entityId;
        data["tableName"] = this.tableName;
        data["action"] = this.action;
        data["message"] = this.message;
        data["tag"] = this.tag;
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface IRelationNotificationDto {
    notificationName?: string | undefined;
    tenantId?: number | undefined;
    tenantName?: string | undefined;
    tenancyName?: string | undefined;
    listUserId?: number[] | undefined;
    userFullName?: string | undefined;
    creatorUserId?: number | undefined;
    creatorUserFullName?: string | undefined;
    entityId?: any | undefined;
    tableName?: string | undefined;
    action?: string | undefined;
    message?: string | undefined;
    tag?: string | undefined;
    type?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export class QuestionGuidGetDto implements IQuestionGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IQuestionGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): QuestionGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IQuestionGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class RegisterStudentDto implements IRegisterStudentDto {
    group?: string | undefined;
    groupId?: string | undefined;
    id?: number | undefined;
    userName!: string;
    emailAddress?: string | undefined;
    name!: string;
    surname!: string;
    password?: string | undefined;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    familyKeys?: string | undefined;
    defaultFamily?: string | undefined;
    tenantId?: number | undefined;
    classId?: string | undefined;
    typeStudent?: string | undefined;
    customerGroupId?: string | undefined;
    noteCustomer?: string | undefined;
    codeData?: string | undefined;

    constructor(data?: IRegisterStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.groupId = _data["groupId"];
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.password = _data["password"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.phoneNumber = _data["phoneNumber"];
            this.type = _data["type"];
            this.familyKeys = _data["familyKeys"];
            this.defaultFamily = _data["defaultFamily"];
            this.tenantId = _data["tenantId"];
            this.classId = _data["classId"];
            this.typeStudent = _data["typeStudent"];
            this.customerGroupId = _data["customerGroupId"];
            this.noteCustomer = _data["noteCustomer"];
            this.codeData = _data["codeData"];
        }
    }

    static fromJS(data: any): RegisterStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["groupId"] = this.groupId;
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["phoneNumber"] = this.phoneNumber;
        data["type"] = this.type;
        data["familyKeys"] = this.familyKeys;
        data["defaultFamily"] = this.defaultFamily;
        data["tenantId"] = this.tenantId;
        data["classId"] = this.classId;
        data["typeStudent"] = this.typeStudent;
        data["customerGroupId"] = this.customerGroupId;
        data["noteCustomer"] = this.noteCustomer;
        data["codeData"] = this.codeData;
        return data;
    }
}

export interface IRegisterStudentDto {
    group?: string | undefined;
    groupId?: string | undefined;
    id?: number | undefined;
    userName: string;
    emailAddress?: string | undefined;
    name: string;
    surname: string;
    password?: string | undefined;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    familyKeys?: string | undefined;
    defaultFamily?: string | undefined;
    tenantId?: number | undefined;
    classId?: string | undefined;
    typeStudent?: string | undefined;
    customerGroupId?: string | undefined;
    noteCustomer?: string | undefined;
    codeData?: string | undefined;
}

export class RegisterUserDto implements IRegisterUserDto {
    id?: number | undefined;
    userName!: string;
    emailAddress?: string | undefined;
    name!: string;
    surname!: string;
    password?: string | undefined;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    familyKeys?: string | undefined;
    defaultFamily?: string | undefined;
    tenantId?: number | undefined;
    classId?: string | undefined;
    typeStudent?: string | undefined;
    customerGroupId?: string | undefined;
    noteCustomer?: string | undefined;
    codeData?: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.password = _data["password"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.phoneNumber = _data["phoneNumber"];
            this.type = _data["type"];
            this.familyKeys = _data["familyKeys"];
            this.defaultFamily = _data["defaultFamily"];
            this.tenantId = _data["tenantId"];
            this.classId = _data["classId"];
            this.typeStudent = _data["typeStudent"];
            this.customerGroupId = _data["customerGroupId"];
            this.noteCustomer = _data["noteCustomer"];
            this.codeData = _data["codeData"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["phoneNumber"] = this.phoneNumber;
        data["type"] = this.type;
        data["familyKeys"] = this.familyKeys;
        data["defaultFamily"] = this.defaultFamily;
        data["tenantId"] = this.tenantId;
        data["classId"] = this.classId;
        data["typeStudent"] = this.typeStudent;
        data["customerGroupId"] = this.customerGroupId;
        data["noteCustomer"] = this.noteCustomer;
        data["codeData"] = this.codeData;
        return data;
    }
}

export interface IRegisterUserDto {
    id?: number | undefined;
    userName: string;
    emailAddress?: string | undefined;
    name: string;
    surname: string;
    password?: string | undefined;
    isEmailConfirmed?: boolean;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    familyKeys?: string | undefined;
    defaultFamily?: string | undefined;
    tenantId?: number | undefined;
    classId?: string | undefined;
    typeStudent?: string | undefined;
    customerGroupId?: string | undefined;
    noteCustomer?: string | undefined;
    codeData?: string | undefined;
}

export class StudentInputDto implements IStudentInputDto {
    group?: string | undefined;
    groupId?: string | undefined;
    tenantId?: number | undefined;
    listStudent?: RegisterUserDto[] | undefined;
    listParent?: RegisterUserDto[] | undefined;

    constructor(data?: IStudentInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.groupId = _data["groupId"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(RegisterUserDto.fromJS(item));
            }
            if (Array.isArray(_data["listParent"])) {
                this.listParent = [] as any;
                for (let item of _data["listParent"])
                    this.listParent!.push(RegisterUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["groupId"] = this.groupId;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        if (Array.isArray(this.listParent)) {
            data["listParent"] = [];
            for (let item of this.listParent)
                data["listParent"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentInputDto {
    group?: string | undefined;
    groupId?: string | undefined;
    tenantId?: number | undefined;
    listStudent?: RegisterUserDto[] | undefined;
    listParent?: RegisterUserDto[] | undefined;
}

export class InfoNameDto implements IInfoNameDto {
    name?: string | undefined;
    surname?: string | undefined;
    middlename?: string | undefined;

    constructor(data?: IInfoNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.middlename = _data["middlename"];
        }
    }

    static fromJS(data: any): InfoNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["middlename"] = this.middlename;
        return data;
    }
}

export interface IInfoNameDto {
    name?: string | undefined;
    surname?: string | undefined;
    middlename?: string | undefined;
}

export class InfoLearnDto implements IInfoLearnDto {
    yearOfBirth?: string | undefined;
    objectType?: string | undefined;

    constructor(data?: IInfoLearnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearOfBirth = _data["yearOfBirth"];
            this.objectType = _data["objectType"];
        }
    }

    static fromJS(data: any): InfoLearnDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoLearnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearOfBirth"] = this.yearOfBirth;
        data["objectType"] = this.objectType;
        return data;
    }
}

export interface IInfoLearnDto {
    yearOfBirth?: string | undefined;
    objectType?: string | undefined;
}

export class InfoContactDto implements IInfoContactDto {
    userId?: number | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    isHasAcount?: boolean | undefined;

    constructor(data?: IInfoContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.type = _data["type"];
            this.isHasAcount = _data["isHasAcount"];
        }
    }

    static fromJS(data: any): InfoContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["type"] = this.type;
        data["isHasAcount"] = this.isHasAcount;
        return data;
    }
}

export interface IInfoContactDto {
    userId?: number | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    type?: string | undefined;
    isHasAcount?: boolean | undefined;
}

export class InfoScoreDto implements IInfoScoreDto {
    subjectId?: string | undefined;
    score?: string | undefined;
    note?: string | undefined;

    constructor(data?: IInfoScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectId = _data["subjectId"];
            this.score = _data["score"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): InfoScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new InfoScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectId"] = this.subjectId;
        data["score"] = this.score;
        data["note"] = this.note;
        return data;
    }
}

export interface IInfoScoreDto {
    subjectId?: string | undefined;
    score?: string | undefined;
    note?: string | undefined;
}

export class RegisterInfoStudentDto implements IRegisterInfoStudentDto {
    nameStudent?: InfoNameDto;
    infoLearn?: InfoLearnDto;
    listContact?: InfoContactDto[] | undefined;
    listScore?: InfoScoreDto[] | undefined;
    userId?: number;
    group?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IRegisterInfoStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameStudent = _data["nameStudent"] ? InfoNameDto.fromJS(_data["nameStudent"]) : <any>undefined;
            this.infoLearn = _data["infoLearn"] ? InfoLearnDto.fromJS(_data["infoLearn"]) : <any>undefined;
            if (Array.isArray(_data["listContact"])) {
                this.listContact = [] as any;
                for (let item of _data["listContact"])
                    this.listContact!.push(InfoContactDto.fromJS(item));
            }
            if (Array.isArray(_data["listScore"])) {
                this.listScore = [] as any;
                for (let item of _data["listScore"])
                    this.listScore!.push(InfoScoreDto.fromJS(item));
            }
            this.userId = _data["userId"];
            this.group = _data["group"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RegisterInfoStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInfoStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameStudent"] = this.nameStudent ? this.nameStudent.toJSON() : <any>undefined;
        data["infoLearn"] = this.infoLearn ? this.infoLearn.toJSON() : <any>undefined;
        if (Array.isArray(this.listContact)) {
            data["listContact"] = [];
            for (let item of this.listContact)
                data["listContact"].push(item.toJSON());
        }
        if (Array.isArray(this.listScore)) {
            data["listScore"] = [];
            for (let item of this.listScore)
                data["listScore"].push(item.toJSON());
        }
        data["userId"] = this.userId;
        data["group"] = this.group;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IRegisterInfoStudentDto {
    nameStudent?: InfoNameDto;
    infoLearn?: InfoLearnDto;
    listContact?: InfoContactDto[] | undefined;
    listScore?: InfoScoreDto[] | undefined;
    userId?: number;
    group?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ListRegisterAccountDto implements IListRegisterAccountDto {
    userId?: number[] | undefined;
    group?: string | undefined;
    value1?: string | undefined;

    constructor(data?: IListRegisterAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userId"])) {
                this.userId = [] as any;
                for (let item of _data["userId"])
                    this.userId!.push(item);
            }
            this.group = _data["group"];
            this.value1 = _data["value1"];
        }
    }

    static fromJS(data: any): ListRegisterAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListRegisterAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userId)) {
            data["userId"] = [];
            for (let item of this.userId)
                data["userId"].push(item);
        }
        data["group"] = this.group;
        data["value1"] = this.value1;
        return data;
    }
}

export interface IListRegisterAccountDto {
    userId?: number[] | undefined;
    group?: string | undefined;
    value1?: string | undefined;
}

export class StudentReviewDto implements IStudentReviewDto {
    reviewSessionGradeId?: string | undefined;
    studentReviewId?: string | undefined;
    userId?: number | undefined;
    score?: string | undefined;
    teacherScoreId?: number | undefined;
    state?: string | undefined;
    reasonRegrade?: string | undefined;
    comment?: string | undefined;
    flag?: string | undefined;
    teacherTakePhotoId?: number | undefined;
    listFile?: FileEduDto[] | undefined;

    constructor(data?: IStudentReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewSessionGradeId = _data["reviewSessionGradeId"];
            this.studentReviewId = _data["studentReviewId"];
            this.userId = _data["userId"];
            this.score = _data["score"];
            this.teacherScoreId = _data["teacherScoreId"];
            this.state = _data["state"];
            this.reasonRegrade = _data["reasonRegrade"];
            this.comment = _data["comment"];
            this.flag = _data["flag"];
            this.teacherTakePhotoId = _data["teacherTakePhotoId"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewSessionGradeId"] = this.reviewSessionGradeId;
        data["studentReviewId"] = this.studentReviewId;
        data["userId"] = this.userId;
        data["score"] = this.score;
        data["teacherScoreId"] = this.teacherScoreId;
        data["state"] = this.state;
        data["reasonRegrade"] = this.reasonRegrade;
        data["comment"] = this.comment;
        data["flag"] = this.flag;
        data["teacherTakePhotoId"] = this.teacherTakePhotoId;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentReviewDto {
    reviewSessionGradeId?: string | undefined;
    studentReviewId?: string | undefined;
    userId?: number | undefined;
    score?: string | undefined;
    teacherScoreId?: number | undefined;
    state?: string | undefined;
    reasonRegrade?: string | undefined;
    comment?: string | undefined;
    flag?: string | undefined;
    teacherTakePhotoId?: number | undefined;
    listFile?: FileEduDto[] | undefined;
}

export class ReviewSessionGradeOutputDto implements IReviewSessionGradeOutputDto {
    listContent?: StudentReviewDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    session?: number | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    content?: string | undefined;
    reasonRegrade?: string | undefined;
    comment?: string | undefined;
    reviewTeacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IReviewSessionGradeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listContent"])) {
                this.listContent = [] as any;
                for (let item of _data["listContent"])
                    this.listContent!.push(StudentReviewDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.session = _data["session"];
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            this.classId = _data["classId"];
            this.content = _data["content"];
            this.reasonRegrade = _data["reasonRegrade"];
            this.comment = _data["comment"];
            this.reviewTeacherId = _data["reviewTeacherId"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReviewSessionGradeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewSessionGradeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listContent)) {
            data["listContent"] = [];
            for (let item of this.listContent)
                data["listContent"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["session"] = this.session;
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        data["classId"] = this.classId;
        data["content"] = this.content;
        data["reasonRegrade"] = this.reasonRegrade;
        data["comment"] = this.comment;
        data["reviewTeacherId"] = this.reviewTeacherId;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IReviewSessionGradeOutputDto {
    listContent?: StudentReviewDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    session?: number | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    content?: string | undefined;
    reasonRegrade?: string | undefined;
    comment?: string | undefined;
    reviewTeacherId?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ReviewSessionGradeGuidGetDto implements IReviewSessionGradeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IReviewSessionGradeGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): ReviewSessionGradeGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewSessionGradeGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IReviewSessionGradeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class ReviewSessionGradeOutputDtoPagedResultDto implements IReviewSessionGradeOutputDtoPagedResultDto {
    totalCount?: number;
    items?: ReviewSessionGradeOutputDto[] | undefined;

    constructor(data?: IReviewSessionGradeOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReviewSessionGradeOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReviewSessionGradeOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewSessionGradeOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReviewSessionGradeOutputDtoPagedResultDto {
    totalCount?: number;
    items?: ReviewSessionGradeOutputDto[] | undefined;
}

export class RandomReviewGradeDto implements IRandomReviewGradeDto {
    numberRandom?: number;
    session?: number | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    listContent?: StudentReviewDto[] | undefined;

    constructor(data?: IRandomReviewGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberRandom = _data["numberRandom"];
            this.session = _data["session"];
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            this.classId = _data["classId"];
            if (Array.isArray(_data["listContent"])) {
                this.listContent = [] as any;
                for (let item of _data["listContent"])
                    this.listContent!.push(StudentReviewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RandomReviewGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RandomReviewGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberRandom"] = this.numberRandom;
        data["session"] = this.session;
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        data["classId"] = this.classId;
        if (Array.isArray(this.listContent)) {
            data["listContent"] = [];
            for (let item of this.listContent)
                data["listContent"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRandomReviewGradeDto {
    numberRandom?: number;
    session?: number | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    classId?: string | undefined;
    listContent?: StudentReviewDto[] | undefined;
}

export class ReviewSessionGradeInputDto implements IReviewSessionGradeInputDto {
    listContent?: StudentReviewDto[] | undefined;
    comment?: string | undefined;
    id?: string;

    constructor(data?: IReviewSessionGradeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listContent"])) {
                this.listContent = [] as any;
                for (let item of _data["listContent"])
                    this.listContent!.push(StudentReviewDto.fromJS(item));
            }
            this.comment = _data["comment"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReviewSessionGradeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewSessionGradeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listContent)) {
            data["listContent"] = [];
            for (let item of this.listContent)
                data["listContent"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data;
    }
}

export interface IReviewSessionGradeInputDto {
    listContent?: StudentReviewDto[] | undefined;
    comment?: string | undefined;
    id?: string;
}

export class SchoolScoreDto implements ISchoolScoreDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    userId?: number;
    subjectId?: string | undefined;
    typeSubjectId?: string | undefined;
    objectTypeId?: string | undefined;
    gradeTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    semester?: string | undefined;
    courses?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    type?: string | undefined;
    files?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISchoolScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.userId = _data["userId"];
            this.subjectId = _data["subjectId"];
            this.typeSubjectId = _data["typeSubjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.gradeTypeId = _data["gradeTypeId"];
            this.schoolYearId = _data["schoolYearId"];
            this.semester = _data["semester"];
            this.courses = _data["courses"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            this.type = _data["type"];
            this.files = _data["files"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SchoolScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["userId"] = this.userId;
        data["subjectId"] = this.subjectId;
        data["typeSubjectId"] = this.typeSubjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["gradeTypeId"] = this.gradeTypeId;
        data["schoolYearId"] = this.schoolYearId;
        data["semester"] = this.semester;
        data["courses"] = this.courses;
        data["score"] = this.score;
        data["comment"] = this.comment;
        data["type"] = this.type;
        data["files"] = this.files;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISchoolScoreDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    userId?: number;
    subjectId?: string | undefined;
    typeSubjectId?: string | undefined;
    objectTypeId?: string | undefined;
    gradeTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    semester?: string | undefined;
    courses?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    type?: string | undefined;
    files?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class SchoolScoreGuidGetDto implements ISchoolScoreGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ISchoolScoreGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SchoolScoreGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolScoreGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ISchoolScoreGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class SchoolScoreInputDto implements ISchoolScoreInputDto {
    listCourseId?: string[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    userId?: number;
    subjectId?: string | undefined;
    typeSubjectId?: string | undefined;
    objectTypeId?: string | undefined;
    gradeTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    semester?: string | undefined;
    courses?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    type?: string | undefined;
    files?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISchoolScoreInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listCourseId"])) {
                this.listCourseId = [] as any;
                for (let item of _data["listCourseId"])
                    this.listCourseId!.push(item);
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.userId = _data["userId"];
            this.subjectId = _data["subjectId"];
            this.typeSubjectId = _data["typeSubjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.gradeTypeId = _data["gradeTypeId"];
            this.schoolYearId = _data["schoolYearId"];
            this.semester = _data["semester"];
            this.courses = _data["courses"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            this.type = _data["type"];
            this.files = _data["files"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SchoolScoreInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolScoreInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listCourseId)) {
            data["listCourseId"] = [];
            for (let item of this.listCourseId)
                data["listCourseId"].push(item);
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["userId"] = this.userId;
        data["subjectId"] = this.subjectId;
        data["typeSubjectId"] = this.typeSubjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["gradeTypeId"] = this.gradeTypeId;
        data["schoolYearId"] = this.schoolYearId;
        data["semester"] = this.semester;
        data["courses"] = this.courses;
        data["score"] = this.score;
        data["comment"] = this.comment;
        data["type"] = this.type;
        data["files"] = this.files;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISchoolScoreInputDto {
    listCourseId?: string[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    userId?: number;
    subjectId?: string | undefined;
    typeSubjectId?: string | undefined;
    objectTypeId?: string | undefined;
    gradeTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    semester?: string | undefined;
    courses?: string | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    type?: string | undefined;
    files?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class FileAttachmentDto implements IFileAttachmentDto {
    name?: string | undefined;
    attachment?: string | undefined;

    constructor(data?: IFileAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.attachment = _data["attachment"];
        }
    }

    static fromJS(data: any): FileAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["attachment"] = this.attachment;
        return data;
    }
}

export interface IFileAttachmentDto {
    name?: string | undefined;
    attachment?: string | undefined;
}

export class EmailUseSentDto implements IEmailUseSentDto {
    fullName?: string | undefined;
    emailAddress?: string | undefined;
    userId?: number | undefined;
    listItem?: string[] | undefined;
    listFile?: FileAttachmentDto[] | undefined;

    constructor(data?: IEmailUseSentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.emailAddress = _data["emailAddress"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["listItem"])) {
                this.listItem = [] as any;
                for (let item of _data["listItem"])
                    this.listItem!.push(item);
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailUseSentDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUseSentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["userId"] = this.userId;
        if (Array.isArray(this.listItem)) {
            data["listItem"] = [];
            for (let item of this.listItem)
                data["listItem"].push(item);
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmailUseSentDto {
    fullName?: string | undefined;
    emailAddress?: string | undefined;
    userId?: number | undefined;
    listItem?: string[] | undefined;
    listFile?: FileAttachmentDto[] | undefined;
}

export class SentmailDto implements ISentmailDto {
    content?: string | undefined;
    listEmail?: EmailUseSentDto[] | undefined;

    constructor(data?: ISentmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            if (Array.isArray(_data["listEmail"])) {
                this.listEmail = [] as any;
                for (let item of _data["listEmail"])
                    this.listEmail!.push(EmailUseSentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SentmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SentmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        if (Array.isArray(this.listEmail)) {
            data["listEmail"] = [];
            for (let item of this.listEmail)
                data["listEmail"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISentmailDto {
    content?: string | undefined;
    listEmail?: EmailUseSentDto[] | undefined;
}

export class SettingDto implements ISettingDto {
    userId?: number | undefined;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ISettingDto {
    userId?: number | undefined;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class SettingGuidGetDto implements ISettingGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ISettingGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SettingGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ISettingGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class SolveExerciseGuidGetDto implements ISolveExerciseGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ISolveExerciseGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SolveExerciseGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveExerciseGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ISolveExerciseGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class TeacherScoreDto implements ITeacherScoreDto {
    teacherScoreId?: string | undefined;
    teacherId?: number | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;

    constructor(data?: ITeacherScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherScoreId = _data["teacherScoreId"];
            this.teacherId = _data["teacherId"];
            this.score = _data["score"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherScoreId"] = this.teacherScoreId;
        data["teacherId"] = this.teacherId;
        data["score"] = this.score;
        data["comment"] = this.comment;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeacherScoreDto {
    teacherScoreId?: string | undefined;
    teacherId?: number | undefined;
    score?: string | undefined;
    comment?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
}

export class SolveExerciseOutputDto implements ISolveExerciseOutputDto {
    studentName?: string | undefined;
    listTeacherScore?: TeacherScoreDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    className?: string | undefined;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    exerciseClassId?: string | undefined;
    exerciseId?: string | undefined;
    questionId?: string | undefined;
    userId?: number;
    teacherScores?: string | undefined;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISolveExerciseOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentName = _data["studentName"];
            if (Array.isArray(_data["listTeacherScore"])) {
                this.listTeacherScore = [] as any;
                for (let item of _data["listTeacherScore"])
                    this.listTeacherScore!.push(TeacherScoreDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.className = _data["className"];
            this.courseName = _data["courseName"];
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            this.lessonId = _data["lessonId"];
            this.exerciseClassId = _data["exerciseClassId"];
            this.exerciseId = _data["exerciseId"];
            this.questionId = _data["questionId"];
            this.userId = _data["userId"];
            this.teacherScores = _data["teacherScores"];
            this.content = _data["content"];
            this.value = _data["value"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SolveExerciseOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveExerciseOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        if (Array.isArray(this.listTeacherScore)) {
            data["listTeacherScore"] = [];
            for (let item of this.listTeacherScore)
                data["listTeacherScore"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["className"] = this.className;
        data["courseName"] = this.courseName;
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        data["lessonId"] = this.lessonId;
        data["exerciseClassId"] = this.exerciseClassId;
        data["exerciseId"] = this.exerciseId;
        data["questionId"] = this.questionId;
        data["userId"] = this.userId;
        data["teacherScores"] = this.teacherScores;
        data["content"] = this.content;
        data["value"] = this.value;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISolveExerciseOutputDto {
    studentName?: string | undefined;
    listTeacherScore?: TeacherScoreDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    className?: string | undefined;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    exerciseClassId?: string | undefined;
    exerciseId?: string | undefined;
    questionId?: string | undefined;
    userId?: number;
    teacherScores?: string | undefined;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class SolveExerciseDto implements ISolveExerciseDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    className?: string | undefined;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    exerciseClassId?: string | undefined;
    exerciseId?: string | undefined;
    questionId?: string | undefined;
    userId?: number;
    teacherScores?: string | undefined;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISolveExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.className = _data["className"];
            this.courseName = _data["courseName"];
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            this.lessonId = _data["lessonId"];
            this.exerciseClassId = _data["exerciseClassId"];
            this.exerciseId = _data["exerciseId"];
            this.questionId = _data["questionId"];
            this.userId = _data["userId"];
            this.teacherScores = _data["teacherScores"];
            this.content = _data["content"];
            this.value = _data["value"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SolveExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["className"] = this.className;
        data["courseName"] = this.courseName;
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        data["lessonId"] = this.lessonId;
        data["exerciseClassId"] = this.exerciseClassId;
        data["exerciseId"] = this.exerciseId;
        data["questionId"] = this.questionId;
        data["userId"] = this.userId;
        data["teacherScores"] = this.teacherScores;
        data["content"] = this.content;
        data["value"] = this.value;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISolveExerciseDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    className?: string | undefined;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    exerciseClassId?: string | undefined;
    exerciseId?: string | undefined;
    questionId?: string | undefined;
    userId?: number;
    teacherScores?: string | undefined;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetSolveExerciseStudentPrintDto implements IGetSolveExerciseStudentPrintDto {
    classId?: string;
    userId?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;

    constructor(data?: IGetSolveExerciseStudentPrintDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSolveExerciseStudentPrintDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSolveExerciseStudentPrintDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetSolveExerciseStudentPrintDto {
    classId?: string;
    userId?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
}

export class SolveExerciseInfoOutputDto implements ISolveExerciseInfoOutputDto {
    className?: string | undefined;
    exerciseName?: string | undefined;
    lessonName?: string | undefined;
    studentName?: string | undefined;
    listTeacherScore?: TeacherScoreDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    exerciseClassId?: string | undefined;
    exerciseId?: string | undefined;
    questionId?: string | undefined;
    userId?: number;
    teacherScores?: string | undefined;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISolveExerciseInfoOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.className = _data["className"];
            this.exerciseName = _data["exerciseName"];
            this.lessonName = _data["lessonName"];
            this.studentName = _data["studentName"];
            if (Array.isArray(_data["listTeacherScore"])) {
                this.listTeacherScore = [] as any;
                for (let item of _data["listTeacherScore"])
                    this.listTeacherScore!.push(TeacherScoreDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseName = _data["courseName"];
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            this.lessonId = _data["lessonId"];
            this.exerciseClassId = _data["exerciseClassId"];
            this.exerciseId = _data["exerciseId"];
            this.questionId = _data["questionId"];
            this.userId = _data["userId"];
            this.teacherScores = _data["teacherScores"];
            this.content = _data["content"];
            this.value = _data["value"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SolveExerciseInfoOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveExerciseInfoOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["className"] = this.className;
        data["exerciseName"] = this.exerciseName;
        data["lessonName"] = this.lessonName;
        data["studentName"] = this.studentName;
        if (Array.isArray(this.listTeacherScore)) {
            data["listTeacherScore"] = [];
            for (let item of this.listTeacherScore)
                data["listTeacherScore"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseName"] = this.courseName;
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        data["lessonId"] = this.lessonId;
        data["exerciseClassId"] = this.exerciseClassId;
        data["exerciseId"] = this.exerciseId;
        data["questionId"] = this.questionId;
        data["userId"] = this.userId;
        data["teacherScores"] = this.teacherScores;
        data["content"] = this.content;
        data["value"] = this.value;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISolveExerciseInfoOutputDto {
    className?: string | undefined;
    exerciseName?: string | undefined;
    lessonName?: string | undefined;
    studentName?: string | undefined;
    listTeacherScore?: TeacherScoreDto[] | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    exerciseClassId?: string | undefined;
    exerciseId?: string | undefined;
    questionId?: string | undefined;
    userId?: number;
    teacherScores?: string | undefined;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetFileByGradeDto implements IGetFileByGradeDto {
    classId?: string;
    lessonClassId?: string;
    listUserId?: number[] | undefined;
    category?: string | undefined;

    constructor(data?: IGetFileByGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): GetFileByGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileByGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        data["category"] = this.category;
        return data;
    }
}

export interface IGetFileByGradeDto {
    classId?: string;
    lessonClassId?: string;
    listUserId?: number[] | undefined;
    category?: string | undefined;
}

export class FileByGradeDto implements IFileByGradeDto {
    solveExerciseId?: string | undefined;
    exerciseId?: string | undefined;
    userId?: number | undefined;
    file?: FileEduDto;
    name?: string | undefined;
    creationTime?: Date;
    isMark?: boolean | undefined;

    constructor(data?: IFileByGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.solveExerciseId = _data["solveExerciseId"];
            this.exerciseId = _data["exerciseId"];
            this.userId = _data["userId"];
            this.file = _data["file"] ? FileEduDto.fromJS(_data["file"]) : <any>undefined;
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.isMark = _data["isMark"];
        }
    }

    static fromJS(data: any): FileByGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileByGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["solveExerciseId"] = this.solveExerciseId;
        data["exerciseId"] = this.exerciseId;
        data["userId"] = this.userId;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isMark"] = this.isMark;
        return data;
    }
}

export interface IFileByGradeDto {
    solveExerciseId?: string | undefined;
    exerciseId?: string | undefined;
    userId?: number | undefined;
    file?: FileEduDto;
    name?: string | undefined;
    creationTime?: Date;
    isMark?: boolean | undefined;
}

export class ValueExerciseClassDto implements IValueExerciseClassDto {
    exerciseId?: string;
    content?: string | undefined;
    codeData?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    id?: string;

    constructor(data?: IValueExerciseClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.content = _data["content"];
            this.codeData = _data["codeData"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ValueExerciseClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueExerciseClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["content"] = this.content;
        data["codeData"] = this.codeData;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IValueExerciseClassDto {
    exerciseId?: string;
    content?: string | undefined;
    codeData?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    id?: string;
}

export class SolveLessonDto implements ISolveLessonDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    className?: string | undefined;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    listExerciseClassId?: ValueExerciseClassDto[] | undefined;
    userId?: number;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISolveLessonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.className = _data["className"];
            this.courseName = _data["courseName"];
            this.classId = _data["classId"];
            this.lessonClassId = _data["lessonClassId"];
            this.lessonId = _data["lessonId"];
            if (Array.isArray(_data["listExerciseClassId"])) {
                this.listExerciseClassId = [] as any;
                for (let item of _data["listExerciseClassId"])
                    this.listExerciseClassId!.push(ValueExerciseClassDto.fromJS(item));
            }
            this.userId = _data["userId"];
            this.content = _data["content"];
            this.value = _data["value"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SolveLessonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveLessonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["className"] = this.className;
        data["courseName"] = this.courseName;
        data["classId"] = this.classId;
        data["lessonClassId"] = this.lessonClassId;
        data["lessonId"] = this.lessonId;
        if (Array.isArray(this.listExerciseClassId)) {
            data["listExerciseClassId"] = [];
            for (let item of this.listExerciseClassId)
                data["listExerciseClassId"].push(item.toJSON());
        }
        data["userId"] = this.userId;
        data["content"] = this.content;
        data["value"] = this.value;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISolveLessonDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    className?: string | undefined;
    courseName?: string | undefined;
    classId?: string | undefined;
    lessonClassId?: string | undefined;
    lessonId?: string | undefined;
    listExerciseClassId?: ValueExerciseClassDto[] | undefined;
    userId?: number;
    content?: string | undefined;
    value?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class HitScoreDto implements IHitScoreDto {
    className?: string | undefined;
    courseName?: string | undefined;
    solveExerciseId?: string | undefined;
    teacherScore?: TeacherScoreDto;
    solveExercise?: SolveExerciseScoreDto;

    constructor(data?: IHitScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.className = _data["className"];
            this.courseName = _data["courseName"];
            this.solveExerciseId = _data["solveExerciseId"];
            this.teacherScore = _data["teacherScore"] ? TeacherScoreDto.fromJS(_data["teacherScore"]) : <any>undefined;
            this.solveExercise = _data["solveExercise"] ? SolveExerciseScoreDto.fromJS(_data["solveExercise"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HitScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new HitScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["className"] = this.className;
        data["courseName"] = this.courseName;
        data["solveExerciseId"] = this.solveExerciseId;
        data["teacherScore"] = this.teacherScore ? this.teacherScore.toJSON() : <any>undefined;
        data["solveExercise"] = this.solveExercise ? this.solveExercise.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHitScoreDto {
    className?: string | undefined;
    courseName?: string | undefined;
    solveExerciseId?: string | undefined;
    teacherScore?: TeacherScoreDto;
    solveExercise?: SolveExerciseScoreDto;
}

export class DeleteScoreDto implements IDeleteScoreDto {
    solveExerciseId?: string;
    teacherScoreId?: string;

    constructor(data?: IDeleteScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.solveExerciseId = _data["solveExerciseId"];
            this.teacherScoreId = _data["teacherScoreId"];
        }
    }

    static fromJS(data: any): DeleteScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["solveExerciseId"] = this.solveExerciseId;
        data["teacherScoreId"] = this.teacherScoreId;
        return data;
    }
}

export interface IDeleteScoreDto {
    solveExerciseId?: string;
    teacherScoreId?: string;
}

export class StudentGuidGetDto implements IStudentGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IStudentGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): StudentGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IStudentGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class StudentOutputDto implements IStudentOutputDto {
    userId?: number;
    group?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.group = _data["group"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["group"] = this.group;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentOutputDto {
    userId?: number;
    group?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class StudentOutputDtoPagedResultDto implements IStudentOutputDtoPagedResultDto {
    totalCount?: number;
    items?: StudentOutputDto[] | undefined;

    constructor(data?: IStudentOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StudentOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentOutputDtoPagedResultDto {
    totalCount?: number;
    items?: StudentOutputDto[] | undefined;
}

export class StudentDto implements IStudentDto {
    userId?: number;
    group?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.group = _data["group"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["group"] = this.group;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentDto {
    userId?: number;
    group?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class SubjectScheduleDto implements ISubjectScheduleDto {
    subjectId?: string;
    schedule?: string | undefined;

    constructor(data?: ISubjectScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectId = _data["subjectId"];
            this.schedule = _data["schedule"];
        }
    }

    static fromJS(data: any): SubjectScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectId"] = this.subjectId;
        data["schedule"] = this.schedule;
        return data;
    }
}

export interface ISubjectScheduleDto {
    subjectId?: string;
    schedule?: string | undefined;
}

export class RegisterScheduleDto implements IRegisterScheduleDto {
    userId?: number;
    group?: string | undefined;
    classId?: string | undefined;
    numberClass?: number | undefined;
    listSubjectSchedule?: SubjectScheduleDto[] | undefined;

    constructor(data?: IRegisterScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.group = _data["group"];
            this.classId = _data["classId"];
            this.numberClass = _data["numberClass"];
            if (Array.isArray(_data["listSubjectSchedule"])) {
                this.listSubjectSchedule = [] as any;
                for (let item of _data["listSubjectSchedule"])
                    this.listSubjectSchedule!.push(SubjectScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["group"] = this.group;
        data["classId"] = this.classId;
        data["numberClass"] = this.numberClass;
        if (Array.isArray(this.listSubjectSchedule)) {
            data["listSubjectSchedule"] = [];
            for (let item of this.listSubjectSchedule)
                data["listSubjectSchedule"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegisterScheduleDto {
    userId?: number;
    group?: string | undefined;
    classId?: string | undefined;
    numberClass?: number | undefined;
    listSubjectSchedule?: SubjectScheduleDto[] | undefined;
}

export class StudentAnswerPracticeExamInputDto implements IStudentAnswerPracticeExamInputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyExerciseOrQuestion?: string | undefined;
    answerMultipleChoice?: AnswerQuestionDto[] | undefined;
    answerEssay?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;

    constructor(data?: IStudentAnswerPracticeExamInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
            this.keyStudentPracticeExam = _data["keyStudentPracticeExam"];
            this.keyExerciseOrQuestion = _data["keyExerciseOrQuestion"];
            if (Array.isArray(_data["answerMultipleChoice"])) {
                this.answerMultipleChoice = [] as any;
                for (let item of _data["answerMultipleChoice"])
                    this.answerMultipleChoice!.push(AnswerQuestionDto.fromJS(item));
            }
            this.answerEssay = _data["answerEssay"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.totalScore = _data["totalScore"];
            this.totalTime = _data["totalTime"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentAnswerPracticeExamInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAnswerPracticeExamInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        data["keyStudentPracticeExam"] = this.keyStudentPracticeExam;
        data["keyExerciseOrQuestion"] = this.keyExerciseOrQuestion;
        if (Array.isArray(this.answerMultipleChoice)) {
            data["answerMultipleChoice"] = [];
            for (let item of this.answerMultipleChoice)
                data["answerMultipleChoice"].push(item.toJSON());
        }
        data["answerEssay"] = this.answerEssay;
        data["index"] = this.index;
        data["files"] = this.files;
        data["totalScore"] = this.totalScore;
        data["totalTime"] = this.totalTime;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentAnswerPracticeExamInputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyExerciseOrQuestion?: string | undefined;
    answerMultipleChoice?: AnswerQuestionDto[] | undefined;
    answerEssay?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;
}

export class StudentAnswerPracticeExamOutputDto implements IStudentAnswerPracticeExamOutputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyExerciseOrQuestion?: string | undefined;
    answerMultipleChoice?: AnswerQuestionDto[] | undefined;
    answerEssay?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;

    constructor(data?: IStudentAnswerPracticeExamOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
            this.keyStudentPracticeExam = _data["keyStudentPracticeExam"];
            this.keyExerciseOrQuestion = _data["keyExerciseOrQuestion"];
            if (Array.isArray(_data["answerMultipleChoice"])) {
                this.answerMultipleChoice = [] as any;
                for (let item of _data["answerMultipleChoice"])
                    this.answerMultipleChoice!.push(AnswerQuestionDto.fromJS(item));
            }
            this.answerEssay = _data["answerEssay"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.totalScore = _data["totalScore"];
            this.totalTime = _data["totalTime"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentAnswerPracticeExamOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentAnswerPracticeExamOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        data["keyStudentPracticeExam"] = this.keyStudentPracticeExam;
        data["keyExerciseOrQuestion"] = this.keyExerciseOrQuestion;
        if (Array.isArray(this.answerMultipleChoice)) {
            data["answerMultipleChoice"] = [];
            for (let item of this.answerMultipleChoice)
                data["answerMultipleChoice"].push(item.toJSON());
        }
        data["answerEssay"] = this.answerEssay;
        data["index"] = this.index;
        data["files"] = this.files;
        data["totalScore"] = this.totalScore;
        data["totalTime"] = this.totalTime;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentAnswerPracticeExamOutputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    keyStudentPracticeExam?: string | undefined;
    keyExerciseOrQuestion?: string | undefined;
    answerMultipleChoice?: AnswerQuestionDto[] | undefined;
    answerEssay?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listFile?: FileEduDto[] | undefined;
}

export class StudentClassGuidGetDto implements IStudentClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IStudentClassGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): StudentClassGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClassGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IStudentClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class StudentClassOutputDtoPagedResultDto implements IStudentClassOutputDtoPagedResultDto {
    totalCount?: number;
    items?: StudentClassOutputDto[] | undefined;

    constructor(data?: IStudentClassOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StudentClassOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentClassOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClassOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentClassOutputDtoPagedResultDto {
    totalCount?: number;
    items?: StudentClassOutputDto[] | undefined;
}

export class GetStudentClassDto implements IGetStudentClassDto {
    classId?: string;
    userId?: number;

    constructor(data?: IGetStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): GetStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IGetStudentClassDto {
    classId?: string;
    userId?: number;
}

export class GetStudentNewDto implements IGetStudentNewDto {
    courseId?: string | undefined;
    timeStart?: Date | undefined;
    timeEnd?: Date | undefined;
    typeUser?: string | undefined;

    constructor(data?: IGetStudentNewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.timeStart = _data["timeStart"] ? new Date(_data["timeStart"].toString()) : <any>undefined;
            this.timeEnd = _data["timeEnd"] ? new Date(_data["timeEnd"].toString()) : <any>undefined;
            this.typeUser = _data["typeUser"];
        }
    }

    static fromJS(data: any): GetStudentNewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStudentNewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["timeStart"] = this.timeStart ? this.timeStart.toISOString() : <any>undefined;
        data["timeEnd"] = this.timeEnd ? this.timeEnd.toISOString() : <any>undefined;
        data["typeUser"] = this.typeUser;
        return data;
    }
}

export interface IGetStudentNewDto {
    courseId?: string | undefined;
    timeStart?: Date | undefined;
    timeEnd?: Date | undefined;
    typeUser?: string | undefined;
}

export class RegisterStudentClassDto implements IRegisterStudentClassDto {
    classId?: string;
    status?: string | undefined;
    valueData?: string | undefined;
    listRegisterUser?: RegisterUserDto[] | undefined;

    constructor(data?: IRegisterStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.status = _data["status"];
            this.valueData = _data["valueData"];
            if (Array.isArray(_data["listRegisterUser"])) {
                this.listRegisterUser = [] as any;
                for (let item of _data["listRegisterUser"])
                    this.listRegisterUser!.push(RegisterUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["status"] = this.status;
        data["valueData"] = this.valueData;
        if (Array.isArray(this.listRegisterUser)) {
            data["listRegisterUser"] = [];
            for (let item of this.listRegisterUser)
                data["listRegisterUser"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegisterStudentClassDto {
    classId?: string;
    status?: string | undefined;
    valueData?: string | undefined;
    listRegisterUser?: RegisterUserDto[] | undefined;
}

export class TruantByStudentDto implements ITruantByStudentDto {
    truantId?: string | undefined;
    userId?: number;
    date?: Date | undefined;
    note?: string | undefined;
    newClassId?: string | undefined;
    oldClassId?: string | undefined;

    constructor(data?: ITruantByStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.truantId = _data["truantId"];
            this.userId = _data["userId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.newClassId = _data["newClassId"];
            this.oldClassId = _data["oldClassId"];
        }
    }

    static fromJS(data: any): TruantByStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TruantByStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truantId"] = this.truantId;
        data["userId"] = this.userId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["newClassId"] = this.newClassId;
        data["oldClassId"] = this.oldClassId;
        return data;
    }
}

export interface ITruantByStudentDto {
    truantId?: string | undefined;
    userId?: number;
    date?: Date | undefined;
    note?: string | undefined;
    newClassId?: string | undefined;
    oldClassId?: string | undefined;
}

export class MovedStudentClassDto implements IMovedStudentClassDto {
    newClassId?: string;
    oldClassId?: string;
    listStudent?: TruantByStudentDto[] | undefined;

    constructor(data?: IMovedStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newClassId = _data["newClassId"];
            this.oldClassId = _data["oldClassId"];
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(TruantByStudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MovedStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new MovedStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newClassId"] = this.newClassId;
        data["oldClassId"] = this.oldClassId;
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMovedStudentClassDto {
    newClassId?: string;
    oldClassId?: string;
    listStudent?: TruantByStudentDto[] | undefined;
}

export class DeleteStudentClassDto implements IDeleteStudentClassDto {
    classId?: string;
    userIds?: number[] | undefined;

    constructor(data?: IDeleteStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface IDeleteStudentClassDto {
    classId?: string;
    userIds?: number[] | undefined;
}

export class TuitionStudentClassDto implements ITuitionStudentClassDto {
    classId?: string;
    listStudent?: number[] | undefined;
    codeData?: string | undefined;

    constructor(data?: ITuitionStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(item);
            }
            this.codeData = _data["codeData"];
        }
    }

    static fromJS(data: any): TuitionStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new TuitionStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item);
        }
        data["codeData"] = this.codeData;
        return data;
    }
}

export interface ITuitionStudentClassDto {
    classId?: string;
    listStudent?: number[] | undefined;
    codeData?: string | undefined;
}

export class UpdateTuitionStudentClassDto implements IUpdateTuitionStudentClassDto {
    classId?: string | undefined;
    userId?: number | undefined;
    codeData?: string | undefined;

    constructor(data?: IUpdateTuitionStudentClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.codeData = _data["codeData"];
        }
    }

    static fromJS(data: any): UpdateTuitionStudentClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTuitionStudentClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["codeData"] = this.codeData;
        return data;
    }
}

export interface IUpdateTuitionStudentClassDto {
    classId?: string | undefined;
    userId?: number | undefined;
    codeData?: string | undefined;
}

export class StudentClass implements IStudentClass {
    classId?: string;
    userId?: number;
    isTruant?: boolean | undefined;
    note?: string | undefined;
    ngayTamNghi?: number | undefined;
    typeStudent?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    search?: string | undefined;
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    entityId?: string | undefined;
    hideValue?: string | undefined;
    language?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    id?: string;

    constructor(data?: IStudentClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.isTruant = _data["isTruant"];
            this.note = _data["note"];
            this.ngayTamNghi = _data["ngayTamNghi"];
            this.typeStudent = _data["typeStudent"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.search = _data["search"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.entityId = _data["entityId"];
            this.hideValue = _data["hideValue"];
            this.language = _data["language"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentClass {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["isTruant"] = this.isTruant;
        data["note"] = this.note;
        data["ngayTamNghi"] = this.ngayTamNghi;
        data["typeStudent"] = this.typeStudent;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["search"] = this.search;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["entityId"] = this.entityId;
        data["hideValue"] = this.hideValue;
        data["language"] = this.language;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentClass {
    classId?: string;
    userId?: number;
    isTruant?: boolean | undefined;
    note?: string | undefined;
    ngayTamNghi?: number | undefined;
    typeStudent?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    search?: string | undefined;
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    entityId?: string | undefined;
    hideValue?: string | undefined;
    language?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    id?: string;
}

export class StructureExerciseOrQuestionDto implements IStructureExerciseOrQuestionDto {
    keyExerciseOrQuestion?: string | undefined;
    structure?: string | undefined;
    score?: string | undefined;
    time?: number | undefined;
    exerciseOrQuestion?: ExerciseOrQuestionOutputDto;

    constructor(data?: IStructureExerciseOrQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyExerciseOrQuestion = _data["keyExerciseOrQuestion"];
            this.structure = _data["structure"];
            this.score = _data["score"];
            this.time = _data["time"];
            this.exerciseOrQuestion = _data["exerciseOrQuestion"] ? ExerciseOrQuestionOutputDto.fromJS(_data["exerciseOrQuestion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StructureExerciseOrQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new StructureExerciseOrQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyExerciseOrQuestion"] = this.keyExerciseOrQuestion;
        data["structure"] = this.structure;
        data["score"] = this.score;
        data["time"] = this.time;
        data["exerciseOrQuestion"] = this.exerciseOrQuestion ? this.exerciseOrQuestion.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStructureExerciseOrQuestionDto {
    keyExerciseOrQuestion?: string | undefined;
    structure?: string | undefined;
    score?: string | undefined;
    time?: number | undefined;
    exerciseOrQuestion?: ExerciseOrQuestionOutputDto;
}

export class StudentPracticeExamInputDto implements IStudentPracticeExamInputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    isConducts?: boolean | undefined;
    isSuggest?: boolean | undefined;
    isLearnTheTopic?: boolean | undefined;
    isAnswers?: boolean | undefined;
    structure?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listStructureExerciseOrQuestion?: StructureExerciseOrQuestionDto[] | undefined;

    constructor(data?: IStudentPracticeExamInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
            this.isConducts = _data["isConducts"];
            this.isSuggest = _data["isSuggest"];
            this.isLearnTheTopic = _data["isLearnTheTopic"];
            this.isAnswers = _data["isAnswers"];
            this.structure = _data["structure"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.totalScore = _data["totalScore"];
            this.totalTime = _data["totalTime"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listStructureExerciseOrQuestion"])) {
                this.listStructureExerciseOrQuestion = [] as any;
                for (let item of _data["listStructureExerciseOrQuestion"])
                    this.listStructureExerciseOrQuestion!.push(StructureExerciseOrQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentPracticeExamInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentPracticeExamInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        data["isConducts"] = this.isConducts;
        data["isSuggest"] = this.isSuggest;
        data["isLearnTheTopic"] = this.isLearnTheTopic;
        data["isAnswers"] = this.isAnswers;
        data["structure"] = this.structure;
        data["index"] = this.index;
        data["files"] = this.files;
        data["totalScore"] = this.totalScore;
        data["totalTime"] = this.totalTime;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listStructureExerciseOrQuestion)) {
            data["listStructureExerciseOrQuestion"] = [];
            for (let item of this.listStructureExerciseOrQuestion)
                data["listStructureExerciseOrQuestion"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentPracticeExamInputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    isConducts?: boolean | undefined;
    isSuggest?: boolean | undefined;
    isLearnTheTopic?: boolean | undefined;
    isAnswers?: boolean | undefined;
    structure?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listStructureExerciseOrQuestion?: StructureExerciseOrQuestionDto[] | undefined;
}

export class StudentPracticeExamOutputDto implements IStudentPracticeExamOutputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    isConducts?: boolean | undefined;
    isSuggest?: boolean | undefined;
    isLearnTheTopic?: boolean | undefined;
    isAnswers?: boolean | undefined;
    structure?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listStructureExerciseOrQuestion?: StructureExerciseOrQuestionDto[] | undefined;

    constructor(data?: IStudentPracticeExamOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"];
            this.userId = _data["userId"];
            this.classId = _data["classId"];
            this.isConducts = _data["isConducts"];
            this.isSuggest = _data["isSuggest"];
            this.isLearnTheTopic = _data["isLearnTheTopic"];
            this.isAnswers = _data["isAnswers"];
            this.structure = _data["structure"];
            this.index = _data["index"];
            this.files = _data["files"];
            this.totalScore = _data["totalScore"];
            this.totalTime = _data["totalTime"];
            if (Array.isArray(_data["listCodeEduCategory"])) {
                this.listCodeEduCategory = [] as any;
                for (let item of _data["listCodeEduCategory"])
                    this.listCodeEduCategory!.push(DetailEduCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["listStructureExerciseOrQuestion"])) {
                this.listStructureExerciseOrQuestion = [] as any;
                for (let item of _data["listStructureExerciseOrQuestion"])
                    this.listStructureExerciseOrQuestion!.push(StructureExerciseOrQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentPracticeExamOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentPracticeExamOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime;
        data["userId"] = this.userId;
        data["classId"] = this.classId;
        data["isConducts"] = this.isConducts;
        data["isSuggest"] = this.isSuggest;
        data["isLearnTheTopic"] = this.isLearnTheTopic;
        data["isAnswers"] = this.isAnswers;
        data["structure"] = this.structure;
        data["index"] = this.index;
        data["files"] = this.files;
        data["totalScore"] = this.totalScore;
        data["totalTime"] = this.totalTime;
        if (Array.isArray(this.listCodeEduCategory)) {
            data["listCodeEduCategory"] = [];
            for (let item of this.listCodeEduCategory)
                data["listCodeEduCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.listStructureExerciseOrQuestion)) {
            data["listStructureExerciseOrQuestion"] = [];
            for (let item of this.listStructureExerciseOrQuestion)
                data["listStructureExerciseOrQuestion"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentPracticeExamOutputDto {
    key?: string | undefined;
    value?: string | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: number;
    userId?: number | undefined;
    classId?: string | undefined;
    isConducts?: boolean | undefined;
    isSuggest?: boolean | undefined;
    isLearnTheTopic?: boolean | undefined;
    isAnswers?: boolean | undefined;
    structure?: string | undefined;
    index?: number | undefined;
    files?: string | undefined;
    totalScore?: string | undefined;
    totalTime?: number | undefined;
    listCodeEduCategory?: DetailEduCategoryDto[] | undefined;
    listStructureExerciseOrQuestion?: StructureExerciseOrQuestionDto[] | undefined;
}

export class StudentStickerOutputDto implements IStudentStickerOutputDto {
    totalSticker?: number | undefined;
    totalMonthSticker?: number | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    sticker?: number;
    comment?: string | undefined;
    files?: string | undefined;
    userId?: number | undefined;
    courseId?: string | undefined;
    classId?: string | undefined;
    session?: number;
    day?: number;
    month?: number;
    year?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentStickerOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSticker = _data["totalSticker"];
            this.totalMonthSticker = _data["totalMonthSticker"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.sticker = _data["sticker"];
            this.comment = _data["comment"];
            this.files = _data["files"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.classId = _data["classId"];
            this.session = _data["session"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentStickerOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentStickerOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSticker"] = this.totalSticker;
        data["totalMonthSticker"] = this.totalMonthSticker;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["sticker"] = this.sticker;
        data["comment"] = this.comment;
        data["files"] = this.files;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["classId"] = this.classId;
        data["session"] = this.session;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentStickerOutputDto {
    totalSticker?: number | undefined;
    totalMonthSticker?: number | undefined;
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    sticker?: number;
    comment?: string | undefined;
    files?: string | undefined;
    userId?: number | undefined;
    courseId?: string | undefined;
    classId?: string | undefined;
    session?: number;
    day?: number;
    month?: number;
    year?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class StudentStickerGuidGetDto implements IStudentStickerGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IStudentStickerGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): StudentStickerGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentStickerGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IStudentStickerGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class StudentStickerInputDto implements IStudentStickerInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    sticker?: number;
    comment?: string | undefined;
    files?: string | undefined;
    userId?: number | undefined;
    courseId?: string | undefined;
    classId?: string | undefined;
    session?: number;
    day?: number;
    month?: number;
    year?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentStickerInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.sticker = _data["sticker"];
            this.comment = _data["comment"];
            this.files = _data["files"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.classId = _data["classId"];
            this.session = _data["session"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentStickerInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentStickerInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["sticker"] = this.sticker;
        data["comment"] = this.comment;
        data["files"] = this.files;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["classId"] = this.classId;
        data["session"] = this.session;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentStickerInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    teacherId?: number | undefined;
    sticker?: number;
    comment?: string | undefined;
    files?: string | undefined;
    userId?: number | undefined;
    courseId?: string | undefined;
    classId?: string | undefined;
    session?: number;
    day?: number;
    month?: number;
    year?: number;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class StudentTuitionFeeGuidGetDto implements IStudentTuitionFeeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: IStudentTuitionFeeGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): StudentTuitionFeeGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentTuitionFeeGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IStudentTuitionFeeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class StudentTuitionFeeDto implements IStudentTuitionFeeDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    studentUserId?: number | undefined;
    subjects?: string | undefined;
    typeId?: string | undefined;
    dateTime?: Date | undefined;
    employeeUserId?: number | undefined;
    tuitions?: string | undefined;
    incurredTuitions?: string | undefined;
    paymentId?: string | undefined;
    refund?: string | undefined;
    total?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: IStudentTuitionFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.studentUserId = _data["studentUserId"];
            this.subjects = _data["subjects"];
            this.typeId = _data["typeId"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.employeeUserId = _data["employeeUserId"];
            this.tuitions = _data["tuitions"];
            this.incurredTuitions = _data["incurredTuitions"];
            this.paymentId = _data["paymentId"];
            this.refund = _data["refund"];
            this.total = _data["total"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StudentTuitionFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentTuitionFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["studentUserId"] = this.studentUserId;
        data["subjects"] = this.subjects;
        data["typeId"] = this.typeId;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["employeeUserId"] = this.employeeUserId;
        data["tuitions"] = this.tuitions;
        data["incurredTuitions"] = this.incurredTuitions;
        data["paymentId"] = this.paymentId;
        data["refund"] = this.refund;
        data["total"] = this.total;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IStudentTuitionFeeDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    studentUserId?: number | undefined;
    subjects?: string | undefined;
    typeId?: string | undefined;
    dateTime?: Date | undefined;
    employeeUserId?: number | undefined;
    tuitions?: string | undefined;
    incurredTuitions?: string | undefined;
    paymentId?: string | undefined;
    refund?: string | undefined;
    total?: number | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class GetTuitionFeeByCourseDto implements IGetTuitionFeeByCourseDto {
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    listUserId?: number[] | undefined;

    constructor(data?: IGetTuitionFeeByCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTuitionFeeByCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTuitionFeeByCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        return data;
    }
}

export interface IGetTuitionFeeByCourseDto {
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    listUserId?: number[] | undefined;
}

export class TuitionDto implements ITuitionDto {
    amount?: number | undefined;
    reason?: string | undefined;
    name?: string | undefined;
    typeTuitionId?: string | undefined;

    constructor(data?: ITuitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.reason = _data["reason"];
            this.name = _data["name"];
            this.typeTuitionId = _data["typeTuitionId"];
        }
    }

    static fromJS(data: any): TuitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TuitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        data["name"] = this.name;
        data["typeTuitionId"] = this.typeTuitionId;
        return data;
    }
}

export interface ITuitionDto {
    amount?: number | undefined;
    reason?: string | undefined;
    name?: string | undefined;
    typeTuitionId?: string | undefined;
}

export class TuitionFeeOutputDto implements ITuitionFeeOutputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listClassId?: string[] | undefined;
    listSubjectId?: string[] | undefined;
    listExemption?: TuitionDto[] | undefined;
    listDocument?: TuitionDto[] | undefined;
    listTuition?: TuitionDto[] | undefined;
    listTotalTuition?: TuitionDto[] | undefined;
    listUnitPrice?: TuitionDto[] | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    discounts?: string | undefined;
    numberSessions?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITuitionFeeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listClassId"])) {
                this.listClassId = [] as any;
                for (let item of _data["listClassId"])
                    this.listClassId!.push(item);
            }
            if (Array.isArray(_data["listSubjectId"])) {
                this.listSubjectId = [] as any;
                for (let item of _data["listSubjectId"])
                    this.listSubjectId!.push(item);
            }
            if (Array.isArray(_data["listExemption"])) {
                this.listExemption = [] as any;
                for (let item of _data["listExemption"])
                    this.listExemption!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listDocument"])) {
                this.listDocument = [] as any;
                for (let item of _data["listDocument"])
                    this.listDocument!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listTuition"])) {
                this.listTuition = [] as any;
                for (let item of _data["listTuition"])
                    this.listTuition!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listTotalTuition"])) {
                this.listTotalTuition = [] as any;
                for (let item of _data["listTotalTuition"])
                    this.listTotalTuition!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listUnitPrice"])) {
                this.listUnitPrice = [] as any;
                for (let item of _data["listUnitPrice"])
                    this.listUnitPrice!.push(TuitionDto.fromJS(item));
            }
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            this.discounts = _data["discounts"];
            this.numberSessions = _data["numberSessions"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TuitionFeeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TuitionFeeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listClassId)) {
            data["listClassId"] = [];
            for (let item of this.listClassId)
                data["listClassId"].push(item);
        }
        if (Array.isArray(this.listSubjectId)) {
            data["listSubjectId"] = [];
            for (let item of this.listSubjectId)
                data["listSubjectId"].push(item);
        }
        if (Array.isArray(this.listExemption)) {
            data["listExemption"] = [];
            for (let item of this.listExemption)
                data["listExemption"].push(item.toJSON());
        }
        if (Array.isArray(this.listDocument)) {
            data["listDocument"] = [];
            for (let item of this.listDocument)
                data["listDocument"].push(item.toJSON());
        }
        if (Array.isArray(this.listTuition)) {
            data["listTuition"] = [];
            for (let item of this.listTuition)
                data["listTuition"].push(item.toJSON());
        }
        if (Array.isArray(this.listTotalTuition)) {
            data["listTotalTuition"] = [];
            for (let item of this.listTotalTuition)
                data["listTotalTuition"].push(item.toJSON());
        }
        if (Array.isArray(this.listUnitPrice)) {
            data["listUnitPrice"] = [];
            for (let item of this.listUnitPrice)
                data["listUnitPrice"].push(item.toJSON());
        }
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        data["discounts"] = this.discounts;
        data["numberSessions"] = this.numberSessions;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITuitionFeeOutputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listClassId?: string[] | undefined;
    listSubjectId?: string[] | undefined;
    listExemption?: TuitionDto[] | undefined;
    listDocument?: TuitionDto[] | undefined;
    listTuition?: TuitionDto[] | undefined;
    listTotalTuition?: TuitionDto[] | undefined;
    listUnitPrice?: TuitionDto[] | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    discounts?: string | undefined;
    numberSessions?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ClassTypeTuitionDto implements IClassTypeTuitionDto {
    classId?: string | undefined;
    classCode?: string | undefined;
    className?: string | undefined;
    typeTuition?: string | undefined;
    subjectId?: string | undefined;

    constructor(data?: IClassTypeTuitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.classCode = _data["classCode"];
            this.className = _data["className"];
            this.typeTuition = _data["typeTuition"];
            this.subjectId = _data["subjectId"];
        }
    }

    static fromJS(data: any): ClassTypeTuitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassTypeTuitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["classCode"] = this.classCode;
        data["className"] = this.className;
        data["typeTuition"] = this.typeTuition;
        data["subjectId"] = this.subjectId;
        return data;
    }
}

export interface IClassTypeTuitionDto {
    classId?: string | undefined;
    classCode?: string | undefined;
    className?: string | undefined;
    typeTuition?: string | undefined;
    subjectId?: string | undefined;
}

export class StudentByCourseDto implements IStudentByCourseDto {
    userId?: number | undefined;
    listClass?: ClassTypeTuitionDto[] | undefined;
    listStudentTuitionFee?: StudentTuitionFeeDto[] | undefined;

    constructor(data?: IStudentByCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["listClass"])) {
                this.listClass = [] as any;
                for (let item of _data["listClass"])
                    this.listClass!.push(ClassTypeTuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listStudentTuitionFee"])) {
                this.listStudentTuitionFee = [] as any;
                for (let item of _data["listStudentTuitionFee"])
                    this.listStudentTuitionFee!.push(StudentTuitionFeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentByCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentByCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.listClass)) {
            data["listClass"] = [];
            for (let item of this.listClass)
                data["listClass"].push(item.toJSON());
        }
        if (Array.isArray(this.listStudentTuitionFee)) {
            data["listStudentTuitionFee"] = [];
            for (let item of this.listStudentTuitionFee)
                data["listStudentTuitionFee"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentByCourseDto {
    userId?: number | undefined;
    listClass?: ClassTypeTuitionDto[] | undefined;
    listStudentTuitionFee?: StudentTuitionFeeDto[] | undefined;
}

export class TuitionFeeByCourseDto implements ITuitionFeeByCourseDto {
    courseId?: string | undefined;
    listTuitionFee?: TuitionFeeOutputDto[] | undefined;
    listStudent?: StudentByCourseDto[] | undefined;

    constructor(data?: ITuitionFeeByCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            if (Array.isArray(_data["listTuitionFee"])) {
                this.listTuitionFee = [] as any;
                for (let item of _data["listTuitionFee"])
                    this.listTuitionFee!.push(TuitionFeeOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listStudent"])) {
                this.listStudent = [] as any;
                for (let item of _data["listStudent"])
                    this.listStudent!.push(StudentByCourseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TuitionFeeByCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TuitionFeeByCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        if (Array.isArray(this.listTuitionFee)) {
            data["listTuitionFee"] = [];
            for (let item of this.listTuitionFee)
                data["listTuitionFee"].push(item.toJSON());
        }
        if (Array.isArray(this.listStudent)) {
            data["listStudent"] = [];
            for (let item of this.listStudent)
                data["listStudent"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITuitionFeeByCourseDto {
    courseId?: string | undefined;
    listTuitionFee?: TuitionFeeOutputDto[] | undefined;
    listStudent?: StudentByCourseDto[] | undefined;
}

export class SubjectGuidGetDto implements ISubjectGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ISubjectGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SubjectGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ISubjectGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class SubjectInputDto implements ISubjectInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    objectTypeId?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISubjectInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.objectTypeId = _data["objectTypeId"];
            this.typeModuleId = _data["typeModuleId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubjectInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["objectTypeId"] = this.objectTypeId;
        data["typeModuleId"] = this.typeModuleId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubjectInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    objectTypeId?: string | undefined;
    typeModuleId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class SurveyListGuidGetDto implements ISurveyListGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ISurveyListGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SurveyListGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyListGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ISurveyListGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class SurveyListOutputDto implements ISurveyListOutputDto {
    files?: string | undefined;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    examId?: string | undefined;
    userId?: number | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    hourStart?: string | undefined;
    hourEnd?: string | undefined;
    dateExam?: Date | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ISurveyListOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.files = _data["files"];
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.schoolYearId = _data["schoolYearId"];
            this.examId = _data["examId"];
            this.userId = _data["userId"];
            this.answers = _data["answers"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.hourStart = _data["hourStart"];
            this.hourEnd = _data["hourEnd"];
            this.dateExam = _data["dateExam"] ? new Date(_data["dateExam"].toString()) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SurveyListOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyListOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["files"] = this.files;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["schoolYearId"] = this.schoolYearId;
        data["examId"] = this.examId;
        data["userId"] = this.userId;
        data["answers"] = this.answers;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["hourStart"] = this.hourStart;
        data["hourEnd"] = this.hourEnd;
        data["dateExam"] = this.dateExam ? this.dateExam.toISOString() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ISurveyListOutputDto {
    files?: string | undefined;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    examId?: string | undefined;
    userId?: number | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    hourStart?: string | undefined;
    hourEnd?: string | undefined;
    dateExam?: Date | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class SurveyListInputDto implements ISurveyListInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    examId?: string | undefined;
    userId?: number | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    hourStart?: string | undefined;
    hourEnd?: string | undefined;
    dateExam?: Date | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ISurveyListInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.schoolYearId = _data["schoolYearId"];
            this.examId = _data["examId"];
            this.userId = _data["userId"];
            this.answers = _data["answers"];
            if (Array.isArray(_data["listFile"])) {
                this.listFile = [] as any;
                for (let item of _data["listFile"])
                    this.listFile!.push(FileEduDto.fromJS(item));
            }
            this.hourStart = _data["hourStart"];
            this.hourEnd = _data["hourEnd"];
            this.dateExam = _data["dateExam"] ? new Date(_data["dateExam"].toString()) : <any>undefined;
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SurveyListInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyListInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["objectTypeId"] = this.objectTypeId;
        data["schoolYearId"] = this.schoolYearId;
        data["examId"] = this.examId;
        data["userId"] = this.userId;
        data["answers"] = this.answers;
        if (Array.isArray(this.listFile)) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        data["hourStart"] = this.hourStart;
        data["hourEnd"] = this.hourEnd;
        data["dateExam"] = this.dateExam ? this.dateExam.toISOString() : <any>undefined;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ISurveyListInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    courseId?: string | undefined;
    subjectId?: string;
    objectTypeId?: string | undefined;
    schoolYearId?: string | undefined;
    examId?: string | undefined;
    userId?: number | undefined;
    answers?: string | undefined;
    listFile?: FileEduDto[] | undefined;
    hourStart?: string | undefined;
    hourEnd?: string | undefined;
    dateExam?: Date | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TeaccherSessionDto implements ITeaccherSessionDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number | undefined;
    session?: number | undefined;
    position?: string | undefined;
    state?: string | undefined;
    evaluationCodes?: string | undefined;
    comment?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITeaccherSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.session = _data["session"];
            this.position = _data["position"];
            this.state = _data["state"];
            this.evaluationCodes = _data["evaluationCodes"];
            this.comment = _data["comment"];
            this.value1 = _data["value1"];
            this.value2 = _data["value2"];
            this.value3 = _data["value3"];
            this.value4 = _data["value4"];
            this.value5 = _data["value5"];
            this.value6 = _data["value6"];
            this.value7 = _data["value7"];
            this.value8 = _data["value8"];
            this.value9 = _data["value9"];
            this.value10 = _data["value10"];
            this.number1 = _data["number1"];
            this.number2 = _data["number2"];
            this.number3 = _data["number3"];
            this.number4 = _data["number4"];
            this.number5 = _data["number5"];
            this.number6 = _data["number6"];
            this.number7 = _data["number7"];
            this.number8 = _data["number8"];
            this.number9 = _data["number9"];
            this.number10 = _data["number10"];
            this.bool1 = _data["bool1"];
            this.bool2 = _data["bool2"];
            this.bool3 = _data["bool3"];
            this.bool4 = _data["bool4"];
            this.bool5 = _data["bool5"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TeaccherSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeaccherSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["session"] = this.session;
        data["position"] = this.position;
        data["state"] = this.state;
        data["evaluationCodes"] = this.evaluationCodes;
        data["comment"] = this.comment;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["bool1"] = this.bool1;
        data["bool2"] = this.bool2;
        data["bool3"] = this.bool3;
        data["bool4"] = this.bool4;
        data["bool5"] = this.bool5;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITeaccherSessionDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number | undefined;
    session?: number | undefined;
    position?: string | undefined;
    state?: string | undefined;
    evaluationCodes?: string | undefined;
    comment?: string | undefined;
    value1?: string | undefined;
    value2?: string | undefined;
    value3?: string | undefined;
    value4?: string | undefined;
    value5?: string | undefined;
    value6?: string | undefined;
    value7?: string | undefined;
    value8?: string | undefined;
    value9?: string | undefined;
    value10?: string | undefined;
    number1?: number;
    number2?: number;
    number3?: number;
    number4?: number;
    number5?: number;
    number6?: number;
    number7?: number;
    number8?: number;
    number9?: number;
    number10?: number;
    bool1?: boolean | undefined;
    bool2?: boolean | undefined;
    bool3?: boolean | undefined;
    bool4?: boolean | undefined;
    bool5?: boolean | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TeaccherSessionGuidGetDto implements ITeaccherSessionGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITeaccherSessionGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TeaccherSessionGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeaccherSessionGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITeaccherSessionGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class TeaccherSessionFilterDto implements ITeaccherSessionFilterDto {
    classId?: string;
    userId?: number | undefined;
    session?: number | undefined;

    constructor(data?: ITeaccherSessionFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.session = _data["session"];
        }
    }

    static fromJS(data: any): TeaccherSessionFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeaccherSessionFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["session"] = this.session;
        return data;
    }
}

export interface ITeaccherSessionFilterDto {
    classId?: string;
    userId?: number | undefined;
    session?: number | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id?: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IInt64EntityDto {
    id?: number;
}

export class TeacherOutputDto implements ITeacherOutputDto {
    teacherName?: string | undefined;
    listSubjectId?: string[] | undefined;
    userId?: number;
    emailAddress?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;

    constructor(data?: ITeacherOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherName = _data["teacherName"];
            if (Array.isArray(_data["listSubjectId"])) {
                this.listSubjectId = [] as any;
                for (let item of _data["listSubjectId"])
                    this.listSubjectId!.push(item);
            }
            this.userId = _data["userId"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.tenantId = _data["tenantId"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TeacherOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherName"] = this.teacherName;
        if (Array.isArray(this.listSubjectId)) {
            data["listSubjectId"] = [];
            for (let item of this.listSubjectId)
                data["listSubjectId"].push(item);
        }
        data["userId"] = this.userId;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITeacherOutputDto {
    teacherName?: string | undefined;
    listSubjectId?: string[] | undefined;
    userId?: number;
    emailAddress?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    tenantId?: number | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    id?: string;
}

export class TeacherGuidGetDto implements ITeacherGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITeacherGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TeacherGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITeacherGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class TeacherInputDto implements ITeacherInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listSubjectId?: string[] | undefined;
    userId?: number;
    emailAddress?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITeacherInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listSubjectId"])) {
                this.listSubjectId = [] as any;
                for (let item of _data["listSubjectId"])
                    this.listSubjectId!.push(item);
            }
            this.userId = _data["userId"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TeacherInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listSubjectId)) {
            data["listSubjectId"] = [];
            for (let item of this.listSubjectId)
                data["listSubjectId"].push(item);
        }
        data["userId"] = this.userId;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITeacherInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listSubjectId?: string[] | undefined;
    userId?: number;
    emailAddress?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TeacherClassGuidGetDto implements ITeacherClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITeacherClassGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TeacherClassGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITeacherClassGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class TeacherClassInputDto implements ITeacherClassInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    position?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITeacherClassInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.classId = _data["classId"];
            this.userId = _data["userId"];
            this.position = _data["position"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TeacherClassInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherClassInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["classId"] = this.classId;
        data["userId"] = this.userId;
        data["position"] = this.position;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITeacherClassInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    classId?: string;
    userId?: number;
    position?: string | undefined;
    startDate?: number | undefined;
    endDate?: number | undefined;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class TuitionFeeGuidGetDto implements ITuitionFeeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;

    constructor(data?: ITuitionFeeGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.language = _data["language"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            if (Array.isArray(_data["sValue"])) {
                this.sValue = [] as any;
                for (let item of _data["sValue"])
                    this.sValue!.push(item);
            }
            if (Array.isArray(_data["lValue"])) {
                this.lValue = [] as any;
                for (let item of _data["lValue"])
                    this.lValue!.push(item);
            }
            if (Array.isArray(_data["gValue"])) {
                this.gValue = [] as any;
                for (let item of _data["gValue"])
                    this.gValue!.push(item);
            }
            if (Array.isArray(_data["dValue"])) {
                this.dValue = [] as any;
                for (let item of _data["dValue"])
                    this.dValue!.push(item);
            }
            if (Array.isArray(_data["tValue"])) {
                this.tValue = [] as any;
                for (let item of _data["tValue"])
                    this.tValue!.push(new Date(item));
            }
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(CriteriaRequestDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TuitionFeeGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TuitionFeeGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (Array.isArray(this.sValue)) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (Array.isArray(this.lValue)) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (Array.isArray(this.gValue)) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (Array.isArray(this.dValue)) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (Array.isArray(this.tValue)) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITuitionFeeGuidGetDto {
    tenantId?: number | undefined;
    userId?: number | undefined;
    id?: string;
    language?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    sValue?: string[] | undefined;
    lValue?: number[] | undefined;
    gValue?: string[] | undefined;
    dValue?: number[] | undefined;
    tValue?: Date[] | undefined;
    criterias?: CriteriaRequestDto[] | undefined;
    sorting?: string | undefined;
    skipCount?: number;
    maxResultCount?: number;
}

export class TuitionFeeInputDto implements ITuitionFeeInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listClassId?: string[] | undefined;
    listSubjectId?: string[] | undefined;
    listExemption?: TuitionDto[] | undefined;
    listDocument?: TuitionDto[] | undefined;
    listTuition?: TuitionDto[] | undefined;
    listTotalTuition?: TuitionDto[] | undefined;
    listUnitPrice?: TuitionDto[] | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    discounts?: string | undefined;
    numberSessions?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;

    constructor(data?: ITuitionFeeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listClassId"])) {
                this.listClassId = [] as any;
                for (let item of _data["listClassId"])
                    this.listClassId!.push(item);
            }
            if (Array.isArray(_data["listSubjectId"])) {
                this.listSubjectId = [] as any;
                for (let item of _data["listSubjectId"])
                    this.listSubjectId!.push(item);
            }
            if (Array.isArray(_data["listExemption"])) {
                this.listExemption = [] as any;
                for (let item of _data["listExemption"])
                    this.listExemption!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listDocument"])) {
                this.listDocument = [] as any;
                for (let item of _data["listDocument"])
                    this.listDocument!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listTuition"])) {
                this.listTuition = [] as any;
                for (let item of _data["listTuition"])
                    this.listTuition!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listTotalTuition"])) {
                this.listTotalTuition = [] as any;
                for (let item of _data["listTotalTuition"])
                    this.listTotalTuition!.push(TuitionDto.fromJS(item));
            }
            if (Array.isArray(_data["listUnitPrice"])) {
                this.listUnitPrice = [] as any;
                for (let item of _data["listUnitPrice"])
                    this.listUnitPrice!.push(TuitionDto.fromJS(item));
            }
            this.courseId = _data["courseId"];
            this.objectTypeId = _data["objectTypeId"];
            this.discounts = _data["discounts"];
            this.numberSessions = _data["numberSessions"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeData = _data["codeData"];
            this.valueData = _data["valueData"];
            this.category = _data["category"];
            this.permissions = _data["permissions"];
            this.language = _data["language"];
            this.status = _data["status"];
            this.hideValue = _data["hideValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TuitionFeeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TuitionFeeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.listClassId)) {
            data["listClassId"] = [];
            for (let item of this.listClassId)
                data["listClassId"].push(item);
        }
        if (Array.isArray(this.listSubjectId)) {
            data["listSubjectId"] = [];
            for (let item of this.listSubjectId)
                data["listSubjectId"].push(item);
        }
        if (Array.isArray(this.listExemption)) {
            data["listExemption"] = [];
            for (let item of this.listExemption)
                data["listExemption"].push(item.toJSON());
        }
        if (Array.isArray(this.listDocument)) {
            data["listDocument"] = [];
            for (let item of this.listDocument)
                data["listDocument"].push(item.toJSON());
        }
        if (Array.isArray(this.listTuition)) {
            data["listTuition"] = [];
            for (let item of this.listTuition)
                data["listTuition"].push(item.toJSON());
        }
        if (Array.isArray(this.listTotalTuition)) {
            data["listTotalTuition"] = [];
            for (let item of this.listTotalTuition)
                data["listTotalTuition"].push(item.toJSON());
        }
        if (Array.isArray(this.listUnitPrice)) {
            data["listUnitPrice"] = [];
            for (let item of this.listUnitPrice)
                data["listUnitPrice"].push(item.toJSON());
        }
        data["courseId"] = this.courseId;
        data["objectTypeId"] = this.objectTypeId;
        data["discounts"] = this.discounts;
        data["numberSessions"] = this.numberSessions;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["status"] = this.status;
        data["hideValue"] = this.hideValue;
        data["id"] = this.id;
        return data;
    }
}

export interface ITuitionFeeInputDto {
    tenantId?: number | undefined;
    creatorUserId?: number | undefined;
    creationTime?: Date;
    listClassId?: string[] | undefined;
    listSubjectId?: string[] | undefined;
    listExemption?: TuitionDto[] | undefined;
    listDocument?: TuitionDto[] | undefined;
    listTuition?: TuitionDto[] | undefined;
    listTotalTuition?: TuitionDto[] | undefined;
    listUnitPrice?: TuitionDto[] | undefined;
    courseId?: string | undefined;
    objectTypeId?: string | undefined;
    discounts?: string | undefined;
    numberSessions?: number;
    name?: string | undefined;
    code?: string | undefined;
    codeData?: string | undefined;
    valueData?: string | undefined;
    category?: string | undefined;
    permissions?: string | undefined;
    language?: string | undefined;
    status?: string | undefined;
    hideValue?: string | undefined;
    id?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}